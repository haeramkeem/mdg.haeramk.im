---
tags:
  - CMU-15445
  - Database
date: 2024-07-04
---
> [!info]- CMU CS DB Andy Pavlo 교수님의 "Intro. to Database Systems" 강의를 필기한 내용입니다.
> - [강의](https://youtu.be/n9S4Ibh5O0E?si=he8YVHmloAMXFMPl)

> [!info] 본 글의 그림들은 별도의 명시가 없는 한 해당 강의 자료에서 가져왔습니다.

> [!warning] 다소 잘못된 내용과 구어적 표현 이 포함되어 있을 수 있습니다.

> [!tip]- 수업에 사용된 SQL
> - [여기](https://github.com/haeramkeem/compose-postgres/blob/main/sql/lecture02.fall2023.15445.cources.cs.cmu.edu.sql)

## History

- 저번 시간에도 말한것 처럼 Relational Model 은 어떠한 Programming language 도 제시하지 않았고, 그냥 수학적인 모델일 뿐이었다.
- 그러다가 IBM 이 1972 년도에 이 Relational Model 을 도입한 Square 라는 언어를 개발했는데,
	- 근데 이놈은 문법이 너무 기괴해서 사망띠
- 그리고 그 이후에 IBM 은 *Structured English Query Language* 를 줄여 *SEQUEL* 을 제시했고, 이것이 나중에 *SQL* 로 발전하게 된다.
- 추가적으로 UC Berkely 에서 *Ingres* 라는 DBMS 와 SQL 을 제시했는데, 이것이 발전한게 그 유명한 Postgres 이다. (Post-ingres)
- 뭐 그리고 IBM 에서는 이후로 SQL 에 기반한 System-38, SQL-DL, DB2 같은 여러 상업 DBMS 를 출시했다고 한다.
- SQL 은 1986년에 미국 표준 (ANSI) 로 등록되고, 1987년에는 국제 표준 (ISO) 으로 등록되었으며, 2023년까지도 지속적으로 버전업데이트를 하고 있다고 한다.
	- 근데 이건 표준일 뿐이고 각 DBMS 에서 이 표준의 특정 기능을 지원하는지의 여부는 각기 다르다.
	- 거의 모든 DBMS 에 구현된 "최소한의" 기능은 SQL-92 표준이라고 한다.

## SQL

- 대략 네 파트로 나누어 볼 수 있다고 한다.
	- *Data Management Language* (*DML*): 데이터 다루기 (Insert, select 등등)
	- *Data Definition Language* (*DDL*): Scheme 정의 (Create table, view 등)
	- *Data Control Language* (*DCL*): 얘는 ACL 같은 거다 - 뭐 접근제어 (보안) 등
	- 그리고 그 외에 *Transaction* 과 같은 내용들..
- 그리고 앤디씨가 여기서 짚고 넘어간 점은 SQL 은 *Bag* 를 다루고 있고, 따라서 중복이 가능하다는 점이다.
	- 반면에 Relational algebra 에서는 안된다. (*Set* 을 다룸)
- 여담으로 SQL 이라는 표준이 있지만 각 DBMS 에서는 이것을 잘 따르지 않고 지맘대로 한다고 한다.
	- 특히 (최근에는 좀 나아졌지만) MySQL 은 진짜 청개구리라네
- SQL 은 그 자체로 최대한 많은 것을 제공해 주는 식으로 발전해 왔다고 한다.
	- 이게 뭔소리냐면, 가령 어떤 domain 을 변경하는 것은 `SELECT` 로 데이터를 가져와서 변경한 뒤 다시 `INSERT` 로 넣는 방식도 가능하다.
	- 하지만 Application code 로 이런 것을 하게 두기 보다는 이런 작업을 SQL 표준으로 만들어서 그냥 `UPDATE` keyword 만 사용하면 되게끔
	- 즉, DBMS 에서 최대한 많은 것을 해주려는 일종의 맥시멀리즘의 성향을 띈다고 한다.
- 그럼 이제 SQL 표준의 여러 기능들을 살펴보자.

## Aggregation function

- *Aggregation function* 은 ==Bag of tuple 를 input 으로 받아, 하나의 "값" 을 output 으로 주는 함수==이다.
	- 말만 들으면 복잡한데 아래 예시 보면 별거 아니다.
		- `AVG(col)`: 해당 column 에 대한 평균
		- `MIN(col)`: 해당 column 에 대한 최소값
		- `MAX(col)`: 해당 column 에 대한 최대값
		- `SUM(col)`: 해당 column 에 대한 합계
		- `COUNT(anything...)`: tuple 들의 개수
			- `anything...` 이라고 적어놓은 것은 column 은 아무래도 상관 없기 때문이다.
- 이놈은 `SELECT` 절에 들어가 결과를 합쳐준다.
- 가령 `COUNT` 로 예를 들어 보면 

```sql
SELECT COUNT(*) FROM student WHERE login LIKE '%@cs';
```

![[Pasted image 20240704221124.png]]

- 여러개의 Aggregation 을 사용하는 것도 가능하다

```sql
SELECT AVG(gpa), COUNT(*) FROM student WHERE login LIKE '%@cs';
```

![[Pasted image 20240704221141.png]]

## `GROUP BY`

- Aggregation 을 사용할 때, `SELECT` 에 Aggregation 되지 않은 것을 그냥 쓸 수는 없다.
- 가령 다음 구문은 에러가 난다.

```sql
SELECT AVG(s.gpa), e.cid
FROM enrolled AS e JOIN student AS s
ON e.sid = s.sid;
```

![[Pasted image 20240704221200.png]]

- 왜냐면 `AVG(s.gpa)` 의 경우에는 aggregate 되어 하나의 결과로 나오지만, `e.course_id` 의 경우에는 하나로 합쳐지지 않기 때문.
- 그래서 이때는 `GROUP BY` 를 사용하면 된다.

```sql {4}
SELECT AVG(s.gpa), e.cid
FROM enrolled AS e JOIN student AS s
ON e.sid = s.sid
GROUP BY e.cid;
```

![[Pasted image 20240704221219.png]]

- 이렇게 하면 같은 `e.course_id` 를 가지는 row 들이 그루핑되어 해당 그룹에 대한 `AVG(s.gpa)` 가 계산된다.
- 즉, `GROUP BY` 는 ==지정해준 column 을 기준으로 subbag 을 만든 뒤, 해당 subbag 에 대해 aggregation 을 할 수 있도록 해주는 키워드==이고,
- `SELECT` 절에 있는 모든 non-aggregated value 들은 반드시 `GROUP BY` 로 그루핑되어야 한다.
	- 물론 근데 DBMS 마다 조금씩은 차이가 있다.
		- 대부분은 에러가 나지만
		- MySQL 을 `"traditional"` mode 로 바꾼 경우나
		- SQLite 의 경우에는 결과가 나오긴 한다.
			- 다만 이때는 non-aggregated value 의 경우 그냥 임의로 하나의 값을 고르는 듯 하다; 어떤 값이 나오든 간에 잘못된 행동이고, 에러가 나는게 SQL 표준에 맞는 것이다.

![[Pasted image 20240704195539.png]]

## `HAVING`

- 만약에 aggregation 의 결과에 대해 조건을 걸기 위해 `WHERE` 절에 넣으면 어떻게 될까?

```sql {4}
SELECT AVG(s.gpa) AS avg_gpa, e.cid
FROM enrolled AS e, student AS s
WHERE e.sid = s.sid
AND avg_gpa > 3.9
GROUP BY e.cid;
```

![[Pasted image 20240704221401.png]]

- 보다시피 에러가 난다.
	- 이것은 Aggregation 이 마지막에 수행되기 때문에, `WHERE` 절에서는 `avg_gpa` 가 뭔지 모르기 때문.
- 이때 `HAVING` 을 사용하면 된다.

```sql {5}
SELECT AVG(s.gpa) AS avg_gpa, e.cid
FROM enrolled AS e, student AS s
WHERE e.sid = s.sid
GROUP BY e.cid
HAVING AVG(s.gpa) > 3.9;
```

![[Pasted image 20240704221732.png]]

- 다만 이때는 주의할 점이 있다.
	- `HAVING` 절은 `GROUP BY` 다음에 와야 한다. 이전에 오면 에러남
	- `HAVING` 절에는 `AS` 로 지정된 alias 를 사용할 수는 없다. 이것도 "column 을 찾을 수 없다" 는 에러가 난다.
		- 참고로 내부 optimizer 에 의해 알아서 최적화 되기 때문에, 이렇게 한다고 해서 `AVG` 가 두번 연산되지는 않는다.
- 즉, `HAVING` 은 ==Aggregation 에 대해 필터링을 하고 싶을 때 사용하는 문법==이다.