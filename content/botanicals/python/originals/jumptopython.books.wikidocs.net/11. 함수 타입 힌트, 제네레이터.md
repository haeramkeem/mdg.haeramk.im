> [!info] 위키북스 박응용 저 "점프 투 파이썬" 책을 읽고 정리한 내용입니다.

> [!warning] 다소 잘못된 내용과 구어적 표현 이 포함되어 있을 수 있습니다.

## 타입 힌트

- 파이썬에서는 자료형의 종류를 동적으로 할당한다
- 하지만 이렇게 할 경우 편리하기는 하지만 가독성도 떨어지고 연산중 자료형이 안맞아 오류가 날 수 있다
- 그래서 파이썬에서는 이 타입 힌트라는 기능을 제공한다
- 변수의 경우 `변수: 자료형` 으로 타입 힌트를 줄 수 있고
- 반환값의 경우 `-> 자료형` 으로 타입 힌트를 줄 수 있다
- 다만 말 그대로 타입 힌트이므로 이것을 따르지 않았을 경우 경고만 할 뿐 따로 에러처리를 하지는 않는다
	- 즉, 타입힌트를 써줘도 얼마든지 동적으로 할당될 수 있으므로 조심해야한다
- 파이썬에서 `pip install mypy` 를 해주면 `mypy` 가 깔리게 되는데, 요놈을 이용하면 타입 힌트랑 자료형이랑 안맞을때 오류처리를 해 손쉽게 고칠 수 있도록 도와준다

### 타입 힌트를 활용한 함수선언

```python
def func_name(arg1: type, arg2: type) -> type :
	return 반환할거
```

- `arg: type` : 매개변수와 매개변수의 타입
- `-> type` : 리턴값의 타입

## 제네레이터

- 제네레이터는 어떤 많은 값들을 생성해서 사용해야할때 전부 다 만들어놓고 사용하는게 아닌 *만드는 방법만 저장했다가 호출시에 바로바로 만들어 쓰는 개념* 이다
- 대표적인예로 `range()` 함수를 알아보자
	- 5조5억개의 숫자를 생성해야한다고 가정해보자
	- 이때 `l1 = [n+1 for n in range(0, 오조오억)]` 으로 그냥 리스트를 생성하고
	- `l2 = range(0, 오조오억)` 이렇게 해줬을때 두가지는 인덱스로 접근도 가능하고, iterate도 사용할 수 있으니 같은 기능을 제공한다고 할 수 있다
	- 심지어 `len()` 으로 요소의 갯수를 구해도 같은 값을 출력한다
	- 하지만 이 둘의 메모리 소모를 보면 확연히 차이가 난다 - *l2가 현저히 적은 양의 데이터를 먹는다*
	- 이것은 l1는 오조오억개의 숫자를 미리 만들어서 저장하고 있지만, l2의 경우에는 숫자를 생성하는 방법만 저장하고 실질적으로 만든 숫자는 가지고 있지 않기 때문
	- 따라서 제네레이터는 같은 기능을 제공하지만 현저히 적은 메모리를 먹는다는 장점이 있다
- 일반 함수에서 제네레이터 기능 사용하기 : `yield`
	- `return` 같은 경우에는 반환하면 바로 함수가 종료되지만 `yield` 의 경우에는 *종료되지 않는다*
	- `return` 같은 경우에는 반환값이 그대로 반환되지만 `yield`는 *제네레이터 객체가 반환된다**
	- `next(반환된 제네레이터 객체)` 를 이용해 다음으로 함수가 반환할 값을 그때그때 받아서 쓸 수가 있다
	- 이것도 `return` 의 경우에는 값을 다 만들어서 반환하지만 `yield` 의 경우에는 값을 만드는 방법을 저장했다가 `next()` 로 호출할때마다 그때그때 값을 만들기 때문임

## 제네레이터 함수

```python
yield 반환할거 # 함수 return문 대신
next(제네레이터 객체) # 제네레이터 호출
```

- 함수를 제네레이터형으로 선언하고싶으면 `return` 대신 `yield` 를 사용하면 된다
- 대신 함수의 반환값이 제네레이터 객체이므로 다음 값을 받고싶을때는 `next()` 를 이용하면 된다
- 함수의 반환값이 제네레이터 객체이고 다음값을 받을떄는 `next()` 를 써야된다는 점을 꼭 기억할 것