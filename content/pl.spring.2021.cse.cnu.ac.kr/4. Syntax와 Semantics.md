
> [!info] 충남대학교 컴퓨터공학과 이성호 교수님의 "프로그래밍 언어 개론" 강의를 필기한 내용입니다.

> [!warning] 강의를 듣고 필기한 내용이기에, 다소 잘못된 부분과 ~~부적절한 언행~~ 이 포함되어 있을 수 있습니다.

## Imperative <-> Declarative

- **Imerative** : 보통의 명령들을 나열해 문제를 푸는 방법을 선언하는 방식으로 프로그래밍 하는 것
- **Declaraive** : 문제를 푸는 방법을 적는게 아니라 어떤 문제인지를 적어서 프로그래밍하는 방법
	- 문제는 얘가 알아서 풀어준다
	- 옛날에는 구렸는데 요즘은 엔진이 좋아져 종종 쓰인댄다
	- SQL같은게 여기에 해당한다고 할 수 있음

## 프로그래밍 언어의 번역 vs 해석

### Compile

- 번역은 그냥 동일한 의미의 기계어로 바꾸는 것 (Compiled language)
- 오류를 컴파일 타임에 잡을 수 있다
- 프로그램 전체를 검토해 기계어로 바꾸기 때문에 최적화 가능 (성능의 이점)
- 비교적 low level이어서 시스템 프로그래밍에도 사용할 수 있다
- 다만 비교적 배우기 어렵고 컴파일 과정이 복잡하다
- 그리고. **static-typed language**이다
	- 컴파일 시점에 변수들의 자료형이 모두 결정된다
- 자바같은 경우에는 JVM이라는 가상 기계어 환경으로 컴파일해 구동하는 과정을 거친다
	- 여러 플랫폼에서 일관되게 지원하기 위함

### Interprete

- 해석은 언어를 읽고 이해해 바로 실행하는 것 (Interpreted language)
- interprete는 프로그램을 통째로 컴파일하는 과정이 아닌 바로바로 해석해서 실행하게 된다
	- 컴파일의 경우에는 통째로 번역하기 때문에 최적화가 용이하지만 인터프리트의 경우 한줄한줄 바로바로 실행하기 때문에 최적화가 어려움
	- 속도가 비교적 느리다
- 간단한 검증만을 수행하기 때문에 오류를 미연에 방지하기는 컴파일 언어보다 어렵다
- 대신 배우기 쉽고 자유로우며 자료형들이 동적으로 선언(**Dynamic-typed language**)된다
- 스크립트 언어들이 여기에 해당된다
- 그리고 shell들도 이런식으로 구동된다

## 프로그래밍 언어의 구성

- 프로그래밍 언어는 syntax와 semantics로 구성되며 얘네들은 해당 언어의 **specification(사용 설명서)** 에 기술된다
- **Syntax** : 명령어들이 어떻게 생겼는지
- **Semantics** : 해당 syntax가 어떻게 작동하는지를 기술
	- syntax별로 semantics가 정의되게 된다

## Unspecified Behaviors

- 특정 syntax에 대해 일부로 semantics를 정의 않는 것
- 동작을 정의하는데에 있어 자유를 부여함
	- 이때 자유라는 것은 나의 자유가 아니라 어떻게 동작할지는 해당 언어의 컴파일러 / 인터프리터 개발자의 자유이다
	- 얘네들을 개발할때 임의적으로 정의해서 개발을 하게 된다는 것
	- 컴파일러 / 인터프리터에 따라 다르게 작동할 수 있다
- 보통 어떻게 정의하든 별로 중요하지 않을 때 이런식으로 기술한다
	- 정의가 중요했으면 당연히 semantics를 정의했겠지
- 다만 개발자는 얘가 semantics를 정의하지 않은 놈이라는것을 알고는 있어야 한다

## Undefined Behaviors

- 특정 syntax에 대해 semantics가 정의 않은 것
- 얘네들은 약간 에러같은애들이다
	- 프로그램을 오작동하게 하지만 에러로 처리하기에는 성능면에서 안좋거나 하는 등의 사유가 있는 애들
- 얘를들어서 쓰레기값에 접근하는 경우이다
	- 얘네들은 에러는 안나지만 undefined여서 오작동하게 된다
- 따라서 개발자는 어떤 경우에 undefined인지를 반드시 숙지해야 한다