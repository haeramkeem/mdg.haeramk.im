> [!info] 충남대학교 컴퓨터공학과 이성호 교수님의 "프로그래밍 언어 개론" 강의를 필기한 내용입니다.

> [!warning] 다소 잘못된 내용과 구어적 표현 이 포함되어 있을 수 있습니다.

## 언어의 확장 과정

1. Concrete syntax의 확장
2. Abstract syntax의 확장
3. Parser의 확장(CS → AS로 바꿔주는놈이 parser이므로)
4. Semantics 확장(Abstract Syntax가 확장되었으므로)
5. Interpreter 수정(AS → 기계어)
- 컴파일 언어의 경우 더 많은 확장 단계를 가지게 된다

## Syntactic Sugar

- Concrete syntax를 확장하되 확장된 구문을 기존의 Abstract syntax에 대응시키는 기법을 말함
- CS를 확장하므로 CS와 CS를 사용하는 parser는 확장해야 되지만 AS나 semantics 등은 확장하지 않아도 된다
- parser가 이 설탕쳐진 구문(확장된 CS)에서 설탕을 빼는 과정(기존의 CS로 변환하여 기존의 AS로 변환하는 과정)을 **Desugaring**이라고 한다
- 하나의 AS에 대응되는 CS가 여러개가 되는 셈인거다
	- 따라서 CS를 하나 정의하고 그것을 기존의 AS에 대응만 시켜주면 되는 셈

## Identifiers

- **Identifier(식별자)** : 함수, 변수, 프로퍼티, 메소드, 클래스들에 붙이는 이름을 식별자라 한다

## Occurrence of Identifier

- **Occurrence of Identifiers** : 하나의 식별자는 프로그램에 여러번 등장할 수 있다는 개념

### 등장의 종류

- **Binding Occurrence** : 식별자의 정의를 위한 등장
- **Bound Occurrence** : 정의된 식별자를 사용하기 위한 등장
- **Free Occurrence** : 정의되지 않은 식별자를 사용하기 위한 등장

## Scope of Identifier

- Binding된 놈이 Bound될 수 있는 범위
- 따라서 bind되어도 scope를 넘어가면 free identifier가 된다
- **Shadowing** : 동일한 이름을 가진 식별자들의 scope가 겹치는 경우 bound했을 때 가장 가까운(가장 안쪽의, 가장 지협적인) scope를 따라가게 된다
	- 가장 가까운 놈이 먼 놈을 가린다는 의미에서 shadowing이라고 하는 것

## Store

- 요기 나오는 내용은 전부 언어 AE를 위해 수업에서 임의로 정의한 것이다
	- 개념은 통용되지만 용어나 구체적인 내용들은 수업용임
- **Store** : 가상 저장공간들의 집합
	- 가상 저장공간이라는 것은 변수를 받아 정수를 돌려주는 하나의 함수라고도 표현할 수 있다 (변수를 이용해 그 정수에 접근하는 것 이므로)
	- 근데 함수는 딕셔너리와도 유사하다(키를 이용해 벨류를 반환하므로)
	- 따라서 가상 저장공간은 변수를 받아 정수를 반환하는 딕셔너리라고도 생각할 수 있다
	- 가상메모리 = 변수이름을 받아 값을 돌려주는 함수 = 변수이름을 키로 받아 매핑된 값을 돌려주는 딕셔너리
- 가상 저장공간 집합 Store는 변수를 받아 정수로 돌려주는 모든 함수(딕셔너리)들의 집합이다
- 시그마 는 Store의 원소이다. 즉, 임의의 한 가상 저장공간(함수, 딕셔너리)이라는 말이다
- **시그마\[x → n\]** : 변수 x를 선언하고 n으로 초기화 하는 것(binding)
	- 즉, x를 받으면 n을 반환하는 규칙을 새로 함수에 추가하는 것
	- 즉, 키x와 값n을 딕셔너리에 추가하는 것
	- 선언, 초기화 후 업데이트된 시그마를 반환
- **시그마(x)** : 변수 x의 값(n)을 찾아 반환 하는 것(bounding)
- **추상메모리 ~에서** 라는 말의 말뜻 : 이게 말이 좀 어려울 수 있는데 그냥 이런뜻이다
	- e에서 변수가 등장하지 않으면 이 메모리를 사용하지 않아도 되니까 추상메모리에서 라는 말은 별 의미없는 말이다.
	- 근데 e에서 변수가 등장한다면 이 변수를 정수로 고치는 바꾸는 것은 저 추상메모리에 정의된 규칙을 따른다는 소리이다
- **ternary relation** : 말뜻은 뭔지 모르게땅
	- 이것의 기호는 `ㅏ` 이고 계산 문맥을 표현한다
	- 즉, `EC ㅏ p` 는 EC라는 규칙 하에 p가 참이라는 소리이다
	- 전제랑 문맥의 차이점은 이거다
		- 어떤 연산을 하기 위해 반드시 참으로 규명나야 되는 것은 전제로 들어간다.
		- 하지만 연산을 하기 위해 이용할 수도 있고 아닐수도 잇는 것은 문맥으로 들어간다?
- 따라서 해당 추상메모리에서 표현식e를 계산했더니 정수n이 나왔다면 이 관계는 `(추상메모리) ㅏ \[(표현식e) 아래화살표 (정수n)\]` 로 말할 수 있는 것이다
	- 수업에서는 대괄호를 안쳐줬지만 생략된 것이므로 해당 추상메모리 하에서 “표현식 e는 정수 n으로 계산됨”은 참이라는 것을 뜻한다