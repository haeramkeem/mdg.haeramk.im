> [!info] 위키북스 박응용 저 "점프 투 파이썬" 책을 읽고 정리한 내용입니다.

> [!warning] 다소 잘못된 내용과 구어적 표현 이 포함되어 있을 수 있습니다.

## 파이썬의 리스트는 다른 리스트들과 다르게 구현되어 있다

- c나 자바의 경우에는 리스트에 요소로 들어갈 자료형의 정수배를 하여 리스트의 메모리를 할당한다
	- 이 경우에는 연속된 메모리 공간에 인덱스 순서대로 리스트의 요소가 저장되므로 인덱스를 지정하면 간단한 연산만으로 메모리 주소를 알 수 있어 매우 빠르다
	- 하지만 이 경우에는 리스트에 같은 자료형의 요소만 저장할 수 있고 선언된 리스트의 크기를 넘어서면 에러가 발생하는 등 불편한 점이 있다
- 하지만 파이썬은 속도를 양보하고 편의성을 가져왔다. 즉, 파이썬의 경우 연속된 메모리 공간에 리스트의 요소를 저장하지 않는다
	- 파이썬에서는 요소들의 주소를 하나의 배열로 관리하는 형식을 취하며, 요소가 추가되면 리스트의 다음 공간에 추가하는 방식이 아닌 추가된 요소의 주소를 주소배열에 넣어주는 방식이다
	- 이 방식은 새로 요소가 추가되면 요소를 메모리 어딘가에 할당하고 이것의 주소를 주소배열에 연결해주고, 요소가 삭제되면 주소배열과 요소와의 연결을 끊어주는 방식으로 요소 추가와 삭제가 이루어진다
- 이 방식의 장점은 기술한대로 편리함에 있다.
	- 실제로 요소들이 차지하는 메모리 공간은 단순한 특정 자료형의 정수배가 아니기 떄문에, *리스트에 다양한 자료형을 추가해도 문제가 되지 않는다*
	- 또한 리스트의 크기가 제한적이지 않으며 언제든 *리스트의 크기를 늘리거나 줄일 수 있다* 는 장점이 있다
- 하지만 *단점은 기술한 대로 속도* 이다.
	- 주소배열이 저장하고 있는 주소들은 반드시 인덱스 순서대로라고 할 수 없다.
	- 요소가 추가되면 주소배열의 빈공간에 그냥 넣어주고 삭제되면 그 요소가 차지하던 주소배열의 자리를 그냥 비워주면 되기 때문이다
	- 따라서 간단한 인덱스를 통한 값 조회의 경우에도 모든 주소배열의 주소로 들어가 값과 데이터타입, 요소들이 저장하고 있는 인덱스 값을 비교해야 되므로 단순한 연산으로 끝나지 않게 된다

## 생성자

```python
a = list()
a = list(iterable)
```

- 인자를 아무것도 안주면 빈 리스트를 생성해서 반환한다
- 반복가능한 객체를 인자로 주면 그 객체의 내용을 리스트화해서 반환한다

## 요소 추가

```python
a.append(b)
a += [b]
a.extend([b])
a.insert(i, b)
```

- 리스트 `a` 의 맨 뒤에 요소 `b` 를 추가하거나 인덱스 `i` 에 요소 `b` 를 추가하는 메소드들
- `+=` 연산이랑 `extend()` 는 같은 기능을 한다
- 이미 선언된 리스트에만 요소 추가가 가능하다. - `[1, 2].append(3)` 같은 연산은 불가능하다

## 요소 삭제

```python
del a[i]
a.remove(b)
a.pop()
a.pop(0)
```

- `del` : 인덱스로 접근해 삭제
- `remove()` : 입력값과 같은 값을 가지는 첫 요소를 삭제
- `pop()` : 맨 뒷 요소를 삭제
- `pop(0)` : 맨 앞 요소를 삭제
- `pop()` 이 O(1)로 제일 빠르고 다른애들은 선형비교를 해야하기 때문에 O(n)이다

## 문자열로 만들기

```python
'a'.join(a)
```

- 리스트a의 요소 사이사이에 `’a’` 를 넣어서 하나의 문자열로 만든다

## 대소비교

```python
[3, 4] > [1, 2] # True
[3, 4] >= [1, 2] # True
[1, 2] == [1, 2] # True
```

- 리스트도 문자열마냥 앞의 인덱스부터 차례대로 대소비교해 전체 리스트의 대소를 판별한다

## 리스트 반복

```python
[1, 2, 3]*3
```

- 결과는 `[1, 2, 3, 1, 2, 3, 1, 2, 3]` 이다

## 파이썬에서 제공하는 강력한 정렬함수 : sort, sorted

```python
a.sort()
sorted(a)
```

- `sort()` : a를 내부적으로 정렬한다
- `sorted()` : a를 정렬한 결과를 반환한다
- 그냥 `sort()` 메소드는 리턴값이 없다는것에 주의해야한다
- 생략가능한 매개변수 `key=func` 를 통해 정렬의 기준을 정할 수 있다
	- 내가 이 기능을 다시 이용할지는 모르겠지만, key로 전달하는 함수의 리턴값이 튜플이라면, 인덱스가 우선인 것을 기준으로 정렬하고 이것으로 정렬이 불가능하면 그때 뒤의 인덱스로 기준을 옮겨가며 정렬한다
- 팀소트의 `O(nlogn)` 의 아주 빠른 함수이다

## 순서 뒤집기

```python
a.reverse()
a[:]
```

- 리스트 `a` 의 순서를 뒤집은 결과를 반환한다

## 인덱스 반환

```python
a.index(123)
```

- `123` 의 위치를 `a` 에서 찾아서 반환한다

## 요소 갯수 세기

```python
a.count(123)
```

- `123` 의 갯수를 `a` 에서 세어서 반환한다

## 요소인지 아닌지

```python
${OBJ} in ${LIST}
${OBJ} not in ${LIST}
```

- `in` : 객체가 리스트의 요소이면 `True`, 요소가 아니면 `False` 를 반환
- `not in` : 그 반대

## 인덱스와 값을 같이 갖고오기

```python
enumerate(lst)
```

- 리스트를 받아 `(인덱스, 값)` 의 튜플을 요소로 하는 반복가능객체로 반환한다

## 최대/최소

```python
max(lst)
min(lst)
```

- `max` 는 요소의 최대값을, `min` 은 요소의 최소값을 리턴한다
- 생략가능한 매개변수 `key=func` 를 통해 최대/최소의 기준을 정할 수 있다