---
tags:
  - cpp
  - cpp-number
date: 2024-07-22
---
## Bitwise

- int, float, double 이 뭔지는 대략 알거고
- 이게 어떻게 표현되는지 한번 보자.
- 다음의 함수로 여러 값들을 bitwise 로 출력해보자.

```cpp
#include <iostream>
#include <string>
#include <vector>

template <typename T>
void PrintBits(T num) {
	// Type 변환
	union {
		T input;
		uint64_t output;
	} data;
	data.input = num;

	// Bit 쪼개기
	std::vector<size_t> acc;
	for (size_t i = 0; i < sizeof(T) * 8; i++) {
		acc.push_back((data.output >> i) & 0x1);
	}

	// 역순 출력
	for (int i = 0; i < acc.size(); i++) {
		std::cout << acc[acc.size() - 1 - i];
	}
	std::cout << std::endl;
}
```

## Integer

### Positive

- 일단 양의 정수의 경우에는 그냥 이진수로 저장된다고 생각하면 된다.
- 가령 32 의 경우에는, 다음처럼 된다.

```cpp
int main() {
	PrintBits<int>(32);
}
```

```
00000000000000000000000000100000
```

### Negative

- 음의 정수의 경우에는 양의 정수를 [[Integer Representation (Arch)|2의 보수]] 로 만들면 된다.

```cpp
int main() {
	PrintBits<int>(-32);
}
```

```
11111111111111111111111111100000
```

- 즉, 이렇게 표현된다.

```
32 =                      00000000000000000000000000100000
1보수(32) =                11111111111111111111111111011111
2보수(32) = 1보수(32) + 1 = 11111111111111111111111111100000
```

- 이렇게 음의 정수를 표현하는 것에는 이점이 두가지 있다.
- 첫번째는 연산이 쉽다는 것이다. 가령 $8 + (-2)$ 는 다음과 같이 계산될 수 있다.

```
8 =  00000000000000000000000000001000
-2 = 11111111111111111111111111111110
+ =  00000000000000000000000000000110 (= 6)
```

- 즉, bitwise operation을 하고 overflow 된 부분을 버리는 것만으로 정수값 계산이 가능하다.
	- 뭐 음수를 양수로 바꿔서 계산하고 이런 귀찮은게 필요 없다 이거야.
- 두번째는 0 을 표현하기 편하다는 것이다.
- 가령 0 은 이진수로도 그냥 0이다.

```
0 = 00000000000000000000000000000000
```

- 그럼 -0 의 경우에는 어떨까? 0 과 -0 은 같기 때문에 당연히 동일하게 표현되는 것이 상식적일 것이다. 실제로도 0 에다가 2의 보수를 취해도 동일한 것을 알 수 있다.

```
0 =                      00000000000000000000000000000000
1보수(0) =                11111111111111111111111111111111
2보수(0) = 1보수(0) + 1 =  00000000000000000000000000000000
```