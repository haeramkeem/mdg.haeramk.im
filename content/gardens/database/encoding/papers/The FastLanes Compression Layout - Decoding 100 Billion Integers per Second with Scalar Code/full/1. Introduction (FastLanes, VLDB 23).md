---
tags:
  - database
  - db-encoding
date: 2024-08-24
title: (논문) The FastLanes Compression Layout - Decoding 100 Billion Integers per Second with Scalar Code (1. Introduction)
---
> [!info] 본 글은 논문 [The FastLanes Compression Layout: Decoding > 100 Billion Integers per Second with Scalar Code (VLDB '23)](https://dl.acm.org/doi/10.14778/3598581.3598587) 를 읽고 정리한 글입니다.

> [!info] 별도의 명시가 없는 한, 본 글의 모든 그림은 위 논문에서 가져왔습니다.

> [!info]- 목차
> - [[1. Introduction (FastLanes, VLDB 23)|1. Introduction (현재 글)]]

## 1. Instruction

### 1.0. Overview

- [[On-Line Analytical Processing, OLAP (Database)|OLAP]] 과 같은 시스템에서는 보통 columnar data format 을 많이 이용한다. 그 이유는:
	- Row data 를 load 하면 불필요한 column 까지 load 되기 때문
	- Columnar data 는 compression 이 용이해 보통 데이터의 크기가 더 작기 때문

#### 1.0.1. Vectorized execution

- *Chunk* (*Vector*) 단위로 query execution 을 처리하는 것을 의미한다.
	- 여기서 *Chunk* (*Vector*) 는 하나의 데이터 (single row) 가 아닌 여러개의 데이터 (multiple rows) 를 의미한다.
	- 보통 1024 개를 묶어 하나의 vector 라고 한다.
- 가령 loop 을 돌며 어떤 작업 (func) 을 하는 다음의 코드는,

```c
int arr[MAX];

void func(int i) {
	// do something...
}

for (int i = 0; i < MAX; i++){
	func(arr[i]);
}
```

- 이것 대신

```c
int arr[MAX];

void func(int* vec, int begin) {
	for (int i = begin; i < begin + 1024; i++) {
		// do something...
	}
}

for (int i = 0; i < MAX; i += 1024) {
	func(arr, i);
}
```

- 이렇게 하는 방식이다.
- 위 두 방식은 동일하지만, vectorized execution 하는 것이 더 좋다. 왜냐면:
	- 일단 function call 이 적어지기 때문에 function call overhead 를 줄일 수 있고,
	- 최적화하기도 좋다.
		- Function 내에서의 loop 횟수가 정해져있고 [^vectorized-execution]
		- 단순 작업을 looping 하는 것이 해당 함수의 전부이기 때문에 [[Single Instruction Multiple Data, SIMD (Arch)|SIMD]] 를 사용하기에도 용이하다.

#### 1.0.2. Vectorized decoding

- 위와 같은 [[#1.0.1. Vectorized execution|vectorized execution]] 은 decompression 에도 적용하여 이점을 볼 수 있다. (즉, *Vectorized decoding*)
- 또한 uncompressed 상태의 vector 크기를 L1 혹은 L2 캐시에 맞춘다면 decompression 이후 memory 에 저장하지 않고 캐시에서 바로 가져다가 query execution 을 할 수 있으므로 memory 에는 compressed vector 만 저장되게 되어 memory 사용량 또한 줄일 수 있다.

#### 1.0.3. Parquet

- Parquet 에서는 무조건 [[Dictionary Encoding (Encoding)|DICT]] 를 적용하고, 이렇게 해서 생성된 code sequence 에 대해서는 [[Run Length Encoding, RLE (Encoding)|RLE]] 나 [[Bit Packing, BP (Encoding)|BP]] 를 적용한다.
- 하지만 이때 [[Run Length Encoding, RLE (Encoding)|RLE]] 나 [[Bit Packing, BP (Encoding)|BP]] 는 데이터의 사이즈가 가변적 [^variable-sized] 이고, 

#### 1.0.4. Compressed execution

- *Compressed Query Execution* 은 데이터가 compressed 된 상태에서 그것을 decompression 하지 않고 (혹은 processing 가능한 최소의 크기로만 부분적으로 decompression 하여) query processing 을 하는 것을 일컫는다.
	- "부분적" 이라는 것은 가령 8bit 로 compressed 된 데이터가 원래는 64bit 로 decompression 되어야 하지만 16bit 로만 decompression 해도 processing 이 가능하다면 그렇게 하는 것이라 생각하면 된다.
- DuckDB 와 같은 근래의 DBMS 들은 이러한 *compressed vector* (random access 가 가능한 compressed data) 를 지원한다.
	- 가령 [[Frame Of Reference, FOR (Encoding)|FOR]]-vector 의 경우 vector 의 1024 개의 value 들은 `uint8` 로 compression 되어 있고, 마지막에 base 를 위한 `uint64` 값 하나만 더 추가하는 식으로 구현할 수 있다.
	- 마찬가지로 [[Dictionary Encoding (Encoding)|DICT]]-vector 의 경우 각 code 는 `uint8` 이되 dictionary 를 가리키는 pointer 하나만 `uint64` 로서 구현할 수 있다.
- 이렇게 함으로써 [[Single Instruction Multiple Data, SIMD (Arch)|SIMD]] 와 같은 optimization 도 사용할 수 있게 되었고, ([[Single Instruction Multiple Data, SIMD (Arch)|SIMD]] 에서는 작은 사이즈 데이터 여러개를 레지스터에 넣으니깐은) 캐시나 메모리 사용량도 더 줄일 수 있게 되었다.
- 또한 compressed vector 를 "부분적으로" decompress 하여 가능한 최소 사이즈의 lane-width (processing size 라고 이해하자) 가 되게 하는 best-case scan decoding 을 best-case 를 넘어 common-case 가 되게 했다고 한다.

#### 1.0.5. FastLanes

- *FastLanes* 는 (저자의 소속인) [CWI](https://cwi.nl/en/) 에서 시작한 next-generation bigdata format 이다.
- 이것은 parallel processing 의 기회를 최대한 늘린 columnar compression layout 으로,
	- 다양한 *Instruction Set Architecture* (*ISA*) 에 대응할 수 있고,
		- 즉, 특정 architecture 에 의존적이지 않고 공통적으로 지원하는 instruction 에만 의존하고
	- Scalar-only code 를 사용하여 vectorized execution 을 사용하지 않고도 효과적 [^technical-dept] 이다.

[^vectorized-execution]: 주인장의 추측이다.
[^variable-sized]: 여기서 variable sized 라는 것이 뭔지 잘 모르겠음; [[Bit Packing, BP (Encoding)|BP]] 는 bit width 가 가변적이라고 받아들일 수 있는데 [[Run Length Encoding, RLE (Encoding)|RLE]] 는 뭐가 가변적이라는거고
[^technical-dept]: Vectorized execution 을 사용하지 않아도 좋다는 것이 맞는 해석인지 모르겠음.