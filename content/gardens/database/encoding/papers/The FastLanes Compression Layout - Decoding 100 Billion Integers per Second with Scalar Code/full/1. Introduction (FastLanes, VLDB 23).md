---
tags:
  - database
  - db-encoding
date: 2024-08-24
title: (논문) The FastLanes Compression Layout - Decoding 100 Billion Integers per Second with Scalar Code (1. Introduction)
---
> [!info] 본 글은 논문 [The FastLanes Compression Layout: Decoding > 100 Billion Integers per Second with Scalar Code (VLDB '23)](https://dl.acm.org/doi/10.14778/3598581.3598587) 를 읽고 정리한 글입니다.

> [!info] 별도의 명시가 없는 한, 본 글의 모든 그림은 위 논문에서 가져왔습니다.

> [!info]- 목차
> - [[1. Introduction (FastLanes, VLDB 23)|1. Introduction (현재 글)]]

## 1. Instruction

### 1.0. Overview

- [[On-Line Analytical Processing, OLAP (Database)|OLAP]] 과 같은 시스템에서는 보통 columnar data format 을 많이 이용한다. 그 이유는:
	- Row data 를 load 하면 불필요한 column 까지 load 되기 때문
	- Columnar data 는 compression 이 용이해 보통 데이터의 크기가 더 작기 때문

#### 1.0.1. Vectorized execution

- *Chunk* (*Vector*) 단위로 query execution 을 처리하는 것을 의미한다.
	- 여기서 *Chunk* (*Vector*) 는 하나의 데이터 (single row) 가 아닌 여러개의 데이터 (multiple rows) 를 의미한다.
- 가령 loop 을 돌며 어떤 작업 (func) 을 하는 다음의 코드는,

```c
int arr[MAX];

void func(int i) {
	// do something...
}

for (int i = 0; i < MAX; i++){
	func(arr[i]);
}
```

- 이것 대신

```c
int arr[MAX];

void func(int* vec, int begin) {
	for (int i = begin; i < begin + 1024; i++) {
		// do something...
	}
}

for (int i = 0; i < MAX; i += 1024) {
	func(arr, i);
}
```

- 이렇게 하는 방식이다.
- 위 두 방식은 동일하지만, vectorized execution 하는 것이 더 좋다. 왜냐면:
	- 일단 function call 이 적어지기 때문에 function call overhead 를 줄일 수 있고,
	- 최적화하기도 좋다.
		- Function 내에서의 loop 횟수가 정해져있고 [^vectorized-execution]
		- 단순 작업을 looping 하는 것이 해당 함수의 전부이기 때문에 [[Single Instruction Multiple Data, SIMD (Arch)|SIMD]] 를 사용하기에도 용이하다.

#### 1.0.2. Vectorized decoding

- 위와 같은 [[#1.0.1. Vectorized execution|vectorized execution]] 은 

#### 1.0.3. Parquet

#### 1.0.4. Compressed execution

#### 1.0.5. FastLanes

[^vectorized-execution]: 주인장의 추측이다.