---
tags:
  - originals
  - snu-shpc24f
date: 2024-09-11
---
> [!info] 서울대학교 컴퓨터공학과 이재진 교수님의 "확장형 고성능 컴퓨팅" 강의를 필기한 내용입니다.
> - [[(SNU CSE) Scalable High-Performance Computing|목차]]

## Programming Language Basics

- 맨날 얘기하는거지만 CS 에서는 abstraction 이 중허고 이것으로 내부 작동 과정을 알지 못해도 해당 기능을 사용할 수 있게 해준다.
- 이때 PL 은 프로그램 작성을 위한 high-level abstraction 을 제공한다.
	- "Programming" 은 machine 에 어떤 작업을 하도록 명령을 내리는 것으로 정의할 수 있다.
	- 뻔한 얘기지만 PL 은 자연어에 가까워서 programming 을 더 빠르게 할 수 있도록 해준다고 한다.
- [[Instruction (Arch)|Low-level (assembly)]]: [[Instruction (Arch)|Instruction]] 에 naming 을 해놓은 것 (1:1 관계)
	- 옛날에는 어떤 언어를 만들 때, 처음에는 compiler 를 asm 으로 개발하고 그 이후에는 compiler 도 그 언어로 개발되는 순서로 했었다고 한다.
- Syntax 와 sementics 의 차이는
	- Syntax: 문법
	- Semantics: 의미
- [[Interpreter (PL)|Interpreter]]
	- Compile 과 execution 을 동시에 하는 것인데
	- 조금 더 구체적으로 말하면 program 을 input 으로 받아 해당 program 의 output 을 output 으로 내뱉는 놈을 의미한다.
	- 모든 연산이 함수로 구현되어 있어서 code parsing 후 해당 함수를 call 하는 것으로 실행된다.
	- 따라서 매번 func call procedure 를 타기 때문에 compiler 보다 느린 것.
- [[Function (PL Function)|Function]]
	- 수학적 함수와는 다르게 PL 에서의 함수는 machine state (가령 memory 에 저장된 값) 을 바꾸기 때문에 매 실행시마다 결과가 다를 수 있다.
	- 따라서 수학 함수는 값으로서 생각할 수 있지만 C 에서는 안된다.
		- C 언어의 함수는 [[First, Second Class Citizen (PL Function)|Second-class citizen]] 이기 때문.

### C Compilation Step

- C compile 과정:

![[Pasted image 20241017133617.png]]

- C compile 과정: Source code (`.c`) -> [[Compilation Steps (GCC, LLVM)|Preprocessing]] -> Compilation -> [[Compilation Steps (GCC, LLVM)|Object file]] (`.o`) -> [[Compilation Steps (GCC, LLVM)|Linking]] (w/ lib) -> Executable binary
- Preprocessing
	- `#include` 는 header file 을 가져오기 때문에 선언만 가져온다.
	- 그래서 link 를 통해 implementation 을 연결해주는 작업이 필요한 것.

![[Pasted image 20241017133921.png]]

- Linker
	- 만약 link 하지 않고 그냥 implentation 이 preprocess 에서 다 포함이 된다면 매번 얘네들을 compile 해줘야 한다.
	- 근데 linker 을 사용하면 부분적으로 compile 하고 (`.o`) 변경되지 않은 부분들에 대해서는 compile 하지 않게 해주는 덕분에 전부 compile 하는것보다 훨씬 빠르게 수행될 수 있다.

## Process Execution

- Process 의 [[Process State Model (OS Process)|execution lifecycle]] 을 큰그림으로 그려보자.
	- Program 을 실행하면 이걸 메모리에 올려두고, ready queue 에 넣어놓은 뒤에
	- Context switch 되면 kernel 에서 정해진 사전 작업을 처리하고
	- 이 메모리에 올려둔 코드로 jump 해서 제어권 변경 및 실행되기 시작하는 것.
	- 그리고 종료되면 kernel 이 다시 제어권을 받아 후처리하게 된다.
- 그리고 각 instruction 을 실행하는 것은
	- [[Program Counter, PC (Arch)|Controller Unit]] 은 [[Program Counter, PC (Arch)|PC]] 를 보고 해당 instrunction 를 메모리에서 가져오고 (fetch),
		- PC 를 바꾸는것도 이 Controller unit 이 담당한다.
	- Decoder 가 이놈이 뭔지 파악 (decode) 해서 해당 inst 에 대한 ALU (Arithmetic Logic Unit) 으로 보내 처리 (execute) 하며,
	- 이런 [[Instruction Cycle (Arch Instruction)|instruction cycle]] 을 반복하게 된다.
- Kernel 로 제어권이 넘어간다는 것은 kernel code 로 PC 를 바꾸는 것을 의미한다.
	- 이렇게 제어권을 넘기는 것을 control transfer 라고 한다.
- `BRANCH`, function call (`JUMP`) 모두 마찬가지로 Control unit 이 PC 를 바꾸는 것
- `STORE`(+ `LOAD`), Arithmetic operation, `BRANCH` 만 있으면 이론적으로는 어떤 프로그램이든 구현할 수 있다.
	- 저 상태에서 필요에 의해 optimization 이 들어간게 현대의 CPU 임.
- [[Register (Arch)|Register]]: processor 가 직접 접근해서 값을 가져올 수 있는 아주 빠른 저장소
	- Architecture 가 32, 64 bit 라는 것은 register 의 사이즈가 해당 크기라는 것이다.
		- 그래서 메모리에서 한번에 가져오는 bit 의 크기도 그 정도이고,
		- Instruction 의 최대 크기도 여기에 맞게 되어 있다.
- [[Variable (PL)|Variable]]: named memory location
	- 이 주소는 compile time 에 다 정해진다.
		- 당연히 [[Virtual Memory (Memory)|Virtual address]] 이기 떄문에 이것이 가능한 것
		- 실행시에 virtual address 로 접근하면 page fault 가 나며 physical address 를 받아 page table 등록되고 처리되는 형태

## CISC, RISC

- [[Complex Instruction Set Computer, CISC (Arch)|CISC]]: Complex Instruction Set Computer
	- Backward-compatibility 를 위해서 이전의 [[Instruction Set Architecture, ISA (Arch)|ISA]] 도 다 들고 있음
	- 따라서 매우 뚱뚱맨
	- 참고로 CISC 라는 용어는 RISC 가 나오기 전까지는 없었다고 한다; CISC 는 RISC 가 아닌 모든 architecture 를 다 커버함.
- [[Reduced Instruction Set Computer, RISC (Arch)|RISC]]: Reduced Instruction Set Computer
	- CISC 에서는 메모리 주소 표현법이 아주 많고 따라서 compiler 입장에서는 선택지가 많기 때문에 optimize 하기 힘들다.
	- 그래서 RISC 는 표현법이 적고 `LOAD`, `STORE` 를 무조건 사용해야 하는 등의 차이점이 있다.
		- CISC 에서는 `LOAD`, `STORE` 뿐 아니라 메모리 주소가 instruction 에 바로 들어갈 수도 있는데 RISC 는 무조건 LOAD 로 register 로 올려야지 사용할 수 있다.
	- RISC 가 문법이 간단하기 떄문에 compiler 입장에서 어떻게 해야 code optimize 를 할 수 있을지 예측이 가능하다.
		- 가령 RISC 의 경우에는 모든 instruction 의 크기가 동일하다. CISC 에서는 들쭉날쭉함
		- 그리고 RISC 에서는 모든 instruction 이 ([[Instruction Pipeline (Arch Instruction)|pipeline]] 의 도움을 받아) 1 cycle 에 끝난다.
		- 다만 RISC 에서는 이런 간단한 문법때문에 오히려 code size 가 커지기도 한다.
	- 요즘은 겉으로는 CISC 지만 내부적으로는 RISC 로 되어 있다고 한다.
		- 외부에 노출되는 API 만 CISC 형태를 띄고 실제 구현된 것은 RISC 와 비슷하게 구현되어 있다고 한다.
		- 사실 이건 뭔말인지 잘 모르겠음

## Process

- 이놈 구성 요소
	- (1) register 도 들어간다.
		- 당연히 [[Time Sharing System (OS Process)|time sharing]] 할 떄 사용하고 있던 register 들을 [[Process Control Block, PCB (OS Process)|PCB]] 에 넣어놔야지 다시 복구가 가능하니까
	- (2) memory (3) IO status (fd 등) (4) signal mgmt
- Virtual memory space 구조: 사실 다 아는거니까 간단하게만 복습하면 ([[Virtual Address Space, VAS (Memory)|참고]])
	- Lowest -> highest 순서로 code, data, stack, heap
	- Global var 는 data 에, local 은 stack 에
	- Stack 은 low -> high 로 자라고 heap 은 high -> low 로 자란다 (역방향).
	- Stack 에 저장되는 함수 데이터는 [[Activation (Arch)|Stack Frame]] 혹은 [[Activation (Arch)|Activation Record]] 라고 불린다.
	- [[Stack Pointer, SP (Arch)|Stack pointer]] (SP) 라는 register 가 stack 의 top 을 가리킨다.
	- PC 는 code 공간을 가리키고 있게 된다. (해당 process 실행중에)
	- 함수가 실행되면 stack frame 이 생기고 SP 가 옮겨가고 종료되면 stack frame 가 날라가고 SP 가 다시 그 전으로 옮겨가는 방식이다.
	- Function call 을 관리하기 위해 stack 을 사용하는 이유는 recursion 을 위해서이다.
		- Recursion 이 없으면 그냥 함수별로 고정된 공간 박아놓고 해도 된다.
- Run mode
	- Instruction 도 mode 가 나눠져 있다
	- [[Instruction (Arch)|Kernel mode]] (= [[Instruction (Arch)|supervisor mode]]) 와 [[Instruction (Arch)|user mode]]
	- 당연히 kernel mode inst 는 kernel 만 실행할 수 있고,
	- User mode 의 code 가 kernel instruction 을 실행하기 위해서는 이걸 해달라고 kernel 에 부탁하는 방식을 사용한다 (즉, 이게 syscall) [[System Call (OS Process)|syscall]].
		- Syscall 을 걸면 trap 이 걸리며 kernel mode 로 바뀌게 된다.
- Process 를 실행시키는 것은
	- [[Uni- Multi-programming (Arch)|Uniprogramming]]: 하나의 core 에서 process 를 한번에 하나만 실행하고, 끝날 때 까지 계속 잡고 있는 것.
	- [[Uni- Multi-programming (Arch)]]: 반대로 core 를 time-sharing 하며 switching 해 여러개의 process 를 와리가리하면서 실행시키는 것
- virtual mem:
	- 처음 논문은 MIT 의 multics OS 개발팀이 작성
	- 근데 발명은 atlas system 에 처음 도입되었다고 한다
		- 이놈은 영국의 manchester computer 라는 회사에서 만들었다고 한다.