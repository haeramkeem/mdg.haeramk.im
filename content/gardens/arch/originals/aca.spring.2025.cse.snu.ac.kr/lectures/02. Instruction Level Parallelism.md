---
tags:
  - arch
  - originals
  - snu-aca25s
date: 2025-03-06
title: 2. Instruction Level Parallelism (Advanced Computer Architectures, SNU CSE)
---
> [!info] 서울대학교 컴퓨터공학부 유승주 교수님의 "고급 컴퓨터 구조" 강의를 필기한 내용입니다.
> - [[(SNU CSE) Advanced Computer Architectures|목차]]

## ILP

- CPU 는 입력으로 들어온 instruction stream 으로부터 parallelism 을 찾아 그것을 exploit 하는 기술이 구현되어 있고, 이러한 것을 ILP 라고 함

## Dependence 복습

- Data dependence (True dependence) Read after write (RAW)
- Anti dependence: Write after read (WAR)
- Output dependence: WAW
- Dependence 없으면 당연히 parallel 하게 실행하거나 순서를 바꿀 수 있다
- 추가적인 Register 를 이용해 dependence 를 끊을 수 있다
	- 근데 이번 강의에서는 추가적인 register 를 사용하지 않는 방법을 배운다
		- 이번에 배우는 architecture 를 scoreboard 라고 부르는듯

## CPU cycle (Scoreboard Architecture)

- ISSUE:
	- Decode 및 resource availability checking 이 가장 중요한 단계
	- structural hazard 검사 → 이거 복습해야됨
		- resource availability 검사: decode 를 한 다음에 그것에 필요한 ALU 가 지금 사용할 수 있는지 검사
		- 다른 누군가가 사용중일 수도 있음
		- 사용중이면 issue 하지 않고 대기 → 이게 stall
	- 여기서는 register 도 자원으로 인식 → 자원이 부족하면 ISSUE 가 안되고 이것은 WAW 가 있어도 마찬가지
- Read operands
	- 피연산자 (레지스터) 를 읽음
	- 이때도 읽을 수 있는지 없는지 검사
	- 값이 준비가 되면 그제서야 읽을 수 있음 → 여기서도 stall 이 발생할 수 있음
- Execute
- Write result (WB)
	- 연산 완료 후, 값을 쓰는 것
	- 이때도 마찬가지로 쓰고자 하는 자리가 사용중인지 검사함
	- 만약에 해당 자리의 값을 누군가가 읽고있으면, 쓸 수 없음 → 이때도 stall 이 발생함
- ← scoreboard example 스스로 생각해보며 정리
	1. structural hazard
	2. read stall
	3. cycle 8 - divd 는 multid 에 의해 read stall 이 발생
	4. cycle 9 - read stall 이 해결되었으므로 두 instr 이 동시에 issue 되는 모습
	5. cycle 12: mulid 는 오래걸리고 subd 는 빠르게 종료되므로 OoO execution 이 되게 된다
	6. cycle 13: addd 는 subd 가 빨리 끝났으므로 add alu 에 issue 되어 divd 보다 먼저 실행됨
	7. cycle 18: 이제 multid 가 끝남
	8. cycle 20: 18 에서 multid 가 끝나서 read stall 되었던 divd 가 issue 됨
	9. cycle 22: divd 가 이미 read 했으므로 addd 가 그자리에 쓸 수 있는듯 cycle 22 에서
- Scoreboard architecture 에서는 pipeling forwarding 이 없다
	- Tomasulo 에선 된댄다
- 42p 에 scoreboard architecture 정리해놓은거 정리