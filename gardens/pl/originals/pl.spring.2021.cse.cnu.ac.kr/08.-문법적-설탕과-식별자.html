<!DOCTYPE html>
<html><head><title>08. 문법적 설탕과 식별자</title><meta charSet="utf-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:title" content="08. 문법적 설탕과 식별자"/><meta property="og:description" content="충남대학교 컴퓨터공학과 이성호 교수님의 &amp;quot;프로그래밍 언어 개론&amp;quot; 강의를 필기한 내용입니다. 다소 잘못된 내용과 구어적 표현 이 포함되어 있을 수 있습니다. 언어의 확장 과정 § Concrete syntax의 확장 Abstract syntax의 확장 Parser의 확장(CS → AS로 바꿔주는놈이 parser이므로) Semantics 확장(Abstract Syntax가 확장되었으므로) Interpreter 수정(AS → 기계어) 컴파일 언어의 경우 더 많은 확장 단계를 가지게 된다 Syntactic Sugar § Concrete syntax를 확장하되 확장된 구문을 기존의 Abstract syntax에 대응시키는 기법을 말함 CS를 확장하므로 CS와 CS를 사용하는 parser는 확장해야 되지만 AS나 semantics 등은 확장하지 않아도 된다 parser가 이 설탕쳐진 구문(확장된 CS)에서 설탕을 빼는 과정(기존의 CS로 변환하여 기존의 AS로 변환하는 과정)을 Desugaring이라고 한다 하나의 AS에 대응되는 CS가 여러개가 되는 셈인거다 따라서 CS를 하나 정의하고 그것을 기존의 AS에 대응만 시켜주면 되는 셈 Identifiers § Identifier(식별자) : 함수, 변수, 프로퍼티, 메소드, 클래스들에 붙이는 이름을 식별자라 한다 Occurrence of Identifier § Occurrence of Identifiers : 하나의 식별자는 프로그램에 여러번 등장할 수 있다는 개념 등장의 종류 § Binding Occurrence : 식별자의 정의를 위한 등장 Bound Occurrence : 정의된 식별자를 사용하기 위한 등장 Free Occurrence : 정의되지 않은 식별자를 사용하기 위한 등장 Scope of Identifier § Binding된 놈이 Bound될 수 있는 범위 따라서 bind되어도 scope를 넘어가면 free identifier가 된다 Shadowing : 동일한 이름을 가진 식별자들의 scope가 겹치는 경우 bound했을 때 가장 가까운(가장 안쪽의, 가장 지협적인) scope를 따라가게 된다 가장 가까운 놈이 먼 놈을 가린다는 의미에서 shadowing이라고 하는 것 Store § 요기 나오는 내용은 전부 언어 AE를 위해 수업에서 임의로 정의한 것이다 개념은 통용되지만 용어나 구체적인 내용들은 수업용임 Store : 가상 저장공간들의 집합 가상 저장공간이라는 것은 변수를 받아 정수를 돌려주는 하나의 함수라고도 표현할 수 있다 (변수를 이용해 그 정수에 접근하는 것 이므로) 근데 함수는 딕셔너리와도 유사하다(키를 이용해 벨류를 반환하므로) 따라서 가상 저장공간은 변수를 받아 정수를 반환하는 딕셔너리라고도 생각할 수 있다 가상메모리 = 변수이름을 받아 값을 돌려주는 함수 = 변수이름을 키로 받아 매핑된 값을 돌려주는 딕셔너리 가상 저장공간 집합 Store는 변수를 받아 정수로 돌려주는 모든 함수(딕셔너리)들의 집합이다 시그마 는 Store의 원소이다."/><meta property="og:image" content="https://mdg.haeramk.im/static/og-image.png"/><meta property="og:width" content="1200"/><meta property="og:height" content="675"/><link rel="icon" href="../../../../static/icon.png"/><meta name="description" content="충남대학교 컴퓨터공학과 이성호 교수님의 &amp;quot;프로그래밍 언어 개론&amp;quot; 강의를 필기한 내용입니다. 다소 잘못된 내용과 구어적 표현 이 포함되어 있을 수 있습니다. 언어의 확장 과정 § Concrete syntax의 확장 Abstract syntax의 확장 Parser의 확장(CS → AS로 바꿔주는놈이 parser이므로) Semantics 확장(Abstract Syntax가 확장되었으므로) Interpreter 수정(AS → 기계어) 컴파일 언어의 경우 더 많은 확장 단계를 가지게 된다 Syntactic Sugar § Concrete syntax를 확장하되 확장된 구문을 기존의 Abstract syntax에 대응시키는 기법을 말함 CS를 확장하므로 CS와 CS를 사용하는 parser는 확장해야 되지만 AS나 semantics 등은 확장하지 않아도 된다 parser가 이 설탕쳐진 구문(확장된 CS)에서 설탕을 빼는 과정(기존의 CS로 변환하여 기존의 AS로 변환하는 과정)을 Desugaring이라고 한다 하나의 AS에 대응되는 CS가 여러개가 되는 셈인거다 따라서 CS를 하나 정의하고 그것을 기존의 AS에 대응만 시켜주면 되는 셈 Identifiers § Identifier(식별자) : 함수, 변수, 프로퍼티, 메소드, 클래스들에 붙이는 이름을 식별자라 한다 Occurrence of Identifier § Occurrence of Identifiers : 하나의 식별자는 프로그램에 여러번 등장할 수 있다는 개념 등장의 종류 § Binding Occurrence : 식별자의 정의를 위한 등장 Bound Occurrence : 정의된 식별자를 사용하기 위한 등장 Free Occurrence : 정의되지 않은 식별자를 사용하기 위한 등장 Scope of Identifier § Binding된 놈이 Bound될 수 있는 범위 따라서 bind되어도 scope를 넘어가면 free identifier가 된다 Shadowing : 동일한 이름을 가진 식별자들의 scope가 겹치는 경우 bound했을 때 가장 가까운(가장 안쪽의, 가장 지협적인) scope를 따라가게 된다 가장 가까운 놈이 먼 놈을 가린다는 의미에서 shadowing이라고 하는 것 Store § 요기 나오는 내용은 전부 언어 AE를 위해 수업에서 임의로 정의한 것이다 개념은 통용되지만 용어나 구체적인 내용들은 수업용임 Store : 가상 저장공간들의 집합 가상 저장공간이라는 것은 변수를 받아 정수를 돌려주는 하나의 함수라고도 표현할 수 있다 (변수를 이용해 그 정수에 접근하는 것 이므로) 근데 함수는 딕셔너리와도 유사하다(키를 이용해 벨류를 반환하므로) 따라서 가상 저장공간은 변수를 받아 정수를 반환하는 딕셔너리라고도 생각할 수 있다 가상메모리 = 변수이름을 받아 값을 돌려주는 함수 = 변수이름을 키로 받아 매핑된 값을 돌려주는 딕셔너리 가상 저장공간 집합 Store는 변수를 받아 정수로 돌려주는 모든 함수(딕셔너리)들의 집합이다 시그마 는 Store의 원소이다."/><meta name="generator" content="Quartz"/><link rel="preconnect" href="https://fonts.googleapis.com"/><link rel="preconnect" href="https://fonts.gstatic.com"/><link href="../../../../index.css" rel="stylesheet" type="text/css" spa-preserve/><link href="https://cdn.jsdelivr.net/npm/katex@0.16.0/dist/katex.min.css" rel="stylesheet" type="text/css" spa-preserve/><link href="https://fonts.googleapis.com/css2?family=IBM Plex Mono&amp;family=Gowun Batang:wght@400;700&amp;family=Gowun Dodum:ital,wght@0,400;0,600;1,400;1,600&amp;display=swap" rel="stylesheet" type="text/css" spa-preserve/><script src="../../../../prescript.js" type="application/javascript" spa-preserve></script><script type="application/javascript" spa-preserve>const fetchData = fetch(`../../../../static/contentIndex.json`).then(data => data.json())</script></head><body data-slug="gardens/pl/originals/pl.spring.2021.cse.cnu.ac.kr/08.-문법적-설탕과-식별자"><div id="quartz-root" class="page"><div id="quartz-body"><div class="left sidebar"><h1 class="page-title "><a href="../../../..">Madison Digital Garden</a></h1><div class="spacer mobile-only"></div><div class="search "><div id="search-icon"><p>Search</p><div></div><svg tabIndex="0" aria-labelledby="title desc" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 19.9 19.7"><title id="title">Search</title><desc id="desc">Search</desc><g class="search-path" fill="none"><path stroke-linecap="square" d="M18.5 18.3l-5.4-5.4"></path><circle cx="8" cy="8" r="7"></circle></g></svg></div><div id="search-container"><div id="search-space"><input autocomplete="off" id="search-bar" name="search" type="text" aria-label="Search for something" placeholder="Search for something"/><div id="results-container"></div></div></div></div><div class="darkmode "><input class="toggle" id="darkmode-toggle" type="checkbox" tabIndex="-1"/><label id="toggle-label-light" for="darkmode-toggle" tabIndex="-1"><svg xmlns="http://www.w3.org/2000/svg" xmlnsXlink="http://www.w3.org/1999/xlink" version="1.1" id="dayIcon" x="0px" y="0px" viewBox="0 0 35 35" style="enable-background:new 0 0 35 35;" xmlSpace="preserve"><title>Light mode</title><path d="M6,17.5C6,16.672,5.328,16,4.5,16h-3C0.672,16,0,16.672,0,17.5    S0.672,19,1.5,19h3C5.328,19,6,18.328,6,17.5z M7.5,26c-0.414,0-0.789,0.168-1.061,0.439l-2,2C4.168,28.711,4,29.086,4,29.5    C4,30.328,4.671,31,5.5,31c0.414,0,0.789-0.168,1.06-0.44l2-2C8.832,28.289,9,27.914,9,27.5C9,26.672,8.329,26,7.5,26z M17.5,6    C18.329,6,19,5.328,19,4.5v-3C19,0.672,18.329,0,17.5,0S16,0.672,16,1.5v3C16,5.328,16.671,6,17.5,6z M27.5,9    c0.414,0,0.789-0.168,1.06-0.439l2-2C30.832,6.289,31,5.914,31,5.5C31,4.672,30.329,4,29.5,4c-0.414,0-0.789,0.168-1.061,0.44    l-2,2C26.168,6.711,26,7.086,26,7.5C26,8.328,26.671,9,27.5,9z M6.439,8.561C6.711,8.832,7.086,9,7.5,9C8.328,9,9,8.328,9,7.5    c0-0.414-0.168-0.789-0.439-1.061l-2-2C6.289,4.168,5.914,4,5.5,4C4.672,4,4,4.672,4,5.5c0,0.414,0.168,0.789,0.439,1.06    L6.439,8.561z M33.5,16h-3c-0.828,0-1.5,0.672-1.5,1.5s0.672,1.5,1.5,1.5h3c0.828,0,1.5-0.672,1.5-1.5S34.328,16,33.5,16z     M28.561,26.439C28.289,26.168,27.914,26,27.5,26c-0.828,0-1.5,0.672-1.5,1.5c0,0.414,0.168,0.789,0.439,1.06l2,2    C28.711,30.832,29.086,31,29.5,31c0.828,0,1.5-0.672,1.5-1.5c0-0.414-0.168-0.789-0.439-1.061L28.561,26.439z M17.5,29    c-0.829,0-1.5,0.672-1.5,1.5v3c0,0.828,0.671,1.5,1.5,1.5s1.5-0.672,1.5-1.5v-3C19,29.672,18.329,29,17.5,29z M17.5,7    C11.71,7,7,11.71,7,17.5S11.71,28,17.5,28S28,23.29,28,17.5S23.29,7,17.5,7z M17.5,25c-4.136,0-7.5-3.364-7.5-7.5    c0-4.136,3.364-7.5,7.5-7.5c4.136,0,7.5,3.364,7.5,7.5C25,21.636,21.636,25,17.5,25z"></path></svg></label><label id="toggle-label-dark" for="darkmode-toggle" tabIndex="-1"><svg xmlns="http://www.w3.org/2000/svg" xmlnsXlink="http://www.w3.org/1999/xlink" version="1.1" id="nightIcon" x="0px" y="0px" viewBox="0 0 100 100" style="enable-background='new 0 0 100 100'" xmlSpace="preserve"><title>Dark mode</title><path d="M96.76,66.458c-0.853-0.852-2.15-1.064-3.23-0.534c-6.063,2.991-12.858,4.571-19.655,4.571  C62.022,70.495,50.88,65.88,42.5,57.5C29.043,44.043,25.658,23.536,34.076,6.47c0.532-1.08,0.318-2.379-0.534-3.23  c-0.851-0.852-2.15-1.064-3.23-0.534c-4.918,2.427-9.375,5.619-13.246,9.491c-9.447,9.447-14.65,22.008-14.65,35.369  c0,13.36,5.203,25.921,14.65,35.368s22.008,14.65,35.368,14.65c13.361,0,25.921-5.203,35.369-14.65  c3.872-3.871,7.064-8.328,9.491-13.246C97.826,68.608,97.611,67.309,96.76,66.458z"></path></svg></label></div></div><div class="center"><div class="page-header"><div class="popover-hint"><h1 class="article-title ">08. 문법적 설탕과 식별자</h1><p class="content-meta ">Nov 24, 2024, 7 min read</p></div></div><article class="popover-hint"><blockquote class="callout" data-callout="info">
<div class="callout-title">
                  <div class="callout-icon"><svg xmlns="http://www.w3.org/2000/svg" width="100%" height="100%" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="10"></circle><line x1="12" y1="16" x2="12" y2="12"></line><line x1="12" y1="8" x2="12.01" y2="8"></line></svg></div>
                  <div class="callout-title-inner"><p>충남대학교 컴퓨터공학과 이성호 교수님의 &quot;프로그래밍 언어 개론&quot; 강의를 필기한 내용입니다. </p></div>
                  
                </div>
</blockquote>
<blockquote class="callout" data-callout="warning">
<div class="callout-title">
                  <div class="callout-icon"><svg xmlns="http://www.w3.org/2000/svg" width="100%" height="100%" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="m21.73 18-8-14a2 2 0 0 0-3.48 0l-8 14A2 2 0 0 0 4 21h16a2 2 0 0 0 1.73-3Z"></path><line x1="12" y1="9" x2="12" y2="13"></line><line x1="12" y1="17" x2="12.01" y2="17"></line></svg></div>
                  <div class="callout-title-inner"><p>다소 잘못된 내용과 구어적 표현 이 포함되어 있을 수 있습니다. </p></div>
                  
                </div>
</blockquote>
<h2 id="언어의-확장-과정">언어의 확장 과정<a aria-hidden="true" tabindex="-1" href="#언어의-확장-과정" class="internal"> §</a></h2>
<ol>
<li>Concrete syntax의 확장</li>
<li>Abstract syntax의 확장</li>
<li>Parser의 확장(CS → AS로 바꿔주는놈이 parser이므로)</li>
<li>Semantics 확장(Abstract Syntax가 확장되었으므로)</li>
<li>Interpreter 수정(AS → 기계어)</li>
</ol>
<ul>
<li>컴파일 언어의 경우 더 많은 확장 단계를 가지게 된다</li>
</ul>
<h2 id="syntactic-sugar">Syntactic Sugar<a aria-hidden="true" tabindex="-1" href="#syntactic-sugar" class="internal"> §</a></h2>
<ul>
<li>Concrete syntax를 확장하되 확장된 구문을 기존의 Abstract syntax에 대응시키는 기법을 말함</li>
<li>CS를 확장하므로 CS와 CS를 사용하는 parser는 확장해야 되지만 AS나 semantics 등은 확장하지 않아도 된다</li>
<li>parser가 이 설탕쳐진 구문(확장된 CS)에서 설탕을 빼는 과정(기존의 CS로 변환하여 기존의 AS로 변환하는 과정)을 <strong>Desugaring</strong>이라고 한다</li>
<li>하나의 AS에 대응되는 CS가 여러개가 되는 셈인거다
<ul>
<li>따라서 CS를 하나 정의하고 그것을 기존의 AS에 대응만 시켜주면 되는 셈</li>
</ul>
</li>
</ul>
<h2 id="identifiers">Identifiers<a aria-hidden="true" tabindex="-1" href="#identifiers" class="internal"> §</a></h2>
<ul>
<li><strong>Identifier(식별자)</strong> : 함수, 변수, 프로퍼티, 메소드, 클래스들에 붙이는 이름을 식별자라 한다</li>
</ul>
<h2 id="occurrence-of-identifier">Occurrence of Identifier<a aria-hidden="true" tabindex="-1" href="#occurrence-of-identifier" class="internal"> §</a></h2>
<ul>
<li><strong>Occurrence of Identifiers</strong> : 하나의 식별자는 프로그램에 여러번 등장할 수 있다는 개념</li>
</ul>
<h3 id="등장의-종류">등장의 종류<a aria-hidden="true" tabindex="-1" href="#등장의-종류" class="internal"> §</a></h3>
<ul>
<li><strong>Binding Occurrence</strong> : 식별자의 정의를 위한 등장</li>
<li><strong>Bound Occurrence</strong> : 정의된 식별자를 사용하기 위한 등장</li>
<li><strong>Free Occurrence</strong> : 정의되지 않은 식별자를 사용하기 위한 등장</li>
</ul>
<h2 id="scope-of-identifier">Scope of Identifier<a aria-hidden="true" tabindex="-1" href="#scope-of-identifier" class="internal"> §</a></h2>
<ul>
<li>Binding된 놈이 Bound될 수 있는 범위</li>
<li>따라서 bind되어도 scope를 넘어가면 free identifier가 된다</li>
<li><strong>Shadowing</strong> : 동일한 이름을 가진 식별자들의 scope가 겹치는 경우 bound했을 때 가장 가까운(가장 안쪽의, 가장 지협적인) scope를 따라가게 된다
<ul>
<li>가장 가까운 놈이 먼 놈을 가린다는 의미에서 shadowing이라고 하는 것</li>
</ul>
</li>
</ul>
<h2 id="store">Store<a aria-hidden="true" tabindex="-1" href="#store" class="internal"> §</a></h2>
<ul>
<li>요기 나오는 내용은 전부 언어 AE를 위해 수업에서 임의로 정의한 것이다
<ul>
<li>개념은 통용되지만 용어나 구체적인 내용들은 수업용임</li>
</ul>
</li>
<li><strong>Store</strong> : 가상 저장공간들의 집합
<ul>
<li>가상 저장공간이라는 것은 변수를 받아 정수를 돌려주는 하나의 함수라고도 표현할 수 있다 (변수를 이용해 그 정수에 접근하는 것 이므로)</li>
<li>근데 함수는 딕셔너리와도 유사하다(키를 이용해 벨류를 반환하므로)</li>
<li>따라서 가상 저장공간은 변수를 받아 정수를 반환하는 딕셔너리라고도 생각할 수 있다</li>
<li>가상메모리 = 변수이름을 받아 값을 돌려주는 함수 = 변수이름을 키로 받아 매핑된 값을 돌려주는 딕셔너리</li>
</ul>
</li>
<li>가상 저장공간 집합 Store는 변수를 받아 정수로 돌려주는 모든 함수(딕셔너리)들의 집합이다</li>
<li>시그마 는 Store의 원소이다. 즉, 임의의 한 가상 저장공간(함수, 딕셔너리)이라는 말이다</li>
<li><strong>시그마[x → n]</strong> : 변수 x를 선언하고 n으로 초기화 하는 것(binding)
<ul>
<li>즉, x를 받으면 n을 반환하는 규칙을 새로 함수에 추가하는 것</li>
<li>즉, 키x와 값n을 딕셔너리에 추가하는 것</li>
<li>선언, 초기화 후 업데이트된 시그마를 반환</li>
</ul>
</li>
<li><strong>시그마(x)</strong> : 변수 x의 값(n)을 찾아 반환 하는 것(bounding)</li>
<li><strong>추상메모리 ~에서</strong> 라는 말의 말뜻 : 이게 말이 좀 어려울 수 있는데 그냥 이런뜻이다
<ul>
<li>e에서 변수가 등장하지 않으면 이 메모리를 사용하지 않아도 되니까 추상메모리에서 라는 말은 별 의미없는 말이다.</li>
<li>근데 e에서 변수가 등장한다면 이 변수를 정수로 고치는 바꾸는 것은 저 추상메모리에 정의된 규칙을 따른다는 소리이다</li>
</ul>
</li>
<li><strong>ternary relation</strong> : 말뜻은 뭔지 모르게땅
<ul>
<li>이것의 기호는 <code>ㅏ</code> 이고 계산 문맥을 표현한다</li>
<li>즉, <code>EC ㅏ p</code> 는 EC라는 규칙 하에 p가 참이라는 소리이다</li>
<li>전제랑 문맥의 차이점은 이거다
<ul>
<li>어떤 연산을 하기 위해 반드시 참으로 규명나야 되는 것은 전제로 들어간다.</li>
<li>하지만 연산을 하기 위해 이용할 수도 있고 아닐수도 잇는 것은 문맥으로 들어간다?</li>
</ul>
</li>
</ul>
</li>
<li>따라서 해당 추상메모리에서 표현식e를 계산했더니 정수n이 나왔다면 이 관계는 <code>(추상메모리) ㅏ \[(표현식e) 아래화살표 (정수n)\]</code> 로 말할 수 있는 것이다
<ul>
<li>수업에서는 대괄호를 안쳐줬지만 생략된 것이므로 해당 추상메모리 하에서 “표현식 e는 정수 n으로 계산됨”은 참이라는 것을 뜻한다</li>
</ul>
</li>
</ul></article></div><div class="right sidebar"><div class="graph "><h3>Graph View</h3><div class="graph-outer"><div id="graph-container" data-cfg="{&quot;drag&quot;:true,&quot;zoom&quot;:true,&quot;depth&quot;:1,&quot;scale&quot;:1.1,&quot;repelForce&quot;:0.5,&quot;centerForce&quot;:0.3,&quot;linkDistance&quot;:30,&quot;fontSize&quot;:0.6,&quot;opacityScale&quot;:1,&quot;showTags&quot;:true,&quot;removeTags&quot;:[]}"></div><svg version="1.1" id="global-graph-icon" xmlns="http://www.w3.org/2000/svg" xmlnsXlink="http://www.w3.org/1999/xlink" x="0px" y="0px" viewBox="0 0 55 55" fill="currentColor" xmlSpace="preserve"><path d="M49,0c-3.309,0-6,2.691-6,6c0,1.035,0.263,2.009,0.726,2.86l-9.829,9.829C32.542,17.634,30.846,17,29,17
	s-3.542,0.634-4.898,1.688l-7.669-7.669C16.785,10.424,17,9.74,17,9c0-2.206-1.794-4-4-4S9,6.794,9,9s1.794,4,4,4
	c0.74,0,1.424-0.215,2.019-0.567l7.669,7.669C21.634,21.458,21,23.154,21,25s0.634,3.542,1.688,4.897L10.024,42.562
	C8.958,41.595,7.549,41,6,41c-3.309,0-6,2.691-6,6s2.691,6,6,6s6-2.691,6-6c0-1.035-0.263-2.009-0.726-2.86l12.829-12.829
	c1.106,0.86,2.44,1.436,3.898,1.619v10.16c-2.833,0.478-5,2.942-5,5.91c0,3.309,2.691,6,6,6s6-2.691,6-6c0-2.967-2.167-5.431-5-5.91
	v-10.16c1.458-0.183,2.792-0.759,3.898-1.619l7.669,7.669C41.215,39.576,41,40.26,41,41c0,2.206,1.794,4,4,4s4-1.794,4-4
	s-1.794-4-4-4c-0.74,0-1.424,0.215-2.019,0.567l-7.669-7.669C36.366,28.542,37,26.846,37,25s-0.634-3.542-1.688-4.897l9.665-9.665
	C46.042,11.405,47.451,12,49,12c3.309,0,6-2.691,6-6S52.309,0,49,0z M11,9c0-1.103,0.897-2,2-2s2,0.897,2,2s-0.897,2-2,2
	S11,10.103,11,9z M6,51c-2.206,0-4-1.794-4-4s1.794-4,4-4s4,1.794,4,4S8.206,51,6,51z M33,49c0,2.206-1.794,4-4,4s-4-1.794-4-4
	s1.794-4,4-4S33,46.794,33,49z M29,31c-3.309,0-6-2.691-6-6s2.691-6,6-6s6,2.691,6,6S32.309,31,29,31z M47,41c0,1.103-0.897,2-2,2
	s-2-0.897-2-2s0.897-2,2-2S47,39.897,47,41z M49,10c-2.206,0-4-1.794-4-4s1.794-4,4-4s4,1.794,4,4S51.206,10,49,10z"></path></svg></div><div id="global-graph-outer"><div id="global-graph-container" data-cfg="{&quot;drag&quot;:true,&quot;zoom&quot;:true,&quot;depth&quot;:-1,&quot;scale&quot;:0.9,&quot;repelForce&quot;:0.5,&quot;centerForce&quot;:0.3,&quot;linkDistance&quot;:30,&quot;fontSize&quot;:0.6,&quot;opacityScale&quot;:1,&quot;showTags&quot;:true,&quot;removeTags&quot;:[]}"></div></div></div><div class="toc desktop-only"><button type="button" id="toc"><h3>Table of Contents</h3><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="fold"><polyline points="6 9 12 15 18 9"></polyline></svg></button><div id="toc-content"><ul class="overflow"><li class="depth-0"><a href="#언어의-확장-과정" data-for="언어의-확장-과정">언어의 확장 과정</a></li><li class="depth-0"><a href="#syntactic-sugar" data-for="syntactic-sugar">Syntactic Sugar</a></li><li class="depth-0"><a href="#identifiers" data-for="identifiers">Identifiers</a></li><li class="depth-0"><a href="#occurrence-of-identifier" data-for="occurrence-of-identifier">Occurrence of Identifier</a></li><li class="depth-1"><a href="#등장의-종류" data-for="등장의-종류">등장의 종류</a></li><li class="depth-0"><a href="#scope-of-identifier" data-for="scope-of-identifier">Scope of Identifier</a></li><li class="depth-0"><a href="#store" data-for="store">Store</a></li></ul></div></div><div class="backlinks "><h3>Backlinks</h3><ul class="overflow"><li><a href="../../../../gardens/pl/originals/pl.spring.2021.cse.cnu.ac.kr/(충남대)-프로그래밍-언어-개론-강의록" class="internal">(충남대) 프로그래밍 언어 개론 강의록</a></li></ul></div></div></div><footer class><hr/><p>Created with <a href="https://quartz.jzhao.xyz/">Quartz v4.1.0</a>, © 2024</p><ul><li><a href="https://github.com/haeramkeem">GitHub</a></li><li><a href="www.linkedin.com/in/haeram-kim-277404220">LinkedIn</a></li><li><a href="mailto:haeram.kim1@gmail.com">Email</a></li></ul></footer></div></body><script type="application/javascript">// quartz/components/scripts/quartz/components/scripts/callout.inline.ts
function toggleCallout() {
  const outerBlock = this.parentElement;
  outerBlock.classList.toggle(`is-collapsed`);
  const collapsed = outerBlock.classList.contains(`is-collapsed`);
  const height = collapsed ? this.scrollHeight : outerBlock.scrollHeight;
  outerBlock.style.maxHeight = height + `px`;
  let current = outerBlock;
  let parent = outerBlock.parentElement;
  while (parent) {
    if (!parent.classList.contains(`callout`)) {
      return;
    }
    const collapsed2 = parent.classList.contains(`is-collapsed`);
    const height2 = collapsed2 ? parent.scrollHeight : parent.scrollHeight + current.scrollHeight;
    parent.style.maxHeight = height2 + `px`;
    current = parent;
    parent = parent.parentElement;
  }
}
function setupCallout() {
  const collapsible = document.getElementsByClassName(
    `callout is-collapsible`
  );
  for (const div of collapsible) {
    const title = div.firstElementChild;
    if (title) {
      title.removeEventListener(`click`, toggleCallout);
      title.addEventListener(`click`, toggleCallout);
      const collapsed = div.classList.contains(`is-collapsed`);
      const height = collapsed ? title.scrollHeight : div.scrollHeight;
      div.style.maxHeight = height + `px`;
    }
  }
}
document.addEventListener(`nav`, setupCallout);
window.addEventListener(`resize`, setupCallout);
</script><script type="module">
          import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.esm.min.mjs';
          const darkMode = document.documentElement.getAttribute('saved-theme') === 'dark'
          mermaid.initialize({
            startOnLoad: false,
            securityLevel: 'loose',
            theme: darkMode ? 'dark' : 'default'
          });
          document.addEventListener('nav', async () => {
            await mermaid.run({
              querySelector: '.mermaid'
            })
          });
          </script><script src="https://cdn.jsdelivr.net/npm/katex@0.16.7/dist/contrib/copy-tex.min.js" type="application/javascript"></script><script src="https://www.googletagmanager.com/gtag/js?id=G-N68CCP1QHG" type="application/javascript"></script><script src="../../../../postscript.js" type="module"></script></html>