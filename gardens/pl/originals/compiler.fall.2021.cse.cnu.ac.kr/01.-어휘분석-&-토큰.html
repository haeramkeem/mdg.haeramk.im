<!DOCTYPE html>
<html><head><title>01. 어휘분석 &amp; 토큰</title><meta charSet="utf-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:title" content="01. 어휘분석 &amp; 토큰"/><meta property="og:description" content="충남대학교 컴퓨터공학과 조은선 교수님의 &amp;quot;컴파일러 개론&amp;quot; 강의를 필기한 내용입니다. 다소 잘못된 내용과 구어적 표현 이 포함되어 있을 수 있습니다. 컴파일러 전반부의 과정 § 전처리기 : # include, # define, # ifdef등의 명령을 처리해서 전처리가 완료된 소스코드로 변환함 Lexical analysis Syntax analysis Semantic analysis Lexical analysis § 전처리가 완료된 소스코드를 하나의 문자열로 보고 문법적으로 의미있는 최소단위인 토큰 으로 쪼개는 과정 토큰은 다음과 같이 5개 정도의 종류가 있다 키워드나 연산자는 사용자가 마음대로 적는게 아니기 때문에 exact match가 가능하다 - if는 바로 분기문이라는 의미의 토큰으로 분류가 가능 하지만 식별자와 상수, 문자열의 경우에는 사용자가 지정하는 것이기 때문에 exact match를 할 수 없고 조금 더 처리를 해줘야 한다 어디까지가 하나의 토큰인지, 이놈이 어떤 역할을 하는놈인지 바로 알기 힘든 경우가 많다더라 토큰을 기술하는 방법 § 토큰을 기술하는 방법중 하나로 정규표현식을 활용한다 이것만 안까먹으면 너가 알던 정규표현식이랑 똑같더라 문제 ^a 100$ 해결못함 토큰을 인식하는 방법 § 그냥 정규표현식 라이브러리 사용하면 된다 근데 좀 더 원론적인 부분으로 들어와서 우리가 그 라이브러리를 만드는 입장일때 정규표현식으로 토큰을 인식하는 방법으로 FSA 를 사용한다 프언개에서 배운거다 - Finite State Automata 즉, 유한상태 오토마타를 의미하는 것 다시 복습해보자면 시작상태와 끝 상태가 있고 시작상태와 끝 상태 사이에는 유한한 상태들이 존재하며 특정 조건에 따라 상태가 전이되는 오토마타인 것 모든 정규식은 FSA로 표현될 수 있고 모든 FSA는 정규식으로 표현될 수 있댄다 토큰을 인식하는 절차는 기술된 정규표현식을 FSA로 변환하고 FSA대로 문자열의 문자 하나하나를 처리하게 된다 근데 FSA로 변환하는 과정에 NFA와 DFA를 거치게 된다 NFA와 DFA는 모두 FSA의 한 종류인데, FSA는 한 상태에서 뻗어나가는 edge(화살표)에 붙은 레이블(문자)에 대한 제약조건이 없다 즉, 하나의 상태에서 같은 레이블이 붙은 화살표가 여러개 있어도 된다는 소리이다 이때, 이것에 대해 제약조건을 준게 DFA이다 즉, DFA(Deterministic Finite Automata) 라는 것은 한 상태에서 뻗어나가는 edge의 레이블은 모두 달라야된다(Deterministic 해야 된다)는 것을 만족하는 FSA를 말한다 반대로 DFA에 포함되지 않는 FSA를 Non-DFA라고 해서 NFA 라고 한다 따라서 토큰 인식은 다음과 같은 순서를 따르게 된다 정규식을 NFA로 변환하고(변환 알고리즘이 알려져 있다) NFA를 DFA로 변환하고(이것도 알려져 있다) DFA를 돌려서 토큰을 인식하는 그리고 여러 정규표현식에 매칭되어 구분될 수 있는 토큰의 경우에는 Greedy하게 처리 = 제일 길이가 긴놈으로 처리하게 된다 토큰인식한 토큰을 처리하는 방법 § Lexeme이라는 자료형을 사용 - (토큰번호, 토큰값)의 형태로 처리하게 된다 위의 예제를 보면 if는 29번, 변수들은 1번, &amp;lt;는 18번 등으로 처리된 것을 알 수 있고 키워드나 연산자의 경우에는 값으로 0이 들어가지만 변수나 상수는 값으로 그 키워드의 변수 / 상수가 들어가는 것을 알 수 있다 변수(상수)들에 대해 같은 번호를 쓰고 값을 다르게 하는 이유는 키워드나 연산자의 경우에는 exact match이지만 변수나 상수의 경우에는 사용자가 지정하는 값이기 때문이라고 생각할 수 있다 그리고 회색글씨처럼 변수번호를 지정해서 값으로 넣어주고 symbol table을 만들어주는 것도 가능한 방법이다 C언어의 구조체로 표현하면 대략 위처럼 된다 union은 타입스크립트에서의 union type과 비슷하다고 생각하면 된다 문자 배열 또는 정수가 저장될 수 있으며 이 문자 배열과 정수가 따로따로 메모리를 할당받는게 아니라 하나의 메모리 공간에 들어가게 되는 것 int number에 토큰 번호가 들어가게 되며 char id[] 에는 변수(식별자)의 경우 이름이 들어가고 int num에는 상수의 경우 그 상수의 값이 들어가게 된다 구문문석기 § 어휘분석기는 scanner()라는 함수를 제공하고 구분분석기가 이 scanner()함수를 호출함으로 다음 토큰을 받아오는 형식으로 구현된다 ."/><meta property="og:image" content="https://mdg.haeramk.im/static/og-image.png"/><meta property="og:width" content="1200"/><meta property="og:height" content="675"/><link rel="icon" href="../../../../static/icon.png"/><meta name="description" content="충남대학교 컴퓨터공학과 조은선 교수님의 &amp;quot;컴파일러 개론&amp;quot; 강의를 필기한 내용입니다. 다소 잘못된 내용과 구어적 표현 이 포함되어 있을 수 있습니다. 컴파일러 전반부의 과정 § 전처리기 : # include, # define, # ifdef등의 명령을 처리해서 전처리가 완료된 소스코드로 변환함 Lexical analysis Syntax analysis Semantic analysis Lexical analysis § 전처리가 완료된 소스코드를 하나의 문자열로 보고 문법적으로 의미있는 최소단위인 토큰 으로 쪼개는 과정 토큰은 다음과 같이 5개 정도의 종류가 있다 키워드나 연산자는 사용자가 마음대로 적는게 아니기 때문에 exact match가 가능하다 - if는 바로 분기문이라는 의미의 토큰으로 분류가 가능 하지만 식별자와 상수, 문자열의 경우에는 사용자가 지정하는 것이기 때문에 exact match를 할 수 없고 조금 더 처리를 해줘야 한다 어디까지가 하나의 토큰인지, 이놈이 어떤 역할을 하는놈인지 바로 알기 힘든 경우가 많다더라 토큰을 기술하는 방법 § 토큰을 기술하는 방법중 하나로 정규표현식을 활용한다 이것만 안까먹으면 너가 알던 정규표현식이랑 똑같더라 문제 ^a 100$ 해결못함 토큰을 인식하는 방법 § 그냥 정규표현식 라이브러리 사용하면 된다 근데 좀 더 원론적인 부분으로 들어와서 우리가 그 라이브러리를 만드는 입장일때 정규표현식으로 토큰을 인식하는 방법으로 FSA 를 사용한다 프언개에서 배운거다 - Finite State Automata 즉, 유한상태 오토마타를 의미하는 것 다시 복습해보자면 시작상태와 끝 상태가 있고 시작상태와 끝 상태 사이에는 유한한 상태들이 존재하며 특정 조건에 따라 상태가 전이되는 오토마타인 것 모든 정규식은 FSA로 표현될 수 있고 모든 FSA는 정규식으로 표현될 수 있댄다 토큰을 인식하는 절차는 기술된 정규표현식을 FSA로 변환하고 FSA대로 문자열의 문자 하나하나를 처리하게 된다 근데 FSA로 변환하는 과정에 NFA와 DFA를 거치게 된다 NFA와 DFA는 모두 FSA의 한 종류인데, FSA는 한 상태에서 뻗어나가는 edge(화살표)에 붙은 레이블(문자)에 대한 제약조건이 없다 즉, 하나의 상태에서 같은 레이블이 붙은 화살표가 여러개 있어도 된다는 소리이다 이때, 이것에 대해 제약조건을 준게 DFA이다 즉, DFA(Deterministic Finite Automata) 라는 것은 한 상태에서 뻗어나가는 edge의 레이블은 모두 달라야된다(Deterministic 해야 된다)는 것을 만족하는 FSA를 말한다 반대로 DFA에 포함되지 않는 FSA를 Non-DFA라고 해서 NFA 라고 한다 따라서 토큰 인식은 다음과 같은 순서를 따르게 된다 정규식을 NFA로 변환하고(변환 알고리즘이 알려져 있다) NFA를 DFA로 변환하고(이것도 알려져 있다) DFA를 돌려서 토큰을 인식하는 그리고 여러 정규표현식에 매칭되어 구분될 수 있는 토큰의 경우에는 Greedy하게 처리 = 제일 길이가 긴놈으로 처리하게 된다 토큰인식한 토큰을 처리하는 방법 § Lexeme이라는 자료형을 사용 - (토큰번호, 토큰값)의 형태로 처리하게 된다 위의 예제를 보면 if는 29번, 변수들은 1번, &amp;lt;는 18번 등으로 처리된 것을 알 수 있고 키워드나 연산자의 경우에는 값으로 0이 들어가지만 변수나 상수는 값으로 그 키워드의 변수 / 상수가 들어가는 것을 알 수 있다 변수(상수)들에 대해 같은 번호를 쓰고 값을 다르게 하는 이유는 키워드나 연산자의 경우에는 exact match이지만 변수나 상수의 경우에는 사용자가 지정하는 값이기 때문이라고 생각할 수 있다 그리고 회색글씨처럼 변수번호를 지정해서 값으로 넣어주고 symbol table을 만들어주는 것도 가능한 방법이다 C언어의 구조체로 표현하면 대략 위처럼 된다 union은 타입스크립트에서의 union type과 비슷하다고 생각하면 된다 문자 배열 또는 정수가 저장될 수 있으며 이 문자 배열과 정수가 따로따로 메모리를 할당받는게 아니라 하나의 메모리 공간에 들어가게 되는 것 int number에 토큰 번호가 들어가게 되며 char id[] 에는 변수(식별자)의 경우 이름이 들어가고 int num에는 상수의 경우 그 상수의 값이 들어가게 된다 구문문석기 § 어휘분석기는 scanner()라는 함수를 제공하고 구분분석기가 이 scanner()함수를 호출함으로 다음 토큰을 받아오는 형식으로 구현된다 ."/><meta name="generator" content="Quartz"/><link rel="preconnect" href="https://fonts.googleapis.com"/><link rel="preconnect" href="https://fonts.gstatic.com"/><link href="../../../../index.css" rel="stylesheet" type="text/css" spa-preserve/><link href="https://cdn.jsdelivr.net/npm/katex@0.16.0/dist/katex.min.css" rel="stylesheet" type="text/css" spa-preserve/><link href="https://fonts.googleapis.com/css2?family=IBM Plex Mono&amp;family=Gowun Batang:wght@400;700&amp;family=Gowun Dodum:ital,wght@0,400;0,600;1,400;1,600&amp;display=swap" rel="stylesheet" type="text/css" spa-preserve/><script src="../../../../prescript.js" type="application/javascript" spa-preserve></script><script type="application/javascript" spa-preserve>const fetchData = fetch(`../../../../static/contentIndex.json`).then(data => data.json())</script></head><body data-slug="gardens/pl/originals/compiler.fall.2021.cse.cnu.ac.kr/01.-어휘분석-&amp;-토큰"><div id="quartz-root" class="page"><div id="quartz-body"><div class="left sidebar"><h1 class="page-title "><a href="../../../..">Madison Digital Garden</a></h1><div class="spacer mobile-only"></div><div class="search "><div id="search-icon"><p>Search</p><div></div><svg tabIndex="0" aria-labelledby="title desc" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 19.9 19.7"><title id="title">Search</title><desc id="desc">Search</desc><g class="search-path" fill="none"><path stroke-linecap="square" d="M18.5 18.3l-5.4-5.4"></path><circle cx="8" cy="8" r="7"></circle></g></svg></div><div id="search-container"><div id="search-space"><input autocomplete="off" id="search-bar" name="search" type="text" aria-label="Search for something" placeholder="Search for something"/><div id="results-container"></div></div></div></div><div class="darkmode "><input class="toggle" id="darkmode-toggle" type="checkbox" tabIndex="-1"/><label id="toggle-label-light" for="darkmode-toggle" tabIndex="-1"><svg xmlns="http://www.w3.org/2000/svg" xmlnsXlink="http://www.w3.org/1999/xlink" version="1.1" id="dayIcon" x="0px" y="0px" viewBox="0 0 35 35" style="enable-background:new 0 0 35 35;" xmlSpace="preserve"><title>Light mode</title><path d="M6,17.5C6,16.672,5.328,16,4.5,16h-3C0.672,16,0,16.672,0,17.5    S0.672,19,1.5,19h3C5.328,19,6,18.328,6,17.5z M7.5,26c-0.414,0-0.789,0.168-1.061,0.439l-2,2C4.168,28.711,4,29.086,4,29.5    C4,30.328,4.671,31,5.5,31c0.414,0,0.789-0.168,1.06-0.44l2-2C8.832,28.289,9,27.914,9,27.5C9,26.672,8.329,26,7.5,26z M17.5,6    C18.329,6,19,5.328,19,4.5v-3C19,0.672,18.329,0,17.5,0S16,0.672,16,1.5v3C16,5.328,16.671,6,17.5,6z M27.5,9    c0.414,0,0.789-0.168,1.06-0.439l2-2C30.832,6.289,31,5.914,31,5.5C31,4.672,30.329,4,29.5,4c-0.414,0-0.789,0.168-1.061,0.44    l-2,2C26.168,6.711,26,7.086,26,7.5C26,8.328,26.671,9,27.5,9z M6.439,8.561C6.711,8.832,7.086,9,7.5,9C8.328,9,9,8.328,9,7.5    c0-0.414-0.168-0.789-0.439-1.061l-2-2C6.289,4.168,5.914,4,5.5,4C4.672,4,4,4.672,4,5.5c0,0.414,0.168,0.789,0.439,1.06    L6.439,8.561z M33.5,16h-3c-0.828,0-1.5,0.672-1.5,1.5s0.672,1.5,1.5,1.5h3c0.828,0,1.5-0.672,1.5-1.5S34.328,16,33.5,16z     M28.561,26.439C28.289,26.168,27.914,26,27.5,26c-0.828,0-1.5,0.672-1.5,1.5c0,0.414,0.168,0.789,0.439,1.06l2,2    C28.711,30.832,29.086,31,29.5,31c0.828,0,1.5-0.672,1.5-1.5c0-0.414-0.168-0.789-0.439-1.061L28.561,26.439z M17.5,29    c-0.829,0-1.5,0.672-1.5,1.5v3c0,0.828,0.671,1.5,1.5,1.5s1.5-0.672,1.5-1.5v-3C19,29.672,18.329,29,17.5,29z M17.5,7    C11.71,7,7,11.71,7,17.5S11.71,28,17.5,28S28,23.29,28,17.5S23.29,7,17.5,7z M17.5,25c-4.136,0-7.5-3.364-7.5-7.5    c0-4.136,3.364-7.5,7.5-7.5c4.136,0,7.5,3.364,7.5,7.5C25,21.636,21.636,25,17.5,25z"></path></svg></label><label id="toggle-label-dark" for="darkmode-toggle" tabIndex="-1"><svg xmlns="http://www.w3.org/2000/svg" xmlnsXlink="http://www.w3.org/1999/xlink" version="1.1" id="nightIcon" x="0px" y="0px" viewBox="0 0 100 100" style="enable-background='new 0 0 100 100'" xmlSpace="preserve"><title>Dark mode</title><path d="M96.76,66.458c-0.853-0.852-2.15-1.064-3.23-0.534c-6.063,2.991-12.858,4.571-19.655,4.571  C62.022,70.495,50.88,65.88,42.5,57.5C29.043,44.043,25.658,23.536,34.076,6.47c0.532-1.08,0.318-2.379-0.534-3.23  c-0.851-0.852-2.15-1.064-3.23-0.534c-4.918,2.427-9.375,5.619-13.246,9.491c-9.447,9.447-14.65,22.008-14.65,35.369  c0,13.36,5.203,25.921,14.65,35.368s22.008,14.65,35.368,14.65c13.361,0,25.921-5.203,35.369-14.65  c3.872-3.871,7.064-8.328,9.491-13.246C97.826,68.608,97.611,67.309,96.76,66.458z"></path></svg></label></div></div><div class="center"><div class="page-header"><div class="popover-hint"><h1 class="article-title ">01. 어휘분석 &amp; 토큰</h1><p class="content-meta ">Oct 07, 2024, 7 min read</p></div></div><article class="popover-hint"><blockquote class="callout" data-callout="info">
<div class="callout-title">
                  <div class="callout-icon"><svg xmlns="http://www.w3.org/2000/svg" width="100%" height="100%" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="10"></circle><line x1="12" y1="16" x2="12" y2="12"></line><line x1="12" y1="8" x2="12.01" y2="8"></line></svg></div>
                  <div class="callout-title-inner"><p>충남대학교 컴퓨터공학과 조은선 교수님의 &quot;컴파일러 개론&quot; 강의를 필기한 내용입니다. </p></div>
                  
                </div>
</blockquote>
<blockquote class="callout" data-callout="warning">
<div class="callout-title">
                  <div class="callout-icon"><svg xmlns="http://www.w3.org/2000/svg" width="100%" height="100%" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="m21.73 18-8-14a2 2 0 0 0-3.48 0l-8 14A2 2 0 0 0 4 21h16a2 2 0 0 0 1.73-3Z"></path><line x1="12" y1="9" x2="12" y2="13"></line><line x1="12" y1="17" x2="12.01" y2="17"></line></svg></div>
                  <div class="callout-title-inner"><p>다소 잘못된 내용과 구어적 표현 이 포함되어 있을 수 있습니다. </p></div>
                  
                </div>
</blockquote>
<h2 id="컴파일러-전반부의-과정">컴파일러 전반부의 과정<a aria-hidden="true" tabindex="-1" href="#컴파일러-전반부의-과정" class="internal"> §</a></h2>
<ol>
<li>전처리기 : # include, # define, # ifdef등의 명령을 처리해서 전처리가 완료된 소스코드로 변환함</li>
<li>Lexical analysis</li>
<li>Syntax analysis</li>
<li>Semantic analysis</li>
</ol>
<h2 id="lexical-analysis">Lexical analysis<a aria-hidden="true" tabindex="-1" href="#lexical-analysis" class="internal"> §</a></h2>
<ul>
<li>전처리가 완료된 소스코드를 하나의 문자열로 보고 문법적으로 의미있는 최소단위인 <strong>토큰</strong> 으로 쪼개는 과정</li>
<li>토큰은 다음과 같이 5개 정도의 종류가 있다</li>
</ul>
<p><img src="../../../../gardens/pl/originals/compiler.fall.2021.cse.cnu.ac.kr/images/01_2170916fad514f6d920e08ed83d324d9/image1.png" alt="%E1%84%8B%E1%85%B5%E1%84%85%E1%85%A9%E1%86%AB01%20-%20%E1%84%8B%E1%85%A5%E1%84%92%E1%85%B1%E1%84%87%E1%85%AE%E1%86%AB%E1%84%89%E1%85%A5%E1%86%A8%20&amp;%20%E1%84%90%E1%85%A9%E1%84%8F%E1%85%B3%E1%86%AB%202170916fad514f6d920e08ed83d324d9/image1.png"/></p>
<ul>
<li>키워드나 연산자는 사용자가 마음대로 적는게 아니기 때문에 <strong>exact match</strong>가 가능하다 - if는 바로 분기문이라는 의미의 토큰으로 분류가 가능</li>
<li>하지만 식별자와 상수, 문자열의 경우에는 사용자가 지정하는 것이기 때문에 exact match를 할 수 없고 조금 더 처리를 해줘야 한다
<ul>
<li>어디까지가 하나의 토큰인지, 이놈이 어떤 역할을 하는놈인지 바로 알기 힘든 경우가 많다더라</li>
</ul>
</li>
</ul>
<h3 id="토큰을-기술하는-방법">토큰을 기술하는 방법<a aria-hidden="true" tabindex="-1" href="#토큰을-기술하는-방법" class="internal"> §</a></h3>
<ul>
<li>토큰을 기술하는 방법중 하나로 <strong>정규표현식</strong>을 활용한다</li>
</ul>
<p><img src="../../../../gardens/pl/originals/compiler.fall.2021.cse.cnu.ac.kr/images/01_2170916fad514f6d920e08ed83d324d9/image2.png" alt="%E1%84%8B%E1%85%B5%E1%84%85%E1%85%A9%E1%86%AB01%20-%20%E1%84%8B%E1%85%A5%E1%84%92%E1%85%B1%E1%84%87%E1%85%AE%E1%86%AB%E1%84%89%E1%85%A5%E1%86%A8%20&amp;%20%E1%84%90%E1%85%A9%E1%84%8F%E1%85%B3%E1%86%AB%202170916fad514f6d920e08ed83d324d9/image2.png"/></p>
<ul>
<li>이것만 안까먹으면 너가 알던 정규표현식이랑 똑같더라</li>
<li>문제</li>
</ul>
<p><img src="../../../../gardens/pl/originals/compiler.fall.2021.cse.cnu.ac.kr/images/01_2170916fad514f6d920e08ed83d324d9/image3.png" alt="%E1%84%8B%E1%85%B5%E1%84%85%E1%85%A9%E1%86%AB01%20-%20%E1%84%8B%E1%85%A5%E1%84%92%E1%85%B1%E1%84%87%E1%85%AE%E1%86%AB%E1%84%89%E1%85%A5%E1%86%A8%20&amp;%20%E1%84%90%E1%85%A9%E1%84%8F%E1%85%B3%E1%86%AB%202170916fad514f6d920e08ed83d324d9/image3.png"/></p>
<ul>
<li><code>^a</code></li>
<li>100$</li>
<li>해결못함</li>
</ul>
<h3 id="토큰을-인식하는-방법">토큰을 인식하는 방법<a aria-hidden="true" tabindex="-1" href="#토큰을-인식하는-방법" class="internal"> §</a></h3>
<ul>
<li>그냥 정규표현식 라이브러리 사용하면 된다</li>
<li>근데 좀 더 원론적인 부분으로 들어와서 우리가 그 라이브러리를 만드는 입장일때 정규표현식으로 토큰을 인식하는 방법으로 <strong>FSA</strong> 를 사용한다
<ul>
<li>프언개에서 배운거다 - <strong>Finite State Automata</strong> 즉, <strong>유한상태 오토마타</strong>를 의미하는 것</li>
</ul>
</li>
</ul>
<p><img src="../../../../gardens/pl/originals/compiler.fall.2021.cse.cnu.ac.kr/images/01_2170916fad514f6d920e08ed83d324d9/image4.png" alt="%E1%84%8B%E1%85%B5%E1%84%85%E1%85%A9%E1%86%AB01%20-%20%E1%84%8B%E1%85%A5%E1%84%92%E1%85%B1%E1%84%87%E1%85%AE%E1%86%AB%E1%84%89%E1%85%A5%E1%86%A8%20&amp;%20%E1%84%90%E1%85%A9%E1%84%8F%E1%85%B3%E1%86%AB%202170916fad514f6d920e08ed83d324d9/image4.png"/></p>
<ul>
<li>다시 복습해보자면
<ul>
<li>시작상태와 끝 상태가 있고</li>
<li>시작상태와 끝 상태 사이에는 유한한 상태들이 존재하며</li>
<li>특정 조건에 따라 상태가 전이되는 오토마타인 것</li>
</ul>
</li>
<li>모든 정규식은 FSA로 표현될 수 있고 모든 FSA는 정규식으로 표현될 수 있댄다</li>
<li>토큰을 인식하는 절차는 기술된 정규표현식을 FSA로 변환하고 FSA대로 문자열의 문자 하나하나를 처리하게 된다</li>
<li>근데 FSA로 변환하는 과정에 <strong>NFA</strong>와 <strong>DFA</strong>를 거치게 된다</li>
<li><strong>NFA</strong>와 <strong>DFA</strong>는 모두 FSA의 한 종류인데, FSA는 한 상태에서 뻗어나가는 edge(화살표)에 붙은 레이블(문자)에 대한 제약조건이 없다</li>
<li>즉, 하나의 상태에서 같은 레이블이 붙은 화살표가 여러개 있어도 된다는 소리이다</li>
<li>이때, 이것에 대해 제약조건을 준게 <strong>DFA</strong>이다
<ul>
<li>즉, <strong>DFA(Deterministic Finite Automata)</strong> 라는 것은 한 상태에서 뻗어나가는 edge의 레이블은 모두 달라야된다(Deterministic 해야 된다)는 것을 만족하는 FSA를 말한다</li>
</ul>
</li>
<li>반대로 DFA에 포함되지 않는 FSA를 Non-DFA라고 해서 <strong>NFA</strong> 라고 한다</li>
<li>따라서 토큰 인식은 다음과 같은 순서를 따르게 된다
<ol>
<li>정규식을 NFA로 변환하고(변환 알고리즘이 알려져 있다)</li>
<li>NFA를 DFA로 변환하고(이것도 알려져 있다)</li>
<li>DFA를 돌려서 토큰을 인식하는 그리고 여러 정규표현식에 매칭되어 구분될 수 있는 토큰의 경우에는 Greedy하게 처리 = 제일 길이가 긴놈으로 처리하게 된다</li>
</ol>
</li>
</ul>
<h3 id="토큰인식한-토큰을-처리하는-방법">토큰인식한 토큰을 처리하는 방법<a aria-hidden="true" tabindex="-1" href="#토큰인식한-토큰을-처리하는-방법" class="internal"> §</a></h3>
<ul>
<li><strong>Lexeme</strong>이라는 자료형을 사용 - (토큰번호, 토큰값)의 형태로 처리하게 된다</li>
</ul>
<p><img src="../../../../gardens/pl/originals/compiler.fall.2021.cse.cnu.ac.kr/images/01_2170916fad514f6d920e08ed83d324d9/image5.png" alt="%E1%84%8B%E1%85%B5%E1%84%85%E1%85%A9%E1%86%AB01%20-%20%E1%84%8B%E1%85%A5%E1%84%92%E1%85%B1%E1%84%87%E1%85%AE%E1%86%AB%E1%84%89%E1%85%A5%E1%86%A8%20&amp;%20%E1%84%90%E1%85%A9%E1%84%8F%E1%85%B3%E1%86%AB%202170916fad514f6d920e08ed83d324d9/image5.png"/></p>
<ul>
<li>위의 예제를 보면 if는 29번, 변수들은 1번, &lt;는 18번 등으로 처리된 것을 알 수 있고</li>
<li>키워드나 연산자의 경우에는 값으로 0이 들어가지만 변수나 상수는 값으로 그 키워드의 변수 / 상수가 들어가는 것을 알 수 있다</li>
<li>변수(상수)들에 대해 같은 번호를 쓰고 값을 다르게 하는 이유는 키워드나 연산자의 경우에는 exact match이지만 변수나 상수의 경우에는 사용자가 지정하는 값이기 때문이라고 생각할 수 있다</li>
<li>그리고 회색글씨처럼 변수번호를 지정해서 값으로 넣어주고 symbol table을 만들어주는 것도 가능한 방법이다</li>
</ul>
<p><img src="../../../../gardens/pl/originals/compiler.fall.2021.cse.cnu.ac.kr/images/01_2170916fad514f6d920e08ed83d324d9/image6.png" alt="%E1%84%8B%E1%85%B5%E1%84%85%E1%85%A9%E1%86%AB01%20-%20%E1%84%8B%E1%85%A5%E1%84%92%E1%85%B1%E1%84%87%E1%85%AE%E1%86%AB%E1%84%89%E1%85%A5%E1%86%A8%20&amp;%20%E1%84%90%E1%85%A9%E1%84%8F%E1%85%B3%E1%86%AB%202170916fad514f6d920e08ed83d324d9/image6.png"/></p>
<ul>
<li>C언어의 구조체로 표현하면 대략 위처럼 된다</li>
<li>union은 타입스크립트에서의 union type과 비슷하다고 생각하면 된다
<ul>
<li>문자 배열 또는 정수가 저장될 수 있으며 이 문자 배열과 정수가 따로따로 메모리를 할당받는게 아니라 하나의 메모리 공간에 들어가게 되는 것</li>
</ul>
</li>
<li>int number에 토큰 번호가 들어가게 되며</li>
<li>char id[] 에는 변수(식별자)의 경우 이름이 들어가고</li>
<li>int num에는 상수의 경우 그 상수의 값이 들어가게 된다</li>
</ul>
<h2 id="구문문석기">구문문석기<a aria-hidden="true" tabindex="-1" href="#구문문석기" class="internal"> §</a></h2>
<p><img src="../../../../gardens/pl/originals/compiler.fall.2021.cse.cnu.ac.kr/images/01_2170916fad514f6d920e08ed83d324d9/image7.png" alt="%E1%84%8B%E1%85%B5%E1%84%85%E1%85%A9%E1%86%AB01%20-%20%E1%84%8B%E1%85%A5%E1%84%92%E1%85%B1%E1%84%87%E1%85%AE%E1%86%AB%E1%84%89%E1%85%A5%E1%86%A8%20&amp;%20%E1%84%90%E1%85%A9%E1%84%8F%E1%85%B3%E1%86%AB%202170916fad514f6d920e08ed83d324d9/image7.png"/></p>
<ul>
<li>어휘분석기는 scanner()라는 함수를 제공하고 구분분석기가 이 scanner()함수를 호출함으로 다음 토큰을 받아오는 형식으로 구현된다</li>
</ul></article></div><div class="right sidebar"><div class="graph "><h3>Graph View</h3><div class="graph-outer"><div id="graph-container" data-cfg="{&quot;drag&quot;:true,&quot;zoom&quot;:true,&quot;depth&quot;:1,&quot;scale&quot;:1.1,&quot;repelForce&quot;:0.5,&quot;centerForce&quot;:0.3,&quot;linkDistance&quot;:30,&quot;fontSize&quot;:0.6,&quot;opacityScale&quot;:1,&quot;showTags&quot;:true,&quot;removeTags&quot;:[]}"></div><svg version="1.1" id="global-graph-icon" xmlns="http://www.w3.org/2000/svg" xmlnsXlink="http://www.w3.org/1999/xlink" x="0px" y="0px" viewBox="0 0 55 55" fill="currentColor" xmlSpace="preserve"><path d="M49,0c-3.309,0-6,2.691-6,6c0,1.035,0.263,2.009,0.726,2.86l-9.829,9.829C32.542,17.634,30.846,17,29,17
	s-3.542,0.634-4.898,1.688l-7.669-7.669C16.785,10.424,17,9.74,17,9c0-2.206-1.794-4-4-4S9,6.794,9,9s1.794,4,4,4
	c0.74,0,1.424-0.215,2.019-0.567l7.669,7.669C21.634,21.458,21,23.154,21,25s0.634,3.542,1.688,4.897L10.024,42.562
	C8.958,41.595,7.549,41,6,41c-3.309,0-6,2.691-6,6s2.691,6,6,6s6-2.691,6-6c0-1.035-0.263-2.009-0.726-2.86l12.829-12.829
	c1.106,0.86,2.44,1.436,3.898,1.619v10.16c-2.833,0.478-5,2.942-5,5.91c0,3.309,2.691,6,6,6s6-2.691,6-6c0-2.967-2.167-5.431-5-5.91
	v-10.16c1.458-0.183,2.792-0.759,3.898-1.619l7.669,7.669C41.215,39.576,41,40.26,41,41c0,2.206,1.794,4,4,4s4-1.794,4-4
	s-1.794-4-4-4c-0.74,0-1.424,0.215-2.019,0.567l-7.669-7.669C36.366,28.542,37,26.846,37,25s-0.634-3.542-1.688-4.897l9.665-9.665
	C46.042,11.405,47.451,12,49,12c3.309,0,6-2.691,6-6S52.309,0,49,0z M11,9c0-1.103,0.897-2,2-2s2,0.897,2,2s-0.897,2-2,2
	S11,10.103,11,9z M6,51c-2.206,0-4-1.794-4-4s1.794-4,4-4s4,1.794,4,4S8.206,51,6,51z M33,49c0,2.206-1.794,4-4,4s-4-1.794-4-4
	s1.794-4,4-4S33,46.794,33,49z M29,31c-3.309,0-6-2.691-6-6s2.691-6,6-6s6,2.691,6,6S32.309,31,29,31z M47,41c0,1.103-0.897,2-2,2
	s-2-0.897-2-2s0.897-2,2-2S47,39.897,47,41z M49,10c-2.206,0-4-1.794-4-4s1.794-4,4-4s4,1.794,4,4S51.206,10,49,10z"></path></svg></div><div id="global-graph-outer"><div id="global-graph-container" data-cfg="{&quot;drag&quot;:true,&quot;zoom&quot;:true,&quot;depth&quot;:-1,&quot;scale&quot;:0.9,&quot;repelForce&quot;:0.5,&quot;centerForce&quot;:0.3,&quot;linkDistance&quot;:30,&quot;fontSize&quot;:0.6,&quot;opacityScale&quot;:1,&quot;showTags&quot;:true,&quot;removeTags&quot;:[]}"></div></div></div><div class="toc desktop-only"><button type="button" id="toc"><h3>Table of Contents</h3><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="fold"><polyline points="6 9 12 15 18 9"></polyline></svg></button><div id="toc-content"><ul class="overflow"><li class="depth-0"><a href="#컴파일러-전반부의-과정" data-for="컴파일러-전반부의-과정">컴파일러 전반부의 과정</a></li><li class="depth-0"><a href="#lexical-analysis" data-for="lexical-analysis">Lexical analysis</a></li><li class="depth-1"><a href="#토큰을-기술하는-방법" data-for="토큰을-기술하는-방법">토큰을 기술하는 방법</a></li><li class="depth-1"><a href="#토큰을-인식하는-방법" data-for="토큰을-인식하는-방법">토큰을 인식하는 방법</a></li><li class="depth-1"><a href="#토큰인식한-토큰을-처리하는-방법" data-for="토큰인식한-토큰을-처리하는-방법">토큰인식한 토큰을 처리하는 방법</a></li><li class="depth-0"><a href="#구문문석기" data-for="구문문석기">구문문석기</a></li></ul></div></div><div class="backlinks "><h3>Backlinks</h3><ul class="overflow"><li><a href="../../../../gardens/pl/originals/compiler.fall.2021.cse.cnu.ac.kr/(충남대)-컴파일러-개론-강의록" class="internal">(충남대) 컴파일러 개론 강의록</a></li></ul></div></div></div><footer class><hr/><p>Created with <a href="https://quartz.jzhao.xyz/">Quartz v4.1.0</a>, © 2024</p><ul><li><a href="https://github.com/haeramkeem">GitHub</a></li><li><a href="www.linkedin.com/in/haeram-kim-277404220">LinkedIn</a></li><li><a href="mailto:haeram.kim1@gmail.com">Email</a></li></ul></footer></div></body><script type="application/javascript">// quartz/components/scripts/quartz/components/scripts/callout.inline.ts
function toggleCallout() {
  const outerBlock = this.parentElement;
  outerBlock.classList.toggle(`is-collapsed`);
  const collapsed = outerBlock.classList.contains(`is-collapsed`);
  const height = collapsed ? this.scrollHeight : outerBlock.scrollHeight;
  outerBlock.style.maxHeight = height + `px`;
  let current = outerBlock;
  let parent = outerBlock.parentElement;
  while (parent) {
    if (!parent.classList.contains(`callout`)) {
      return;
    }
    const collapsed2 = parent.classList.contains(`is-collapsed`);
    const height2 = collapsed2 ? parent.scrollHeight : parent.scrollHeight + current.scrollHeight;
    parent.style.maxHeight = height2 + `px`;
    current = parent;
    parent = parent.parentElement;
  }
}
function setupCallout() {
  const collapsible = document.getElementsByClassName(
    `callout is-collapsible`
  );
  for (const div of collapsible) {
    const title = div.firstElementChild;
    if (title) {
      title.removeEventListener(`click`, toggleCallout);
      title.addEventListener(`click`, toggleCallout);
      const collapsed = div.classList.contains(`is-collapsed`);
      const height = collapsed ? title.scrollHeight : div.scrollHeight;
      div.style.maxHeight = height + `px`;
    }
  }
}
document.addEventListener(`nav`, setupCallout);
window.addEventListener(`resize`, setupCallout);
</script><script type="module">
          import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.esm.min.mjs';
          const darkMode = document.documentElement.getAttribute('saved-theme') === 'dark'
          mermaid.initialize({
            startOnLoad: false,
            securityLevel: 'loose',
            theme: darkMode ? 'dark' : 'default'
          });
          document.addEventListener('nav', async () => {
            await mermaid.run({
              querySelector: '.mermaid'
            })
          });
          </script><script src="https://cdn.jsdelivr.net/npm/katex@0.16.7/dist/contrib/copy-tex.min.js" type="application/javascript"></script><script src="https://www.googletagmanager.com/gtag/js?id=G-N68CCP1QHG" type="application/javascript"></script><script src="../../../../postscript.js" type="module"></script></html>