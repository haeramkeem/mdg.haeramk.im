<!DOCTYPE html>
<html><head><title>03. Tomasulo's Algorithm and Branch Prediction (Advanced Computer Architectures, SNU CSE)</title><meta charSet="utf-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:title" content="03. Tomasulo's Algorithm and Branch Prediction (Advanced Computer Architectures, SNU CSE)"/><meta property="og:description" content="서울대학교 컴퓨터공학부 유승주 교수님의 &amp;quot;고급 컴퓨터 구조&amp;quot; 강의를 필기한 내용입니다. 목차 Register Renaming § 내용 옮겨짐 Register Renaming (Arch) Tomasulo’s Algorithm § Tomasulo 의 특징을 간단하게 설명해 보면: Reservation station 을 통해 저런 register renaming 을 지원하고."/><meta property="og:image" content="https://mdg.haeramk.im/static/og-image.png"/><meta property="og:width" content="1200"/><meta property="og:height" content="675"/><link rel="icon" href="../../../../../static/icon.png"/><meta name="description" content="서울대학교 컴퓨터공학부 유승주 교수님의 &amp;quot;고급 컴퓨터 구조&amp;quot; 강의를 필기한 내용입니다. 목차 Register Renaming § 내용 옮겨짐 Register Renaming (Arch) Tomasulo’s Algorithm § Tomasulo 의 특징을 간단하게 설명해 보면: Reservation station 을 통해 저런 register renaming 을 지원하고."/><meta name="generator" content="Quartz"/><link rel="preconnect" href="https://fonts.googleapis.com"/><link rel="preconnect" href="https://fonts.gstatic.com"/><link href="../../../../../index.css" rel="stylesheet" type="text/css" spa-preserve/><link href="https://cdn.jsdelivr.net/npm/katex@0.16.0/dist/katex.min.css" rel="stylesheet" type="text/css" spa-preserve/><link href="https://fonts.googleapis.com/css2?family=IBM Plex Mono&amp;family=Gowun Batang:wght@400;700&amp;family=Gowun Dodum:ital,wght@0,400;0,600;1,400;1,600&amp;display=swap" rel="stylesheet" type="text/css" spa-preserve/><script src="../../../../../prescript.js" type="application/javascript" spa-preserve></script><script type="application/javascript" spa-preserve>const fetchData = fetch(`../../../../../static/contentIndex.json`).then(data => data.json())</script></head><body data-slug="gardens/arch/originals/aca.spring.2025.cse.snu.ac.kr/lectures/03.-Tomasulo's-Algorithm-and-Branch-Prediction"><div id="quartz-root" class="page"><div id="quartz-body"><div class="left sidebar"><h1 class="page-title "><a href="../../../../..">Madison Digital Garden</a></h1><div class="spacer mobile-only"></div><div class="search "><div id="search-icon"><p>Search</p><div></div><svg tabIndex="0" aria-labelledby="title desc" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 19.9 19.7"><title id="title">Search</title><desc id="desc">Search</desc><g class="search-path" fill="none"><path stroke-linecap="square" d="M18.5 18.3l-5.4-5.4"></path><circle cx="8" cy="8" r="7"></circle></g></svg></div><div id="search-container"><div id="search-space"><input autocomplete="off" id="search-bar" name="search" type="text" aria-label="Search for something" placeholder="Search for something"/><div id="results-container"></div></div></div></div><div class="darkmode "><input class="toggle" id="darkmode-toggle" type="checkbox" tabIndex="-1"/><label id="toggle-label-light" for="darkmode-toggle" tabIndex="-1"><svg xmlns="http://www.w3.org/2000/svg" xmlnsXlink="http://www.w3.org/1999/xlink" version="1.1" id="dayIcon" x="0px" y="0px" viewBox="0 0 35 35" style="enable-background:new 0 0 35 35;" xmlSpace="preserve"><title>Light mode</title><path d="M6,17.5C6,16.672,5.328,16,4.5,16h-3C0.672,16,0,16.672,0,17.5    S0.672,19,1.5,19h3C5.328,19,6,18.328,6,17.5z M7.5,26c-0.414,0-0.789,0.168-1.061,0.439l-2,2C4.168,28.711,4,29.086,4,29.5    C4,30.328,4.671,31,5.5,31c0.414,0,0.789-0.168,1.06-0.44l2-2C8.832,28.289,9,27.914,9,27.5C9,26.672,8.329,26,7.5,26z M17.5,6    C18.329,6,19,5.328,19,4.5v-3C19,0.672,18.329,0,17.5,0S16,0.672,16,1.5v3C16,5.328,16.671,6,17.5,6z M27.5,9    c0.414,0,0.789-0.168,1.06-0.439l2-2C30.832,6.289,31,5.914,31,5.5C31,4.672,30.329,4,29.5,4c-0.414,0-0.789,0.168-1.061,0.44    l-2,2C26.168,6.711,26,7.086,26,7.5C26,8.328,26.671,9,27.5,9z M6.439,8.561C6.711,8.832,7.086,9,7.5,9C8.328,9,9,8.328,9,7.5    c0-0.414-0.168-0.789-0.439-1.061l-2-2C6.289,4.168,5.914,4,5.5,4C4.672,4,4,4.672,4,5.5c0,0.414,0.168,0.789,0.439,1.06    L6.439,8.561z M33.5,16h-3c-0.828,0-1.5,0.672-1.5,1.5s0.672,1.5,1.5,1.5h3c0.828,0,1.5-0.672,1.5-1.5S34.328,16,33.5,16z     M28.561,26.439C28.289,26.168,27.914,26,27.5,26c-0.828,0-1.5,0.672-1.5,1.5c0,0.414,0.168,0.789,0.439,1.06l2,2    C28.711,30.832,29.086,31,29.5,31c0.828,0,1.5-0.672,1.5-1.5c0-0.414-0.168-0.789-0.439-1.061L28.561,26.439z M17.5,29    c-0.829,0-1.5,0.672-1.5,1.5v3c0,0.828,0.671,1.5,1.5,1.5s1.5-0.672,1.5-1.5v-3C19,29.672,18.329,29,17.5,29z M17.5,7    C11.71,7,7,11.71,7,17.5S11.71,28,17.5,28S28,23.29,28,17.5S23.29,7,17.5,7z M17.5,25c-4.136,0-7.5-3.364-7.5-7.5    c0-4.136,3.364-7.5,7.5-7.5c4.136,0,7.5,3.364,7.5,7.5C25,21.636,21.636,25,17.5,25z"></path></svg></label><label id="toggle-label-dark" for="darkmode-toggle" tabIndex="-1"><svg xmlns="http://www.w3.org/2000/svg" xmlnsXlink="http://www.w3.org/1999/xlink" version="1.1" id="nightIcon" x="0px" y="0px" viewBox="0 0 100 100" style="enable-background='new 0 0 100 100'" xmlSpace="preserve"><title>Dark mode</title><path d="M96.76,66.458c-0.853-0.852-2.15-1.064-3.23-0.534c-6.063,2.991-12.858,4.571-19.655,4.571  C62.022,70.495,50.88,65.88,42.5,57.5C29.043,44.043,25.658,23.536,34.076,6.47c0.532-1.08,0.318-2.379-0.534-3.23  c-0.851-0.852-2.15-1.064-3.23-0.534c-4.918,2.427-9.375,5.619-13.246,9.491c-9.447,9.447-14.65,22.008-14.65,35.369  c0,13.36,5.203,25.921,14.65,35.368s22.008,14.65,35.368,14.65c13.361,0,25.921-5.203,35.369-14.65  c3.872-3.871,7.064-8.328,9.491-13.246C97.826,68.608,97.611,67.309,96.76,66.458z"></path></svg></label></div></div><div class="center"><div class="page-header"><div class="popover-hint"><h1 class="article-title ">03. Tomasulo's Algorithm and Branch Prediction (Advanced Computer Architectures, SNU CSE)</h1><p class="content-meta ">Mar 11, 2025, 37 min read</p><ul class="tags "><li><a href="../../../../../tags/arch" class="internal tag-link">#arch</a></li><li><a href="../../../../../tags/originals" class="internal tag-link">#originals</a></li><li><a href="../../../../../tags/snu-aca25s" class="internal tag-link">#snu-aca25s</a></li></ul></div></div><article class="popover-hint"><blockquote class="callout" data-callout="info">
<div class="callout-title">
                  <div class="callout-icon"><svg xmlns="http://www.w3.org/2000/svg" width="100%" height="100%" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="10"></circle><line x1="12" y1="16" x2="12" y2="12"></line><line x1="12" y1="8" x2="12.01" y2="8"></line></svg></div>
                  <div class="callout-title-inner"><p>서울대학교 컴퓨터공학부 유승주 교수님의 &quot;고급 컴퓨터 구조&quot; 강의를 필기한 내용입니다. </p></div>
                  
                </div>
<ul>
<li><a href="../../../../../gardens/arch/originals/aca.spring.2025.cse.snu.ac.kr/(SNU-CSE)-Advanced-Computer-Architectures" class="internal" data-slug="gardens/arch/originals/aca.spring.2025.cse.snu.ac.kr/(SNU-CSE)-Advanced-Computer-Architectures">목차</a></li>
</ul>
</blockquote>
<h2 id="register-renaming">Register Renaming<a aria-hidden="true" tabindex="-1" href="#register-renaming" class="internal"> §</a></h2>
<blockquote class="callout" data-callout="info">
<div class="callout-title">
                  <div class="callout-icon"><svg xmlns="http://www.w3.org/2000/svg" width="100%" height="100%" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="10"></circle><line x1="12" y1="16" x2="12" y2="12"></line><line x1="12" y1="8" x2="12.01" y2="8"></line></svg></div>
                  <div class="callout-title-inner"><p>내용 옮겨짐 </p></div>
                  
                </div>
<ul>
<li><a href="../../../../../gardens/arch/cpu/terms/Register-Renaming-(Arch)" class="internal" data-slug="gardens/arch/cpu/terms/Register-Renaming-(Arch)">Register Renaming (Arch)</a></li>
</ul>
</blockquote>
<h2 id="tomasulos-algorithm">Tomasulo’s Algorithm<a aria-hidden="true" tabindex="-1" href="#tomasulos-algorithm" class="internal"> §</a></h2>
<ul>
<li>Tomasulo 의 특징을 간단하게 설명해 보면:
<ul>
<li><a href="../../../../../gardens/arch/cpu/drafts/Reservation-Station-(Arch)" class="internal" data-slug="gardens/arch/cpu/drafts/Reservation-Station-(Arch)">Reservation station</a> 을 통해 저런 register renaming 을 지원하고.</li>
<li>이놈을 이용해 <a href="../../../../../gardens/arch/cpu/terms/Structure-Hazard-(Arch)" class="internal" data-slug="gardens/arch/cpu/terms/Structure-Hazard-(Arch)">Structural hazard</a> 로 인한 stall 도 줄였으며</li>
<li><a href="../../../../../gardens/arch/cpu/drafts/Common-Data-Bus,-CDB-(CPU-Arch)" class="internal" data-slug="gardens/arch/cpu/drafts/Common-Data-Bus,-CDB-(CPU-Arch)">Common Data Bus</a> 로 <a href="../../../../../gardens/arch/originals/shpc.fall.2024.cse.snu.ac.kr/drafts/05/Data-Hazard-(Arch)" class="internal" data-slug="gardens/arch/originals/shpc.fall.2024.cse.snu.ac.kr/drafts/05/Data-Hazard-(Arch)">Data forward</a> 가 가능하게 했다.</li>
</ul>
</li>
</ul>
<h3 id="tomasulo-organization">Tomasulo Organization<a aria-hidden="true" tabindex="-1" href="#tomasulo-organization" class="internal"> §</a></h3>
<p><img src="../../../../../images/Pasted-image-20250427183157.png" width="auto" height="auto"/></p>
<ul>
<li>Tomasulo 에서는 대충 위와 같은 형상을 띄고 있다.
<ul>
<li>위 그림에서 <em>FP</em> 가 뭔지는 신경쓰지 말자: 아마 floating point operation 예시여서 그런듯</li>
</ul>
</li>
<li><em>Load Buffer</em>: Memory 에서 올라온 데이터 (즉, <code>LOAD</code> operation 의 결과) 들이 담기는 buffer 이다.</li>
<li><em>OP Queue</em>: 말 그대로 operation queue.</li>
<li><em>Registers</em>: Functional unit 들이 공용으로 사용하는 register 들.</li>
<li><em>Store Buffer</em>: Memory 로 내리기 전에 대기하는 (즉, <code>STORE</code> 전에 대기하는) buffer.</li>
<li><em>Reservation Station</em>: 각 연산에 대한 operation queue 이자 input value 들의 복사본 임시로 저장하고 있는 장소.
<ul>
<li>“Input value 들의 복사본” 에 집중하자. 이 말은, Reservation Station 에 추가적인 register 가 있어서 register renaming 을 하여 <a href="../../../../../gardens/arch/dependence/terms/Data-Dependence-(Arch)" class="internal" data-slug="gardens/arch/dependence/terms/Data-Dependence-(Arch)">WAR dependence</a>, <a href="../../../../../gardens/arch/dependence/terms/Data-Dependence-(Arch)" class="internal" data-slug="gardens/arch/dependence/terms/Data-Dependence-(Arch)">WAW dependence</a> 를 해결한다고 생각할 수 있다.</li>
<li>따라서 Reservation station 에 있는 이 register 를 <em>Temporary Input Register</em> (<em>TIR</em>) 이라고도 한다.</li>
</ul>
</li>
<li><em>Common Data Bus</em>: Components 들을 연결하고 있는 공용 bus.
<ul>
<li>구체적으로는, 이놈을 통해 전송되는 메세지는 64bit data + 4bit address 로 구성되어 있다.</li>
<li>저 4bit address 는 Source functional unit 에 대한 address 로, 이 메세지를 받은 다른 functional unit 이 이 메세지를 받았을 때 본인이 기다리고 있는 메세지인지 판단하게 해준다.</li>
<li>이 address 를 <em>tag</em> 라고도 부른다.</li>
</ul>
</li>
</ul>
<h3 id="reservation-station-components">Reservation Station Components<a aria-hidden="true" tabindex="-1" href="#reservation-station-components" class="internal"> §</a></h3>
<ul>
<li><em>Op</em>: Functional unit 이 실행하고 있는 operation</li>
<li><span class="math math-inline"><span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9694em;vertical-align:-0.2861em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.2222em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span></span></span></span></span>, <span class="math math-inline"><span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:-0.2222em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></span>: Operation 입력값
<ul>
<li>Operation 의 결과물은 <a href="../../../../../gardens/arch/cpu/drafts/Store-Buffer-(Arch)" class="internal" data-slug="gardens/arch/cpu/drafts/Store-Buffer-(Arch)">Store buffer</a> 의 <em>V</em> 라는 field 에 담기고, <span class="math math-inline"><span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9694em;vertical-align:-0.2861em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.2222em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span></span></span></span></span> 와 <span class="math math-inline"><span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:-0.2222em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></span> 에는 저 공간을 가리키도록 되어 있다.</li>
</ul>
</li>
<li><span class="math math-inline"><span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9694em;vertical-align:-0.2861em;"></span><span class="mord"><span class="mord mathnormal">Q</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span></span></span></span></span>, <span class="math math-inline"><span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8778em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal">Q</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></span>: <a href="../../../../../gardens/arch/cpu/drafts/Scoreboard-Architecture-(CPU-Arch)" class="internal" data-slug="gardens/arch/cpu/drafts/Scoreboard-Architecture-(CPU-Arch)">Scoreboard</a> 에서 처럼, <a href="../../../../../gardens/arch/dependence/terms/Data-Dependence-(Arch)" class="internal" data-slug="gardens/arch/dependence/terms/Data-Dependence-(Arch)">RAW dependence</a> 가 있는 경우 의존하는 functional unit 이 담기는 곳이다.
<ul>
<li>다만, Scoreboard 와는 다르게 readiness 는 따로 없다. 그냥 여기에 아무것도 적혀있지 않으면 그게 ready 라는 뜻.</li>
</ul>
</li>
<li><em>Busy</em>: Functional unit 이 사용중인가에 대한 flag</li>
<li>Register result status: <a href="../../../../../gardens/arch/cpu/drafts/Scoreboard-Architecture-(CPU-Arch)" class="internal" data-slug="gardens/arch/cpu/drafts/Scoreboard-Architecture-(CPU-Arch)">Scoreboard Architecture</a> 와 동일하다.</li>
</ul>
<h3 id="cpu-cycles">CPU cycles<a aria-hidden="true" tabindex="-1" href="#cpu-cycles" class="internal"> §</a></h3>
<ul>
<li>Tomasulo 에서는 <a href="../../../../../gardens/arch/cpu/drafts/Scoreboard-Architecture-(CPU-Arch)" class="internal" data-slug="gardens/arch/cpu/drafts/Scoreboard-Architecture-(CPU-Arch)">Scoreboard</a> 와 다르게 3-stage 로 처리한다.</li>
<li><em>Issue</em>: 이때에는 Instruction 을 Reservation Station 에 등록하고 Register result status 을 갱신한다.
<ul>
<li>즉, dependence 를 확인해 <span class="math math-inline"><span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9694em;vertical-align:-0.2861em;"></span><span class="mord"><span class="mord mathnormal">Q</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span></span></span></span></span>, <span class="math math-inline"><span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8778em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal">Q</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></span> 를 채우고 필요한 값들을 <span class="math math-inline"><span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9694em;vertical-align:-0.2861em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.2222em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span></span></span></span></span>, <span class="math math-inline"><span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:-0.2222em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></span> 에 복사해둔다는 의미이다.</li>
</ul>
</li>
<li><em>Execute</em>: 실재로 instruction 을 실행하는데, 만약에 Reservation Station 에 필요한 데이터가 다 있으면 바로 실행하고 만약에 그렇지 않으면 Common Data Bus 를 Polling 하며 필요한 데이터가 전송될때 까지 stall 한다.</li>
<li><em>Write result</em>: 실행을 종료한다. 여기서는 Common Data Bus 에 결과를 broadcast 하고 본인의 Reservation Station 을 free 한다.</li>
</ul>
<h3 id="example-1">Example 1<a aria-hidden="true" tabindex="-1" href="#example-1" class="internal"> §</a></h3>
<p><img src="../../../../../images/Pasted-image-20250427183938.png" width="auto" height="auto"/></p>
<ul>
<li><a href="../../../../../gardens/arch/cpu/drafts/Scoreboard-Architecture-(CPU-Arch)" class="internal" data-slug="gardens/arch/cpu/drafts/Scoreboard-Architecture-(CPU-Arch)">Scoreboard</a> 에서와 마찬가지로, 위와 같은 구조에서 instruction 들을 처리하는 과정에 대해 알아보자.</li>
</ul>
<h4 id="cycle-1">Cycle 1<a aria-hidden="true" tabindex="-1" href="#cycle-1" class="internal"> §</a></h4>
<p><img src="../../../../../images/Pasted-image-20250427184100.png" width="auto" height="auto"/></p>
<ul>
<li>일단 첫번째 <code>LOAD</code> 가 issue 된다. 이에 따라 오른쪽 위의 load buffer 에는 Load1 이 busy 가 되고, 그에 따른 address 가 적힌다.</li>
<li>그리고 output register 가 <code>F6</code> 이기 떄문에 Scoreboard 에서 처럼 register result status 의 <code>F6</code> 에 Load1 이 적힌다.</li>
</ul>
<h4 id="cycle-2">Cycle 2<a aria-hidden="true" tabindex="-1" href="#cycle-2" class="internal"> §</a></h4>
<p><img src="../../../../../images/Pasted-image-20250427184257.png" width="auto" height="auto"/></p>
<ul>
<li>이번에는 두번째 <code>LOAD</code> 가 issue 되고, <a href="#cycle-1" class="internal">Cycle 1</a> 와 마찬가지로 처리된다.
<ul>
<li>보다시피 Scoreboard 에서와 다르게, 이때에는 load buffer 덕분에 여러개의 <code>LOAD</code> 가 issue 될 수 있다.</li>
</ul>
</li>
<li>근데 이 예제에서 왜 첫번째 <code>LOAD</code> 가 exec comp 되지 않는지는 모르겠다; 아마 <code>LOAD</code> 에 2 cycle 이 걸린다는 설정인듯 하다.</li>
</ul>
<h4 id="cycle-3">Cycle 3<a aria-hidden="true" tabindex="-1" href="#cycle-3" class="internal"> §</a></h4>
<p><img src="../../../../../images/Pasted-image-20250427184601.png" width="auto" height="auto"/></p>
<ul>
<li>Cycle 3 에서는 첫번째 <code>LOAD</code> 의 EX 가 완료되고, <code>MULTD</code> 가 issue 된다.</li>
<li>이때의 Reservation Station 을 보면
<ul>
<li>일단 <em>Busy</em> 와 <em>Op</em> 가 채워지고</li>
<li>두번째 <code>LOAD</code> 가 종료되어야 <code>F2</code> 에 접근할 수 있기 때문에 (<a href="../../../../../gardens/arch/dependence/terms/Data-Dependence-(Arch)" class="internal" data-slug="gardens/arch/dependence/terms/Data-Dependence-(Arch)">RAW dependence</a>) <span class="math math-inline"><span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9694em;vertical-align:-0.2861em;"></span><span class="mord"><span class="mord mathnormal">Q</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span></span></span></span></span> 에 Load2 가 적힌다.</li>
<li>그리고 두번째 피연산자인 <code>F4</code> 는 <code>F4</code> 가 그대로 적히는 것이 아니라 <code>F4</code> 의 값이 Reservation Station 에 적힌다.
<ul>
<li>이렇게 한다는 것은 <code>F4</code> register 를 사용하는 것이 아니고 Reservation Station 의 <span class="math math-inline"><span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:-0.2222em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></span> 를 사용하는 것이므로 자동으로 register renaming 이 되는 것이다.</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="cycle-4">Cycle 4<a aria-hidden="true" tabindex="-1" href="#cycle-4" class="internal"> §</a></h4>
<p><img src="../../../../../images/Pasted-image-20250427185934.png" width="auto" height="auto"/></p>
<ul>
<li>우선 첫번째 <code>LOAD</code> 는 write result 까지 끝마치며 종료된다. 이에 따라 load buffer 의 Load1 이 비워진다.</li>
<li>그리고 두번째 <code>LOAD</code> 의 EX 이 끝난다.</li>
<li><code>MULTD</code> 는 아직 EX 를 시작할 수 없다: 왜냐면 Load2 가 이제서야 끝났기 때문에 아직까지는 <a href="../../../../../gardens/arch/dependence/terms/Data-Dependence-(Arch)" class="internal" data-slug="gardens/arch/dependence/terms/Data-Dependence-(Arch)">RAW dependence</a> 가 해소되지 않았기 때문.</li>
<li>마지막으로 <code>SUBD</code> 가 issue 된다. 이때 눈여겨볼 것은 이때의 Reservation Station 의 상태이다.
<ul>
<li>일단 두번째 피연산자인 <code>F2</code> 는 두번째 <code>LOAD</code> 에 의존하고 있으므로 (RAW) <span class="math math-inline"><span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8778em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal">Q</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></span> 에 Load2 가 명시된다.</li>
<li>첫번째 피연산자인 <code>F6</code> 은 첫번째 <code>LOAD</code> 에 의존하고 있는데, 첫번째 <code>LOAD</code> 는 cycle 3 에서 EX 가 끝났기 때문에 이 결과를 Common Data Bus 를 이용해 받아서 Reservation Station 에 복사한다.
<ul>
<li>이 것이 위 그림에서 <code>M(A1)</code> 이고, 이에 따라 Register result status 에도 바뀐 것을 볼 수 있다.</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="cycle-5">Cycle 5<a aria-hidden="true" tabindex="-1" href="#cycle-5" class="internal"> §</a></h4>
<p><img src="../../../../../images/Pasted-image-20250427191036.png" width="auto" height="auto"/></p>
<ul>
<li>Cycle 5 에서는 우선 두번째 <code>LOAD</code> 가 종료되며 Load Buffer 에서 Load2 가 비워진다.</li>
<li>그리고 <code>SUBD</code> 와 <code>MULTD</code> 에 대한 EX 가 시작된다.
<ul>
<li>왜냐면 이 둘은 두번째 <code>LOAD</code> 에 대한 <a href="../../../../../gardens/arch/dependence/terms/Data-Dependence-(Arch)" class="internal" data-slug="gardens/arch/dependence/terms/Data-Dependence-(Arch)">RAW dependence</a> 가 있어서 stall 중이었는데, cycle 5 에서 write result 과정에서 Common Data Bus 로 메세지를 보내 그 즉시 Add1 와 Mult1 이 시작되는 것.</li>
<li>그래서 위의 그림에서도 cycle 4 에서와 유사하게 두번째 <code>LOAD</code> 의 값이 <code>M(A2)</code> 로써 Reservation Station 에 등록되게 되는 것이다.</li>
<li><a href="../../../../../gardens/arch/cpu/drafts/Scoreboard-Architecture-(CPU-Arch)" class="internal" data-slug="gardens/arch/cpu/drafts/Scoreboard-Architecture-(CPU-Arch)">Scoreboard</a> 에서의 예시와 마찬가지로, EX 가 시작되었으므로 그에 대한 남아있는 cycle 수가 Reservation Station 에 적혀있는 것 또한 확인할 수 있다.</li>
</ul>
</li>
<li>또한 <code>DIVD</code> 가 issue 된다.
<ul>
<li>여기서는 <code>F6</code> 은 <code>M(A1)</code> 으로써 Reservation Station 의 <span class="math math-inline"><span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:-0.2222em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></span> 에 복사되고, <code>F0</code> 는 Mult1 에 RAW 가 걸려있기 때문에 <span class="math math-inline"><span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9694em;vertical-align:-0.2861em;"></span><span class="mord"><span class="mord mathnormal">Q</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span></span></span></span></span> 에 Mult1 이 등록된다.</li>
</ul>
</li>
</ul>
<h4 id="cycle-6">Cycle 6<a aria-hidden="true" tabindex="-1" href="#cycle-6" class="internal"> §</a></h4>
<p><img src="../../../../../images/Pasted-image-20250427191847.png" width="auto" height="auto"/></p>
<ul>
<li>Cycle 6 에서는 <code>ADDD</code> 가 issue 된다.
<ul>
<li>우선 피연산자 <code>F8</code> 은 Add1(<code>SUBD</code>) 에 의존하고 있으므로 (<a href="../../../../../gardens/arch/dependence/terms/Data-Dependence-(Arch)" class="internal" data-slug="gardens/arch/dependence/terms/Data-Dependence-(Arch)">RAW dependence</a>) <span class="math math-inline"><span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9694em;vertical-align:-0.2861em;"></span><span class="mord"><span class="mord mathnormal">Q</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span></span></span></span></span> 에 Add1 가 등록뢰고, <code>F2</code> 는 이미 종료된 두번째 <code>LOAD</code> 의 값이므로 <code>M(A2)</code> 가 들어간다.</li>
</ul>
</li>
<li>근데 여기서 눈여겨볼 것은 Register result status 이다.
<ul>
<li>Cycle 5 까지는 <code>F6</code> 에 <code>M(A1)</code> 이 적혀있었는데, <code>ADDD</code> 가 issue 되면서 Add2 의 결과가 <code>F6</code> 에 적힐 것이므로 Add2 가 등록된다.</li>
<li>하지만 Reservation Station 에서는 Add1 와 Mult2 에 대해 여전히 <code>M(A1)</code> 이 복사된 채로 남아있다. 이 말은 Add2 가 종료되어 F6 에 값을 overwrite 할지라도 Add1 와 Mult2 는 여전히 이전 값을 사용할 수 있다는 말이다.</li>
<li>따라서, 이 Reservation Station 에 값을 복사해 둠으로써 register renaming 을 하여 <a href="../../../../../gardens/arch/dependence/terms/Data-Dependence-(Arch)" class="internal" data-slug="gardens/arch/dependence/terms/Data-Dependence-(Arch)">WAR dependence</a> 가 해소되게 되는 것이다.</li>
</ul>
</li>
</ul>
<h4 id="cycle-7-8">Cycle 7, 8<a aria-hidden="true" tabindex="-1" href="#cycle-7-8" class="internal"> §</a></h4>
<p><img src="../../../../../images/Pasted-image-20250427194414.png" width="auto" height="auto"/></p>
<ul>
<li>Cycle 7 에서는 <code>ADDD</code> 는 Mult1 에 의존하고 있기 때문에 (<span class="math math-inline"><span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9694em;vertical-align:-0.2861em;"></span><span class="mord"><span class="mord mathnormal">Q</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span></span></span></span></span>) 시작되지 않고,</li>
<li>Add1 (<code>SUBD</code>) 의 EX 가 끝난다.</li>
</ul>
<p><img src="../../../../../images/Pasted-image-20250427194427.png" width="auto" height="auto"/></p>
<ul>
<li>Cycle 8 에서는 Add1 은 write result 까지 실행되며 종료된다.</li>
<li>또한 write result 과정에서 Add1 의 결과가 Common Data Bus 를 타고 이놈에 의존하고 있던 functional unit 에게 전달된다.
<ul>
<li>이 결과를 기다리고 있던 놈은 Add2 이기 때문에, 바로 이놈의 <span class="math math-inline"><span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9694em;vertical-align:-0.2861em;"></span><span class="mord"><span class="mord mathnormal">Q</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span></span></span></span></span> 가 비워지고 <span class="math math-inline"><span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9694em;vertical-align:-0.2861em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.2222em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span></span></span></span></span> 에 값이 채워진다.</li>
<li>이것은 위 그림에서 <code>M(A1) - M(A2)</code> 라는 의미에서 <code>(M - M)</code> 으로 표시되어 있고, register result status 에서도 그에 맞게 표시되어 있다.</li>
</ul>
</li>
<li>이에 따라 Add2 의 EX 가 바로 시작되고, 이놈의 time 에 2cycle 이 남아있음이 보여지고 있다.</li>
</ul>
<h4 id="cycle-10-11-skip-cycle-9">Cycle 10, 11 (Skip cycle 9)<a aria-hidden="true" tabindex="-1" href="#cycle-10-11-skip-cycle-9" class="internal"> §</a></h4>
<p><img src="../../../../../images/Pasted-image-20250427195847.png" width="auto" height="auto"/></p>
<ul>
<li>Cycle 9 는 아무것도 안하기 때문에 생략하고, Cycle 10 에서는 Add2 의 EX 가 종료된다.</li>
</ul>
<p><img src="../../../../../images/Pasted-image-20250427200143.png" width="auto" height="auto"/></p>
<ul>
<li>Cycle 11 에서 Add2(<code>ADDD</code>) 는 write result 까지 끝나며 종료된다.</li>
<li>그리고 그와 동시에 Add2 의 결과가 Common Data Bus 를 통해 전파되어 보면 Add2 의 결과였던 F6 가 <code>(M - M + M)</code> 로 바뀌어 있음을 알 수 있다.
<ul>
<li>이것은 Add2 이 <code>(M - M)</code> 에 <code>M(A2)</code> 를 더하는 연산이었기 때문에, <code>(M - M + M)</code> 으로 표시해놓은 것.</li>
<li>물론 이놈에 의존하고 있는 애는 없기 때문에 이번에는 Reservation Station 에 등록되지 않는다.</li>
</ul>
</li>
</ul>
<h4 id="cycle-15-16-skip-cycle-12--14">Cycle 15, 16 (Skip cycle 12 ~ 14)<a aria-hidden="true" tabindex="-1" href="#cycle-15-16-skip-cycle-12--14" class="internal"> §</a></h4>
<p><img src="../../../../../images/Pasted-image-20250427200850.png" width="auto" height="auto"/></p>
<ul>
<li>이때도 마찬가지다; 12 ~ 14 cycle 은 아무것도 안되고 생략하고, cycle 15 에서 Mult1 의 EX 가 끝난다.</li>
</ul>
<p><img src="../../../../../images/Pasted-image-20250427200837.png" width="auto" height="auto"/></p>
<ul>
<li>그래서 다음 cycle (16) 에서는 Mult1 가 write result 까지 끝내며 종료되고, 이놈의 결과가 Common Data Bus 로 전파되어 Reservation Station 에 복사돼 Mult2 의 <span class="math math-inline"><span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9694em;vertical-align:-0.2861em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.2222em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span></span></span></span></span> 가 <code>M * F4</code> 로 바뀐다.
<ul>
<li>그리고 register result status 의 <code>F0</code> 또한 Mult1 의 결과 <code>M * F4</code> 로 바뀐다.</li>
</ul>
</li>
</ul>
<h4 id="cycle-57-skip-cycle-17--56">Cycle 57 (Skip cycle 17 ~ 56)<a aria-hidden="true" tabindex="-1" href="#cycle-57-skip-cycle-17--56" class="internal"> §</a></h4>
<p><img src="../../../../../images/Pasted-image-20250427201459.png" width="auto" height="auto"/></p>
<ul>
<li>뭐 이러저러 해서 cycle 57 에 모든 instruction 이 다 끝나게 된다.</li>
</ul>
<h3 id="tomasulo-vs-scoreboard">Tomasulo vs Scoreboard<a aria-hidden="true" tabindex="-1" href="#tomasulo-vs-scoreboard" class="internal"> §</a></h3>
<p><img src="../../../../../images/Pasted-image-20250427201741.png" width="auto" height="auto"/></p>
<ul>
<li>그럼 이제 Tomasulo 와 Scoreboard 를 비교해 보자. 위에서 왼쪽이 Scoreboard 이고, 오른쪽이 Tomasulo 이다.</li>
<li>보면 Tomasulo 가 좀 더 일찍 끝나는 것을 알 수 있는데, 이건 Tomasulo 의 다음과 같은 특징이 작용했기 때문이다:
<ul>
<li>일단 Tomasulo example 에서는 좀 더 functional unit 이 더 많았고,</li>
<li>Reservation station 으로 인해 사용할 수 있는 register 도 더 많았으며 (그래서 register renaming 도 가능했으며)</li>
<li>Common Data Bus 를 이용해 data forwarding 도 가능했기 때문이다.</li>
</ul>
</li>
<li>그래서 이 둘의 특징을 비교해 보면 다음과 같이 정리할 수 있다.</li>
</ul>
<p><img src="../../../../../images/Pasted-image-20250427202051.png" width="auto" height="auto"/></p>
<ul>
<li>보면, Tomasulo 에서는
<ul>
<li>Reservation station 을 이용해 <a href="../../../../../gardens/arch/cpu/terms/Structure-Hazard-(Arch)" class="internal" data-slug="gardens/arch/cpu/terms/Structure-Hazard-(Arch)">Structural hazard</a> 로 인한 issue stall 을 줄일 수 있었고,</li>
<li>여기에의 register 들을 이용해 <a href="../../../../../gardens/arch/dependence/terms/Data-Dependence-(Arch)" class="internal" data-slug="gardens/arch/dependence/terms/Data-Dependence-(Arch)">WAR dependence</a> 및 <a href="../../../../../gardens/arch/dependence/terms/Data-Dependence-(Arch)" class="internal" data-slug="gardens/arch/dependence/terms/Data-Dependence-(Arch)">WAW dependence</a> 로 인한 stall 도 해결했으며
<ul>
<li>구체적으로는 Reservation Station 의 TIR 로 WAR 이 해소되고 renaming 으로 WAW 이 해소된다.</li>
<li>WAW 에 대해서는 뒤의 <a href="#example-2" class="internal">Example 2</a> 에서 예시가 나오니 뒤에서 확인하자.</li>
</ul>
</li>
<li>Common Data Bus 로 functional unit 의 결과를 broadcast 해서 1 cycle 먼저 EX 가 가능하게 만들었고</li>
<li>Scoreboard 에서의 central 한 접근이 아닌 functional unit 마다의 reservation station 으로 decentral 한 접근을 했다고 할 수 있다.
<ul>
<li>즉, <a href="../../../../../gardens/arch/dependence/terms/Data-Dependence-(Arch)" class="internal" data-slug="gardens/arch/dependence/terms/Data-Dependence-(Arch)">RAW dependence</a> detection 을 각 Reservation Station 으로 분배한 것.</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="example-2">Example 2<a aria-hidden="true" tabindex="-1" href="#example-2" class="internal"> §</a></h3>
<p><img src="../../../../../images/Pasted-image-20250427205544.png" width="auto" height="auto"/></p>
<ul>
<li>이번에는 Tomasulo algorithm 에서, loop 에 대한 예시를 보고 가자.
<ul>
<li>왼쪽 위의 instruction list 는 loop 을 돌며 실행하게 되는 instruction 을 unroll 해서 보여준 것이고</li>
<li>오른쪽 아래의 instrcution list 는 loop 가 있는 원본의 code 이다.</li>
<li>그리고 왼쪽 아래에 R1 register 의 값이 나와있다.</li>
</ul>
</li>
</ul>
<h4 id="cycle-1-1">Cycle 1<a aria-hidden="true" tabindex="-1" href="#cycle-1-1" class="internal"> §</a></h4>
<p><img src="../../../../../images/Pasted-image-20250427211417.png" width="auto" height="auto"/></p>
<ul>
<li>Cycle 1 에서는 첫번째 <code>LOAD</code> 가 issue 되고, 이에 따라 load buffer 에 80 (<code>R1</code>) 에 대한 load 가 Load1 로 등록된다.</li>
<li>이 예제에서는 이 첫번째 <code>LOAD</code> 가 cache miss 가 나서 8 cycle 이 걸린다고 가정한다. 즉, 이 <code>LOAD</code> 는 cycle 9 나 되어서나 종료될 것이다.</li>
</ul>
<h4 id="cycle-2-1">Cycle 2<a aria-hidden="true" tabindex="-1" href="#cycle-2-1" class="internal"> §</a></h4>
<p><img src="../../../../../images/Pasted-image-20250427212143.png" width="auto" height="auto"/></p>
<ul>
<li>그리고 첫번째 <code>MULTD</code> 가 issue 된다.
<ul>
<li><span class="math math-inline"><span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:-0.2222em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></span> 에는 F2 의 값이 복사되고 (<code>R(F2)</code>),</li>
<li><code>F0</code> 는 Load1 에 의존하기 때문에 <span class="math math-inline"><span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8778em;vertical-align:-0.1944em;"></span><span class="mord"><span class="mord mathnormal">Q</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3361em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.03148em;">k</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></span> 에는 Load1 가 들어간다.</li>
</ul>
</li>
</ul>
<h4 id="cycle-3-1">Cycle 3<a aria-hidden="true" tabindex="-1" href="#cycle-3-1" class="internal"> §</a></h4>
<p><img src="../../../../../images/Pasted-image-20250427212339.png" width="auto" height="auto"/></p>
<ul>
<li>그리고 첫번째 <code>STORE</code> 이 issue 된다.
<ul>
<li>Store buffer 에는 addr 80 (<code>R1</code>) 에 대한 요청이 등록되고, Store 할 값은 Mult1 의 결과라는 것이 명시된다.</li>
</ul>
</li>
<li>여기서 저 화살표를 좀 살펴볼 필요가 있다.
<ul>
<li>이것이 Tomasulo 에서 이런식으로 aliasing 이 되어 register renaming 이 된다는 것을 나타내는 화살표로,</li>
<li>Mult1 은 Load1 에 의존하고 있고 Load1 이 끝나자 마자 이 값이 전파되어 Mult1 에서 사용된다는 것과</li>
<li>Store1 은 Mult1 에 의존하고 있고 Mult1 이 끝나자 마자 이 값이 전파되어 Store1 에서 사용된다는 의미이다.</li>
</ul>
</li>
<li>당연히 첫번째 <code>MULTD</code> 는 EX 되지 않는다; Load1 을 기다리고 있으므로</li>
</ul>
<h4 id="cycle-4-5">Cycle 4, 5<a aria-hidden="true" tabindex="-1" href="#cycle-4-5" class="internal"> §</a></h4>
<ul>
<li>Cycle 4 와 5 에서는 loop 을 계속 진행하는 것과 관련된 것이어서 이부분은 빠르게 넘어가자.</li>
</ul>
<p><img src="../../../../../images/Pasted-image-20250427212716.png" width="auto" height="auto"/></p>
<ul>
<li>Cycle 4 에서는 <code>R1</code> 에서 8을 빼고
<ul>
<li>그래서 아래 그림의 cycle 5 에서 <code>R1</code> 이 72 로 감소한 것을 볼 수 있다.</li>
</ul>
</li>
</ul>
<p><img src="../../../../../images/Pasted-image-20250427212729.png" width="auto" height="auto"/></p>
<ul>
<li>Cycle 5 에서는 <code>BNEZ</code> 를 통해 다시 loop 이 반복되도록 한다.
<ul>
<li>즉, 이에 따라 왼쪽 위의 instruction list 에서 iteration 이 1 에서 2로 넘어가게 된다.</li>
</ul>
</li>
</ul>
<h4 id="cycle-6-1">Cycle 6<a aria-hidden="true" tabindex="-1" href="#cycle-6-1" class="internal"> §</a></h4>
<p><img src="../../../../../images/Pasted-image-20250427213109.png" width="auto" height="auto"/></p>
<ul>
<li>Cycle 6 에서는 loop 한바퀴를 돌아 두번째 <code>LOAD</code> 가 issue 된다.
<ul>
<li>이에 따라 load buffer 의 Load2 가 채워지게 된다.</li>
</ul>
</li>
<li>여기서 주목할 점은 register result status 이다.
<ul>
<li>보면 <code>F0</code> 이 Load1 에서 Load2 로 변경되어 있는데, 이에 따라 이 예제에서는 Load1 이 메모리에서 가져온 값이 절대로 <code>F0</code> 에 저장되지 않는다는 것을 알 수 있다.</li>
<li>어찌보면 Load1 의 값이 덮어씌워져 Mult1 에서 문제가 생기는 것은 아닌가 생각할 수 있다.
<ul>
<li>즉, <a href="../../../../../gardens/arch/dependence/terms/Data-Dependence-(Arch)" class="internal" data-slug="gardens/arch/dependence/terms/Data-Dependence-(Arch)">WAR dependence</a> 가 있는 거 아닌가? 라는 의심이 들 수 있다.</li>
<li>하지만 그렇지 않다; 왜냐면 Load1 의 결과가 <code>F0</code> 에 저장되었다가 Mult1 로 가는 것이 아니고 Load1 이 끝나자마자 Common Data Bus 를 통해 Load1 으로 전달되기 때문이다.</li>
<li>즉, 이것은 computation 과 register 가 분리되어 있다고 볼 수 있고, 그에 따라 <a href="../../../../../gardens/arch/dependence/terms/Data-Dependence-(Arch)" class="internal" data-slug="gardens/arch/dependence/terms/Data-Dependence-(Arch)">WAR dependence</a> 이나 <a href="../../../../../gardens/arch/dependence/terms/Data-Dependence-(Arch)" class="internal" data-slug="gardens/arch/dependence/terms/Data-Dependence-(Arch)">WAW dependence</a> 가 해소될 수 있는 것이다.</li>
</ul>
</li>
</ul>
</li>
</ul>
<h4 id="cycle-7">Cycle 7<a aria-hidden="true" tabindex="-1" href="#cycle-7" class="internal"> §</a></h4>
<p><img src="../../../../../images/Pasted-image-20250427214307.png" width="auto" height="auto"/></p>
<ul>
<li>Cycle 7 에서는 두번째 <code>MULTD</code> 가 issue 된다.
<ul>
<li>따라서 reservation station 의 Mult2 에 <code>F2</code> 가 복사되고 (<code>R(F2)</code>),</li>
<li>나머지 피연산자인 <code>F0</code> 은 Load2 에서부터 직접 받으므로 <span class="math math-inline"><span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9694em;vertical-align:-0.2861em;"></span><span class="mord"><span class="mord mathnormal">Q</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span></span></span></span></span> 가 Load2 로 설정된다.</li>
</ul>
</li>
</ul>
<h4 id="cycle-8">Cycle 8<a aria-hidden="true" tabindex="-1" href="#cycle-8" class="internal"> §</a></h4>
<p><img src="../../../../../images/Pasted-image-20250427214629.png" width="auto" height="auto"/></p>
<ul>
<li>Cycle 8 에서는 두번째 <code>STORE</code> 이 issue 된다.
<ul>
<li>따라서 store buffer 의 Store2 에 이놈이 등록되고,</li>
<li>피연산자는 Mult2 로부터 Common Data Bus 를 이용해 바로 받도록 한다.</li>
</ul>
</li>
<li>보면 (노란색으로 칠해놓은 <code>SD</code> 를 무시하면) 첫번째 <code>MULTD</code> 와 두번째 <code>MULTD</code> 는 <a href="../../../../../gardens/arch/dependence/terms/Data-Dependence-(Arch)" class="internal" data-slug="gardens/arch/dependence/terms/Data-Dependence-(Arch)">WAW dependence</a> 관계에 있다.
<ul>
<li>원래 <a href="../../../../../gardens/arch/cpu/drafts/Scoreboard-Architecture-(CPU-Arch)" class="internal" data-slug="gardens/arch/cpu/drafts/Scoreboard-Architecture-(CPU-Arch)">Scoreboard</a> 의 경우였다면, 이때에는 issue 조차 되지 않았겠지만</li>
<li>Tomasulo 의 경우에는 애초에 Mult1 이 <code>F4</code> 에 저장되지 않기 때문에 아무런 문제가 생기지 않는다.</li>
</ul>
</li>
</ul>
<h4 id="cycle-9">Cycle 9<a aria-hidden="true" tabindex="-1" href="#cycle-9" class="internal"> §</a></h4>
<p><img src="../../../../../images/Pasted-image-20250427214657.png" width="auto" height="auto"/></p>
<ul>
<li>Cycle 9 에서는 드디어 첫번째 <code>LOAD</code> 의 EX 가 끝난다.
<ul>
<li>근데 원래대로라면 <code>F0</code> 에 <code>LOAD</code> 가 되었어야 했겠지만, 두번째 <code>LOAD</code> 가 <code>F0</code> 을 점유하고 있기 때문에 여기에는 데이터가 올라가지 않는다.</li>
<li>대신 Cycle 10 에서 write result 할 때 Common Data Bus 를 타고 바로 Mult1 의 <span class="math math-inline"><span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9694em;vertical-align:-0.2861em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.2222em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span></span></span></span></span> 에 꽂히게 된다.</li>
</ul>
</li>
<li>뭐 여기서 <code>SUBI</code> 가 실행되어서 Cycle 10 에서 <code>R1</code> 이 줄어들긴 하는데 위에서 말한 대로 이건 loop 을 위한 것이므로 자세한 설명은 생략</li>
</ul>
<h4 id="cycle-10">Cycle 10<a aria-hidden="true" tabindex="-1" href="#cycle-10" class="internal"> §</a></h4>
<p><img src="../../../../../images/Pasted-image-20250427222025.png" width="auto" height="auto"/></p>
<ul>
<li>그래서 위에서 말한 대로 cycle 10 에서는 Mult1 의 <span class="math math-inline"><span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9694em;vertical-align:-0.2861em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.2222em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span></span></span></span></span> 에 바로 첫번째 <code>LOAD</code> 의 값이 올라오며 바로 Mult1 에 대한 EX 가 시작된다.
<ul>
<li>그래서 Reservation Station 에도 time 이 표시되고 있는 것을 볼 수 있다.</li>
</ul>
</li>
<li>그리고 cycle 10 에서는 드디어 두번째 <code>LOAD</code> 의 EX 가 끝난다.</li>
</ul>
<h4 id="cycle-11">Cycle 11<a aria-hidden="true" tabindex="-1" href="#cycle-11" class="internal"> §</a></h4>
<p><img src="../../../../../images/Pasted-image-20250427222348.png" width="auto" height="auto"/></p>
<ul>
<li>그래서 cycle 11 에서는 Load2 가 write result 를 할 때 Common Data Bus 를 통해 Mult2 의 <span class="math math-inline"><span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9694em;vertical-align:-0.2861em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.22222em;">V</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.2222em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span></span></span></span></span> 에 값을 전달하고, 따라서 바로 Mult2 의 EX 가 시작된다.</li>
<li>또한 세번째 loop 이 시작되며 64 (Cycle 9 에서 <code>SUBI</code> 를 통해 변경된 <code>R1</code> 값) addr 에 대한 <code>LOAD</code> 가 load buffer 의 Load3 에 올라간다.</li>
</ul>
<h4 id="cycle-12">Cycle 12<a aria-hidden="true" tabindex="-1" href="#cycle-12" class="internal"> §</a></h4>
<p><img src="../../../../../images/Pasted-image-20250427222406.png" width="auto" height="auto"/></p>
<ul>
<li>Cycle 12 에서는 다음 <code>MULTD</code> 를 issue 해야 되는데, 여기서 첫번째 stall 이 발생한다.
<ul>
<li>왜냐면 더 이상 reservation station 에 자리가 없기 때문.</li>
<li>그래서 Mult1 이 끝날때까지 stall 이 발생한다.</li>
</ul>
</li>
</ul>
<h4 id="cycle-14-15-skip-cycle-13">Cycle 14, 15 (Skip cycle 13)<a aria-hidden="true" tabindex="-1" href="#cycle-14-15-skip-cycle-13" class="internal"> §</a></h4>
<p><img src="../../../../../images/Pasted-image-20250427223603.png" width="auto" height="auto"/></p>
<ul>
<li>Cycle 13 은 그냥 stall 되어 있는 거여서 생략하고, cycle 14 에서는 드디어 첫번째 <code>MULTD</code> 의 EX 가 종료된다.</li>
</ul>
<p><img src="../../../../../images/Pasted-image-20250427223622.png" width="auto" height="auto"/></p>
<ul>
<li>그리고 cycle 15 에서는 첫번째 <code>MULTD</code> 에 대해 write result 까지 하며 완료되고, 이 값은 Store1 에게 전파된다.
<ul>
<li>그래서 store buffer 의 Store1 내용이 Mult1 에서 <code>[80] * R2</code> 로 변경된다.</li>
</ul>
</li>
<li>또한 두번째 <code>MULTD</code> 에 대한 EX 도 완료된다.</li>
</ul>
<h4 id="cycle-16">Cycle 16<a aria-hidden="true" tabindex="-1" href="#cycle-16" class="internal"> §</a></h4>
<p><img src="../../../../../images/Pasted-image-20250427223642.png" width="auto" height="auto"/></p>
<ul>
<li>Cycle 16 에서는 이제 reservation station 에 자리가 나기 때문에 세번째 <code>MULTD</code> 가 issue 된다.</li>
<li>그리고 두번째 <code>MULTD</code> 가 write result 까지 하며 종료되며 이에 따라 그 결과가 Common Data Bus 를 통해 Store2 에 전달된다.
<ul>
<li>그래서 마찬가지로 store buffer 의 Store2 내용이 Mult2 에서 <code>[72] * R2</code> 로 변경된다.</li>
</ul>
</li>
</ul>
<h3 id="tomasulo-limitations">Tomasulo Limitations<a aria-hidden="true" tabindex="-1" href="#tomasulo-limitations" class="internal"> §</a></h3>
<ul>
<li>여기까지 보면 Tomasulo 에서는 Common Data Bus 가 엄청 중요하다는 것을 알 수 있다.</li>
<li>즉, Tomasulo 에서는 이 CDB 에 contention 이 걸리게 된다.
<ul>
<li>CDB broadcasting 이 빈번하게 발생하며 대역폭을 많이 사용하게 돼 bottleneck 이 되며, CDB 가 비싸기에 CDB 를 여러개 두는 것도 어렵다.</li>
<li>또한 tag comparison 이 필요하기에 구현 복잡도도 올라간다.</li>
</ul>
</li>
</ul>
<h2 id="explicit-register-renaming">Explicit Register Renaming<a aria-hidden="true" tabindex="-1" href="#explicit-register-renaming" class="internal"> §</a></h2>
<ul>
<li>위의 Tomasulo 는 CDS 로 데이터를 직접 전달해주는 방식이기 때문에, 암묵적으로 register renaming 을 한다고 할 수 있다 (<em>Implicit Register Renaming</em>).</li>
<li>이러한 방식 말고 <em>Explicit Register Renaming</em> 을 할 수도 있다.
<ul>
<li>즉, indirection principle 을 차용해 logical register 와 physical register 를 나누고, logical register 의 개수의 배수가 되는 더 많은 physical register 를 구비한 뒤, 이 둘의 mapping table 을 관리하는 것이다.</li>
</ul>
</li>
<li>그래서 CPU 에서는 register 를 더 많이 갖고 있다.
<ul>
<li>즉, compilier 에서는 4개를 갖고있다고 생각하더라도 CPU 에서는 이것의 배수의 register 를 구비해 놓는다.</li>
<li>그리고 한번 write 가 되면, 다른 physical register 가 사용된다.</li>
<li>예를 들어 logical register 가 4개 있고 logical register <span class="math math-inline"><span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0077em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></span> 에는 처음에 physical register <span class="math math-inline"><span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></span> 이 붙어있다가</li>
<li>여기에 한번 write 가 되면 그 다음부터는 <span class="math math-inline"><span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">5</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></span> 가 사용된다는 것</li>
<li>근데 WB 은 instruction 실행할 때 항상 사용되니까 issue 할 때마다 이 mapping 이 바뀌게 된다.</li>
</ul>
</li>
<li>이러한 logical register 들을 ”<em>name</em>” 이라고 부르고 physical register 들을 ”<em>location</em>” 이라고 부른다.</li>
<li>또한 logical register 의 개수는 ISA 에 명시된 register 의 개수와 같다. 즉, 이런식으로 compiler 에게 abstraction 을 제공하는 것.</li>
</ul>
<h3 id="mapping-table-example">Mapping Table Example<a aria-hidden="true" tabindex="-1" href="#mapping-table-example" class="internal"> §</a></h3>
<p><img src="../../../../../images/Pasted-image-20250427230347.png" width="auto" height="auto"/></p>
<ul>
<li>Mapping table 이 logical register 와 physical register 간에 구분이 잘 안돼있어서 좀 보기 힘들긴 한데, 위 그림에서 가운데 table 은 logical register <span class="math math-inline"><span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1757em;"><span style="top:-2.55em;margin-left:-0.0077em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">∗</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></span> 에 대한 physical register <span class="math math-inline"><span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.1757em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mbin mtight">∗</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></span> 의 mapping 이 시간순대로 (아래로 내려갈수록 시간이 흐른 것) 보여준 것이다.</li>
<li>그래서 왼쪽의 logical register code 와 오른쪽의 physical register code 를 비교하면서 보면 된다.
<ul>
<li>처음 <code>ADD</code> 를 실행하면 <span class="math math-inline"><span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0077em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></span> 에 write 이 되면서 mapping 이 <span class="math math-inline"><span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">1</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></span> 에서 <span class="math math-inline"><span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">5</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></span> 로 바뀐다. 그래서 오른쪽에서는 <span class="math math-inline"><span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">5</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></span> 로 되어 있는 것.</li>
<li>그리고 두번째 <code>SUB</code> 에서는 <code>ADD</code> 에서 읽은 <span class="math math-inline"><span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.0077em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">4</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></span> 가 <code>SUB</code> 에서는 write 한다. 그래서 오른쪽을 보면 <code>ADD</code> 에서는 <span class="math math-inline"><span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">4</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></span> 로 되어 있던 것이 <span class="math math-inline"><span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8333em;vertical-align:-0.15em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.13889em;">P</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3011em;"><span style="top:-2.55em;margin-left:-0.1389em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">6</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.15em;"><span></span></span></span></span></span></span></span></span></span></span> 으로 바뀐다.</li>
</ul>
</li>
</ul>
<h3 id="scoreboard-with-explicit-register-renaming-example">Scoreboard with Explicit Register Renaming Example<a aria-hidden="true" tabindex="-1" href="#scoreboard-with-explicit-register-renaming-example" class="internal"> §</a></h3>
<ul>
<li>Scoreboard 에서 이런 Explicit Register Renaming 을 사용하면 어떻게 되는지 살펴보자.</li>
</ul>
<p><img src="../../../../../images/Pasted-image-20250427231645.png" width="auto" height="auto"/></p>
<h4 id="cycle-1-2">Cycle 1<a aria-hidden="true" tabindex="-1" href="#cycle-1-2" class="internal"> §</a></h4>
<p><img src="../../../../../images/Pasted-image-20250427231416.png" width="auto" height="auto"/></p>
<ul>
<li>Cycle 1 에서는 첫번째 <code>LD</code> 가 issue 된다.
<ul>
<li>위에서 말했다시피, issue time 에 output register 가 rename 된다. 그래서 <code>F6</code> 이 <code>P6</code> 에서 <code>P32</code> 로 rename 된다.</li>
</ul>
</li>
</ul>
<h4 id="cycle-2-2">Cycle 2<a aria-hidden="true" tabindex="-1" href="#cycle-2-2" class="internal"> §</a></h4>
<p><img src="../../../../../images/Pasted-image-20250427231600.png" width="auto" height="auto"/></p>
<ul>
<li>Cycle 2 에서는 두번째 <code>LD</code> 가 issue 된다.
<ul>
<li>마찬가지로, 이때 <code>F2</code> 는 <code>P2</code> 에서 <code>P34</code> 로 rename 된다.</li>
</ul>
</li>
</ul>
<h4 id="cycle-3-2">Cycle 3<a aria-hidden="true" tabindex="-1" href="#cycle-3-2" class="internal"> §</a></h4>
<p><img src="../../../../../images/Pasted-image-20250427231728.png" width="auto" height="auto"/></p>
<ul>
<li>Cycle 3 에서는 <code>MULTD</code> 가 issue 된다.
<ul>
<li>일단 마찬가지로 <code>F0</code> 이 <code>P0</code> 에서 <code>P36</code> 으로 renaming 된다.</li>
<li>이때 functional unit status 를 자세히 보면, input register <code>F2</code>, <code>F4</code> 에 대해 <code>F4</code> 는 그대로 <code>P4</code> 로 명시되어 있는 반면 <code>F2</code> 는 rename 된 location <code>P34</code> 가 되어 있는 것을 알 수 있다.</li>
<li>그리고 간단히 복습하자면, <code>F2</code> 는 두번째 <code>LD</code> 에 <a href="../../../../../gardens/arch/dependence/terms/Data-Dependence-(Arch)" class="internal" data-slug="gardens/arch/dependence/terms/Data-Dependence-(Arch)">RAW dependence</a> 가 있기 때문에 <span class="math math-inline"><span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9694em;vertical-align:-0.2861em;"></span><span class="mord"><span class="mord mathnormal">Q</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:0em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span></span></span></span></span> 가 Int2 가 되고 <span class="math math-inline"><span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.9694em;vertical-align:-0.2861em;"></span><span class="mord"><span class="mord mathnormal" style="margin-right:0.00773em;">R</span><span class="msupsub"><span class="vlist-t vlist-t2"><span class="vlist-r"><span class="vlist" style="height:0.3117em;"><span style="top:-2.55em;margin-left:-0.0077em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mathnormal mtight" style="margin-right:0.05724em;">j</span></span></span></span><span class="vlist-s">​</span></span><span class="vlist-r"><span class="vlist" style="height:0.2861em;"><span></span></span></span></span></span></span></span></span></span></span> 가 <code>NO</code> 가 된다.</li>
</ul>
</li>
</ul>
<h4 id="cycle-4-1">Cycle 4<a aria-hidden="true" tabindex="-1" href="#cycle-4-1" class="internal"> §</a></h4>
<p><img src="../../../../../images/Pasted-image-20250427232129.png" width="auto" height="auto"/></p>
<ul>
<li>Cycle 4 에서는 <code>SUBD</code> 가 issue 된다.
<ul>
<li>마찬가지로 이놈의 output register 인 F8 이 P8 에서 <code>P38</code> 으로 renaming 이 되고,</li>
<li>Input register 인 <code>F2</code> 는 mapping 된 location 인 <code>P34</code> 가 적히는 것을 알 수 있다.</li>
</ul>
</li>
<li>그리고 첫번째 <code>LOAD</code> 가 종료된다.</li>
</ul>
<h4 id="cycle-5-1">Cycle 5<a aria-hidden="true" tabindex="-1" href="#cycle-5-1" class="internal"> §</a></h4>
<p><img src="../../../../../images/Pasted-image-20250427232347.png" width="auto" height="auto"/></p>
<ul>
<li>Cycle 5 에서는 <code>DIVD</code> 가 issue 된다.
<ul>
<li>또 마찬가지로, 이놈의 output register 인 <code>F10</code> 은 <code>P10</code> 에서 <code>P40</code> 으로 renaming 되고, input register 인 <code>F0</code> 와 <code>F6</code> 은 renaming 된 register 인 <code>P36</code> 와 <code>P32</code> 를 사용하게 된다.</li>
</ul>
</li>
</ul>
<h4 id="cycle-10-skip-cycle-6--9">Cycle 10 (Skip cycle 6 ~ 9)<a aria-hidden="true" tabindex="-1" href="#cycle-10-skip-cycle-6--9" class="internal"> §</a></h4>
<p><img src="../../../../../images/Pasted-image-20250427232738.png" width="auto" height="auto"/></p>
<ul>
<li>일단 이전까지는 Add 가 <code>SUBD</code> 에서 사용중이었으므로 <code>ADDD</code> 는 cycle 10 까지 stall 된다.
<ul>
<li>그래서 cycle 6 ~ 9 는 생략했당.</li>
</ul>
</li>
<li>그래서 cycle 10 에서 <code>ADDD</code> 가 issue 된다.
<ul>
<li>보면 output register 인 <code>F6</code> 은 다시 <code>P32</code> 에서 <code>P42</code> 로 renaming 되고, input register 는 <code>F8</code> 와 <code>F2</code> 에 대해 기존에 renaming 된 register 인 <code>P38</code> 와 <code>P34</code> 를 사용한다.</li>
<li>근데 생각해 보면 이 <code>F6</code> 은 이전에 <code>DIVD</code> 에서 읽고있었던 register 였으므로 <code>DIVD</code> 와 <code>ADDD</code> 간에는 <a href="../../../../../gardens/arch/dependence/terms/Data-Dependence-(Arch)" class="internal" data-slug="gardens/arch/dependence/terms/Data-Dependence-(Arch)">WAR dependence</a> 가 있었던 것을 알 수 있었는데, 이렇게 register renaming 을 통해 이러한 WAR 가 해소된 것을 알 수 있다.
<ul>
<li>근데 주의할 점은 <code>F6</code> 의 기존 location 이었던 <code>P32</code> 가 <code>DIVD</code> 에서 여전히 사용되고 있다는 것이다.</li>
<li>즉, 추후에 또 mapping 이 바뀌어 <code>DIVD</code> 가 여전히 <code>P32</code> 을 읽고 있는 와중에 <code>P32</code> 가 또 다른 name 에 mapping 되지 않도록 주의해야 한다.</li>
<li>이를 위해 내부적으로 freelist 를 관리하고 있고, 사용을 다 했으면 이 freelist 에 넣어 이러한 문제를 막는다고 한다.</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="branch-prediction">Branch Prediction<a aria-hidden="true" tabindex="-1" href="#branch-prediction" class="internal"> §</a></h2>
<ul>
<li><a href="../../../../../gardens/arch/cpu/terms/Branch-Prediction-(Arch)" class="internal" data-slug="gardens/arch/cpu/terms/Branch-Prediction-(Arch)">Branch prediction</a> 이라는 것은 알다시피 branch instruction 이 있으면 다음에 어떤 instruction 을 실행해야 할 지 알 수 없기 때문에, 미리 예측하여 실행하는 것이다.
<ul>
<li>이러한 관점에서, branch prediction 을 HW-based speculative execution 이라고 하기도 한다.</li>
</ul>
</li>
<li>한번에 여러개의 inst 를 issue 하는 superscalar 의 경우에는 한번 misprediction 이 발생하면 다 터지기 때문에 overhead 가 아주 커진다.</li>
</ul>
<p><img src="../../../../../images/Pasted-image-20250427234144.png" width="auto" height="auto"/></p>
<ul>
<li>Branch prediction 을 할 때, 그 대상은
<ul>
<li>일단 방향 (direction): function call 같은 경우에는 single direction 이고, branch 는 binary direction 이기 때문에 1bit 정도면 충분하다.</li>
<li>그리고 위치 (target) 까지 알아야 한다: 어느 주소로 갈 것이냐 (즉, 64bit 가 필요하다).</li>
</ul>
</li>
</ul>
<h3 id="1-bit-predictor">1-bit Predictor<a aria-hidden="true" tabindex="-1" href="#1-bit-predictor" class="internal"> §</a></h3>
<ul>
<li>간단한 predictor 로는 branch 의 PC (address) 를 hash 하여 그놈에 맞는 1bit-history table entry 를 업데이트하는 것이다.
<ul>
<li>따라서 이렇게 하면 같은 branch 에서는 항상 그 이전의 결과를 따라가게된다.</li>
</ul>
</li>
<li>즉, 아래와 같은 방식으로 예측한다는 것이고,
<ul>
<li>여기서 <em>Branch History Table</em> 을 <em>BHT</em> 라고 부르기도 한다.</li>
</ul>
</li>
</ul>
<p><img src="../../../../../images/Pasted-image-20250427234541.png" width="auto" height="auto"/></p>
<ul>
<li>이를 위해서는 아래와 같은 구조가 필요하며,</li>
</ul>
<p><img src="../../../../../images/Pasted-image-20250427235139.png" width="auto" height="auto"/></p>
<ul>
<li>State transition 에 대한 FSM (Finite State Machine) 을 그려보면 다음과 같다.</li>
</ul>
<p><img src="../../../../../images/Pasted-image-20250427235403.png" width="auto" height="auto"/></p>
<ul>
<li>사실 너무 간단해서 별로 설명할게 없는데, 이 구조의 단점은 성능이 구리다는 것이다.</li>
<li>아래의 예시를 보자.</li>
</ul>
<p><img src="../../../../../images/Pasted-image-20250427235502.png" width="auto" height="auto"/></p>
<ul>
<li>예시가 좀 불충분하긴 한데, 이 for loop 을 반복해서 실행한다고 해보면</li>
<li>1-bit predictor 에서는 이전의 결정을 그대로 따라가기 때문에 <code>i</code> 가 4가 됐을 때 기존처럼 taken 으로 예측하면 실제로는 not taken 이기 때문에 한번 틀리고, 다음에 <code>i</code> 가 0 이 되었을 때 기존처럼 not taken 으로 예측하면 실제로는 taken 이기 때문에 또 한번 틀린다.</li>
<li>이런식으로 연속해서 두번 틀리게 되어 60% 라는 낮은 적중률이 나오게 되는 것이다.</li>
</ul>
<h3 id="2-bit-saturating-up-down-counter-predictor">2-bit Saturating Up, Down Counter Predictor<a aria-hidden="true" tabindex="-1" href="#2-bit-saturating-up-down-counter-predictor" class="internal"> §</a></h3>
<ul>
<li>위 1-bit predictor 의 문제점은 taken 여부를 바로바로 바꾸기 때문이었다.</li>
<li>그렇다면 좀 결정을 차분히 바꾸기 위해 일종의 유예기간을 두자는 것이 이 <em>2-bit Saturating Up, Down Counter Predictor</em> 이다.</li>
<li>즉, 여기서는 2bit 를 사용하여, weak-strong 개념을 추가하여 예측하는 방법이다.
<ul>
<li>만약에 weak taken 에서 한번 더 taken 되면 strong 이 되는 식이다.</li>
<li>즉, second-chance 를 주는 셈이고 strong 상태에서는 두번 연속 반대의 결과가 나와야 taken-not taken 이 바뀌게 된다는 것이다.</li>
</ul>
</li>
<li>따라서 아래와 같은 FSM 을 그려볼 수 있다.</li>
</ul>
<p><img src="../../../../../images/Pasted-image-20250428001132.png" width="auto" height="auto"/></p>
<ul>
<li>아니면 이런 식의 방법도 있다:
<ul>
<li>위의 방법에서는 strong 에서 반대의 strong 으로 가려면 세번의 연속된 동일한 결정이 나와야 하는 반면,</li>
<li>아래의 방법에서는 weak 에서는 strong 으로 옮겨지게 해서 두번만 동일하게 나와도 바뀌는 식이다.</li>
</ul>
</li>
</ul>
<p><img src="../../../../../images/Pasted-image-20250428001308.png" width="auto" height="auto"/></p>
<ul>
<li>이렇게 하면 아래 그림에서 보이는 것 처럼 확률을 높일 수 있다.
<ul>
<li>즉, 한번 틀리는 것으로는 결정을 바로 바꾸지 않기 때문에 어쩌다 한번 틀리는 경우에 대해 다음번까지 틀리는 것을 방지할 수 있다.</li>
</ul>
</li>
</ul>
<p><img src="../../../../../images/Pasted-image-20250428001547.png" width="auto" height="auto"/></p>
<h3 id="alias-problem">Alias Problem<a aria-hidden="true" tabindex="-1" href="#alias-problem" class="internal"> §</a></h3>
<ul>
<li>하지만 위와 같은 hash table 의 접근에서는 항상 문제가 되는 것이 collision 이다.</li>
</ul>
<p><img src="../../../../../images/Pasted-image-20250428001739.png" width="auto" height="auto"/></p>
<ul>
<li>즉, 위처럼 collision 이 발생하는 경우에는 다른놈의 prediction 을 갖다 사용하기 때문에 실패 확률이 높아질 수 있다.</li>
</ul>
<h3 id="branch-correlation">Branch Correlation<a aria-hidden="true" tabindex="-1" href="#branch-correlation" class="internal"> §</a></h3>
<p><img src="../../../../../images/Pasted-image-20250428003246.png" width="auto" height="auto"/></p>
<ul>
<li>실제 code 를 생각해 보면, 각각의 branch 는 독립적이지 않고 연관되어 있는 경우가 많다.
<ul>
<li>가령 위 그림에서 왼쪽의 code 를 보더라도 경우의 수는 <span class="math math-inline"><span class="katex"><span class="katex-html" aria-hidden="true"><span class="base"><span class="strut" style="height:0.8141em;"></span><span class="mord"><span class="mord">2</span><span class="msupsub"><span class="vlist-t"><span class="vlist-r"><span class="vlist" style="height:0.8141em;"><span style="top:-3.063em;margin-right:0.05em;"><span class="pstrut" style="height:2.7em;"></span><span class="sizing reset-size6 size3 mtight"><span class="mord mtight">3</span></span></span></span></span></span></span></span><span class="mspace" style="margin-right:0.2778em;"></span><span class="mrel">=</span><span class="mspace" style="margin-right:0.2778em;"></span></span><span class="base"><span class="strut" style="height:0.6444em;"></span><span class="mord">8</span></span></span></span></span> 개가 아니고 4개인 것을 알 수 있다.</li>
<li>또한 만약 <code>b1</code> 와 <code>b2</code> 가 taken 이라면 <code>b3</code> 는 당연히 not taken 이라는 것은 누구나 알 수 있다.</li>
</ul>
</li>
<li>이런식으로 주변의 branch 를 연관시켜서 prediction 을 하는 branch correlation 이 등장한다.</li>
</ul>
<h3 id="correlated-branch-predictor">Correlated Branch Predictor<a aria-hidden="true" tabindex="-1" href="#correlated-branch-predictor" class="internal"> §</a></h3>
<p><img src="../../../../../images/Pasted-image-20250428085506.png" width="auto" height="auto"/></p>
<ul>
<li>위 그림에서 왼쪽이 위에서 말한 2-bit saturated counter 이고, 오른쪽이 correlated branch predictor 이다.</li>
<li>보면 N-bit global branch history 를 이용한다.
<ul>
<li>이놈은 N 번의 이전 branch prediction history 를 저장한다.</li>
<li>가령 2-bit 이고, 이전에 taken - not taken 이었으면 10 이런식으로 저장돼 있는 것.</li>
</ul>
</li>
<li>그리고 2-bit saturated counter 와 동일하게 branch PC 를 hashing 해서 M-bit 을 만들어 내고, 이 M-bit 을 index 로 해서 배열에 접근하는데</li>
<li>어느 배열에 접근할 지가 저 N-bit global branch history 에 의해 결정되는 것이다.
<ul>
<li>즉, 이렇게 하면 같은 branch 라 할지라도 최근 두번의 prediction 결과에 따라 다른 prediction 을 할 수 있는 것이다.</li>
<li>일종의 prediction context 가 바뀌는 셈.</li>
</ul>
</li>
<li>이렇게 N-bit global history 와 M-bit counter 를 사용하는 것을 줄여서 <em>(M, N) scheme</em> 이라고 한다.</li>
</ul>
<h3 id="gselect-branch-predictor">Gselect Branch Predictor<a aria-hidden="true" tabindex="-1" href="#gselect-branch-predictor" class="internal"> §</a></h3>
<ul>
<li><em>Gselect Branch Predictor</em> 는 위의 Correlated Branch Predictor 와 아이디어는 동일한데, 여러개의 table 을 사용하는 것이 아닌 하나의 거대한 table 을 사용하는 방법이다.</li>
</ul>
<p><img src="../../../../../images/Pasted-image-20250428092850.png" width="auto" height="auto"/></p>
<ul>
<li>그래서 위 그림에서 보이는 것 처럼 PC 에서 LSB 일부를 뽑아내고 (즉, 이것이 hashing 을 하는 것과 동일한 효과)</li>
<li><em>Branch History Register</em> (<em>BHR</em>) 에서 LSB 일부를 뽑아내어 이 두개를 concat 한 값을 index 로 하여 <em>Prediction History Table</em> (<em>PHT</em>) 에 접근한다.</li>
</ul>
<h3 id="gshare-branch-predictor">Gshare Branch Predictor<a aria-hidden="true" tabindex="-1" href="#gshare-branch-predictor" class="internal"> §</a></h3>
<ul>
<li>근데 <em>Gselect Branch Predictor</em> 에는 문제가 있다:</li>
</ul>
<p><img src="../../../../../images/Pasted-image-20250428093123.png" width="auto" height="auto"/></p>
<ul>
<li>위 예시에서 보다시피, Gselect 에서는 PC 와 BHR 의 LSB 일부만 뽑아내어 concat 하기 때문에, history 가 충분히 반영되지 않는다는 것이다.
<ul>
<li>그래서 보면 첫 두 row 에 대해서는 history 가 달라짐에 따라 다른 PHT index (Gselect) 가 나오지만,</li>
<li>그 아래 두 row 에 대해서는 history 가 다른데도 동일한 PHT index (Gselect) 가 나온다.</li>
</ul>
</li>
<li>그래서 이런 문제를 해결한 것이 <em>Gshare Branch Predictor</em> 이다.</li>
</ul>
<p><img src="../../../../../images/Pasted-image-20250428093349.png" width="auto" height="auto"/></p>
<ul>
<li>여기서의 핵심은 LSB 를 concat 하는 것이 아니고, address 와 history 전부를 XOR-ing 하는 것이다.
<ul>
<li>위 예시에서는 address 가 8bit 이니까 상관없지만 실제로는 32/64bit 이니까 아마 LSB 8bit 를 뽑아내겠지</li>
</ul>
</li>
<li>그래서 이렇게 하면 history 전체가 반영되기 때문에 아래의 두 row 를 봐도 history 가 달라짐에 따라 PHT index (Gshare) 도 달라지는 것을 볼 수 있다.</li>
</ul>
<h3 id="branch-target-buffer">Branch Target Buffer<a aria-hidden="true" tabindex="-1" href="#branch-target-buffer" class="internal"> §</a></h3>
<p><img src="../../../../../images/Pasted-image-20250428085004.png" width="auto" height="auto"/></p>
<ul>
<li>마지막으로 branch target buffer 를 간단히 보면
<ul>
<li>이놈은 어디로 branch 를 뛸까를 결정하기 위해 PC 와 predicted PC 를 key-value 로 하는 buffer 라고 생각하면 된다.</li>
<li>우선 PC 가 들어오면 이 buffer 를 lookup 해서 여기에 없으면 이 PC 가 branch 가 아니므로 그냥 일반적으로 실행하는 거고</li>
<li>여기에 있으면 여기에 buffering 된 주소를 다음 PC 로 해서 jump 를 뛰는거다</li>
<li>그리고 entry 의 마지막에 branch prediction 결과 (taken, not taken) 이 저장되어 있는 형태라고 한다.</li>
</ul>
</li>
</ul></article></div><div class="right sidebar"><div class="graph "><h3>Graph View</h3><div class="graph-outer"><div id="graph-container" data-cfg="{&quot;drag&quot;:true,&quot;zoom&quot;:true,&quot;depth&quot;:1,&quot;scale&quot;:1.1,&quot;repelForce&quot;:0.5,&quot;centerForce&quot;:0.3,&quot;linkDistance&quot;:30,&quot;fontSize&quot;:0.6,&quot;opacityScale&quot;:1,&quot;showTags&quot;:true,&quot;removeTags&quot;:[]}"></div><svg version="1.1" id="global-graph-icon" xmlns="http://www.w3.org/2000/svg" xmlnsXlink="http://www.w3.org/1999/xlink" x="0px" y="0px" viewBox="0 0 55 55" fill="currentColor" xmlSpace="preserve"><path d="M49,0c-3.309,0-6,2.691-6,6c0,1.035,0.263,2.009,0.726,2.86l-9.829,9.829C32.542,17.634,30.846,17,29,17
	s-3.542,0.634-4.898,1.688l-7.669-7.669C16.785,10.424,17,9.74,17,9c0-2.206-1.794-4-4-4S9,6.794,9,9s1.794,4,4,4
	c0.74,0,1.424-0.215,2.019-0.567l7.669,7.669C21.634,21.458,21,23.154,21,25s0.634,3.542,1.688,4.897L10.024,42.562
	C8.958,41.595,7.549,41,6,41c-3.309,0-6,2.691-6,6s2.691,6,6,6s6-2.691,6-6c0-1.035-0.263-2.009-0.726-2.86l12.829-12.829
	c1.106,0.86,2.44,1.436,3.898,1.619v10.16c-2.833,0.478-5,2.942-5,5.91c0,3.309,2.691,6,6,6s6-2.691,6-6c0-2.967-2.167-5.431-5-5.91
	v-10.16c1.458-0.183,2.792-0.759,3.898-1.619l7.669,7.669C41.215,39.576,41,40.26,41,41c0,2.206,1.794,4,4,4s4-1.794,4-4
	s-1.794-4-4-4c-0.74,0-1.424,0.215-2.019,0.567l-7.669-7.669C36.366,28.542,37,26.846,37,25s-0.634-3.542-1.688-4.897l9.665-9.665
	C46.042,11.405,47.451,12,49,12c3.309,0,6-2.691,6-6S52.309,0,49,0z M11,9c0-1.103,0.897-2,2-2s2,0.897,2,2s-0.897,2-2,2
	S11,10.103,11,9z M6,51c-2.206,0-4-1.794-4-4s1.794-4,4-4s4,1.794,4,4S8.206,51,6,51z M33,49c0,2.206-1.794,4-4,4s-4-1.794-4-4
	s1.794-4,4-4S33,46.794,33,49z M29,31c-3.309,0-6-2.691-6-6s2.691-6,6-6s6,2.691,6,6S32.309,31,29,31z M47,41c0,1.103-0.897,2-2,2
	s-2-0.897-2-2s0.897-2,2-2S47,39.897,47,41z M49,10c-2.206,0-4-1.794-4-4s1.794-4,4-4s4,1.794,4,4S51.206,10,49,10z"></path></svg></div><div id="global-graph-outer"><div id="global-graph-container" data-cfg="{&quot;drag&quot;:true,&quot;zoom&quot;:true,&quot;depth&quot;:-1,&quot;scale&quot;:0.9,&quot;repelForce&quot;:0.5,&quot;centerForce&quot;:0.3,&quot;linkDistance&quot;:30,&quot;fontSize&quot;:0.6,&quot;opacityScale&quot;:1,&quot;showTags&quot;:true,&quot;removeTags&quot;:[]}"></div></div></div><div class="toc desktop-only"><button type="button" id="toc"><h3>Table of Contents</h3><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="fold"><polyline points="6 9 12 15 18 9"></polyline></svg></button><div id="toc-content"><ul class="overflow"><li class="depth-0"><a href="#register-renaming" data-for="register-renaming">Register Renaming</a></li><li class="depth-0"><a href="#tomasulos-algorithm" data-for="tomasulos-algorithm">Tomasulo's Algorithm</a></li><li class="depth-1"><a href="#tomasulo-organization" data-for="tomasulo-organization">Tomasulo Organization</a></li><li class="depth-1"><a href="#reservation-station-components" data-for="reservation-station-components">Reservation Station Components</a></li><li class="depth-1"><a href="#cpu-cycles" data-for="cpu-cycles">CPU cycles</a></li><li class="depth-1"><a href="#example-1" data-for="example-1">Example 1</a></li><li class="depth-1"><a href="#tomasulo-vs-scoreboard" data-for="tomasulo-vs-scoreboard">Tomasulo vs Scoreboard</a></li><li class="depth-1"><a href="#example-2" data-for="example-2">Example 2</a></li><li class="depth-1"><a href="#tomasulo-limitations" data-for="tomasulo-limitations">Tomasulo Limitations</a></li><li class="depth-0"><a href="#explicit-register-renaming" data-for="explicit-register-renaming">Explicit Register Renaming</a></li><li class="depth-1"><a href="#mapping-table-example" data-for="mapping-table-example">Mapping Table Example</a></li><li class="depth-1"><a href="#scoreboard-with-explicit-register-renaming-example" data-for="scoreboard-with-explicit-register-renaming-example">Scoreboard with Explicit Register Renaming Example</a></li><li class="depth-0"><a href="#branch-prediction" data-for="branch-prediction">Branch Prediction</a></li><li class="depth-1"><a href="#1-bit-predictor" data-for="1-bit-predictor">1-bit Predictor</a></li><li class="depth-1"><a href="#2-bit-saturating-up-down-counter-predictor" data-for="2-bit-saturating-up-down-counter-predictor">2-bit Saturating Up, Down Counter Predictor</a></li><li class="depth-1"><a href="#alias-problem" data-for="alias-problem">Alias Problem</a></li><li class="depth-1"><a href="#branch-correlation" data-for="branch-correlation">Branch Correlation</a></li><li class="depth-1"><a href="#correlated-branch-predictor" data-for="correlated-branch-predictor">Correlated Branch Predictor</a></li><li class="depth-1"><a href="#gselect-branch-predictor" data-for="gselect-branch-predictor">Gselect Branch Predictor</a></li><li class="depth-1"><a href="#gshare-branch-predictor" data-for="gshare-branch-predictor">Gshare Branch Predictor</a></li><li class="depth-1"><a href="#branch-target-buffer" data-for="branch-target-buffer">Branch Target Buffer</a></li></ul></div></div><div class="backlinks "><h3>Backlinks</h3><ul class="overflow"><li><a href="../../../../../gardens/arch/cpu/terms/Register-Renaming-(Arch)" class="internal">Register Renaming (Arch)</a></li><li><a href="../../../../../gardens/arch/originals/aca.spring.2025.cse.snu.ac.kr/(SNU-CSE)-Advanced-Computer-Architectures" class="internal">(SNU CSE) Advanced Computer Architectures</a></li></ul></div></div></div><footer class><hr/><p>Created with <a href="https://quartz.jzhao.xyz/">Quartz v4.1.0</a>, © 2025</p><ul><li><a href="https://github.com/haeramkeem">GitHub</a></li><li><a href="https://www.linkedin.com/in/haeram-kim-277404220">LinkedIn</a></li><li><a href="mailto:haeram.kim1@gmail.com">Email</a></li></ul></footer></div></body><script type="application/javascript">// quartz/components/scripts/quartz/components/scripts/callout.inline.ts
function toggleCallout() {
  const outerBlock = this.parentElement;
  outerBlock.classList.toggle(`is-collapsed`);
  const collapsed = outerBlock.classList.contains(`is-collapsed`);
  const height = collapsed ? this.scrollHeight : outerBlock.scrollHeight;
  outerBlock.style.maxHeight = height + `px`;
  let current = outerBlock;
  let parent = outerBlock.parentElement;
  while (parent) {
    if (!parent.classList.contains(`callout`)) {
      return;
    }
    const collapsed2 = parent.classList.contains(`is-collapsed`);
    const height2 = collapsed2 ? parent.scrollHeight : parent.scrollHeight + current.scrollHeight;
    parent.style.maxHeight = height2 + `px`;
    current = parent;
    parent = parent.parentElement;
  }
}
function setupCallout() {
  const collapsible = document.getElementsByClassName(
    `callout is-collapsible`
  );
  for (const div of collapsible) {
    const title = div.firstElementChild;
    if (title) {
      title.removeEventListener(`click`, toggleCallout);
      title.addEventListener(`click`, toggleCallout);
      const collapsed = div.classList.contains(`is-collapsed`);
      const height = collapsed ? title.scrollHeight : div.scrollHeight;
      div.style.maxHeight = height + `px`;
    }
  }
}
document.addEventListener(`nav`, setupCallout);
window.addEventListener(`resize`, setupCallout);
</script><script type="module">
          import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.esm.min.mjs';
          const darkMode = document.documentElement.getAttribute('saved-theme') === 'dark'
          mermaid.initialize({
            startOnLoad: false,
            securityLevel: 'loose',
            theme: darkMode ? 'dark' : 'default'
          });
          document.addEventListener('nav', async () => {
            await mermaid.run({
              querySelector: '.mermaid'
            })
          });
          </script><script src="https://cdn.jsdelivr.net/npm/katex@0.16.7/dist/contrib/copy-tex.min.js" type="application/javascript"></script><script src="https://www.googletagmanager.com/gtag/js?id=G-N68CCP1QHG" type="application/javascript"></script><script src="../../../../../postscript.js" type="module"></script></html>