<!DOCTYPE html>
<html><head><title>08-1. Memory Address</title><meta charSet="utf-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:title" content="08-1. Memory Address"/><meta property="og:description" content="이화여자대학교 컴퓨터공학과 반효경 교수님의 &amp;quot;운영체제 (KOCW)&amp;quot; 강의를 필기한 내용입니다. 다소 잘못된 내용과 구어적 표현 이 포함되어 있을 수 있습니다. Logical, Physical, Symbolic Address § Logical Address (Virtual Address): 프로세스 각각이 가지는 가상 주소 공간 속의 주소 즉 메모리 전체에 이 프로세스 하나만 올라가있다고 상상했을 때의 주소를 의미한다 따라서 메모리 주소는 0번부터 시작 이제부터는 별다줄로다가 LA라 표현해보자고 Physical Address: 실제 메모리의 주소 실제 메모리의 주소이기 때문에 하위 주소에는 커널이 들어가고 상위 주소에 유저 프로세스들이 올라가게 된다 얘는 PA 라 표현해보자고 Symbolic Address 라는 것은 코드 작성시에의 변수를 의미하는 것 즉, 코드에는 메모리 주소가 아닌 사람이 읽을 수 있는 형태의 문자열인 변수를 사용하게 되는데 이것을 Symbolic Address 라고 하는 것 Address Binding § Address Binding: LA 를 PA 로 바꾸는 과정 메모리에 접근하기 위해서는 LA 가 아니라 PA 가 필요한데 이를 위해 주소 변환 과정이 필요하게 된다 Binding 시점에 따른 분류 § Binding 시점에 따라 종류를 세 가지로 나눠볼 수 있다 Compile Time Binding: 컴파일 시점에 PA 까지 결정되는 것 컴파일 시점에는 SA 가 LA 로 바뀌기 때문에 이때의 주소를 PA로 사용한다는 것은 항상 LA와 PA 가 같고 프로세스는 항상 (별도의 조치가 없는 한) PA 0번부터 적재되게 된다 뭐 당연히 현대의 컴퓨터에서는 사용되지 않았지만 옛날에 컴퓨터에서 하나의 프로세스만 작동되던 시절에는 이런 방식의 바인딩을 사용했다더라 LA 와 PA 가 같기 때문에 이러한 코드를 Absolute Code(절대 코드) 라고 부르고 컴파일러는 이것을 생성하게 된다 Load Time Binding: 프로그램이 프로세스가 되어 메모리에 적재되는 시점에 PA 를 결정하는 것 얘는 위에놈보다 좀 더 합리적이제 메모리 사용 현황은 계속해서 바뀌어서 컴파일 시점에는 메모리의 어느 부분에 적재할지 알기 힘들기 때문에 메모리에 적재할때 LA 와 PA 를 바인딩하자는 개념 이때에는 컴파일러가 Relocatable Code (재배치 가능 코드) 를 생성한다 Runtime Binding: Load Time Binding 과 유사하나 최초에 메모리에 적재된 이후에도 새롭게 바인딩이 될 수 있는 방법 이것은 이제 프로세스의 Swapping 을 지원하기 위해 나온 것이다 왜냐면 프로세스가 Swap out 되면 디스크로 쫒겨나게 되는데 이후에 다시 Swap in 할 때 기존의 PA 가 아닌 새로운 PA 에 바인딩될 수 있도록 해야 하기 때문 당연히 요즘의 운영체제에서는 이 방법을 사용한다 프로세스가 시작되고 종료되기 전까지 PA 가 계속 바뀔 수 있으므로 주소 변환 과정을 CPU 가 아닌 MMU 라는 별도의 하드웨어를 이용해 처리한다 CPU 입장에서 § 위 그림을 자세히 보면 코드가 적재되는 위치만 바뀌고 코드에 작성되어 있는 주소는 바뀌지 않잖어 따라서 CPU가 사용하는 (바라보는) 주소는 LA 이다 왜냐하면 코드에 작성되어 있는 주소를 바꾸기 위해서는 컴파일을 새로 해야 되는데 Compile Time Binding 이 아닌 이상 불가능 하기 때문에 코드에 작성되어 있는 주소는 LA 로 놔두고 적재 위치만 바꾸게 되는 것 Memory Management Unit (MMU) § MMU 는 주소 변환을 해주는 하드웨어 유닛인데 다음과 같은 방식으로 작동한다 일단 CPU 가 LA 를 이용해 주소를 달라고 요청 LA 는 무적권 0번부터 시작하기 때문에 LA 가 곧 프로세스 주소 공간의 시작점으로부터의 Offset 을 나타냄 → 프로세스가 적재되어 있는 실제 메모리 상의 시작점의 주소만 알면 여기에 LA 를 더함으로써 PA 를 구할 수 있다 이 시작점의 주소는 MMU 내의 Base Register (BA) 혹은 Relocation Register 에 저장된다 PA 를 알아낸 이후에는 여기에 저장되어 있던 것을 읽어 CPU 로 전달 위의 그림이 MMU 의 작동 과정을 나타내는 그림인데 MMU가 주소 변환을 할 때에는 LA 가 유효한지를 먼저 검사하게 된다 왜냐면 만약 프로세스의 주소 공간의 크기가 3000일 때 이것보다 큰 LA 요청이 들어오게 된다면 프로세스 바깥의 주소 공간을 참조하게 되는 것 이므로 다른 프로세스의 주소공간에 무단 침입하는 셈이기 때문이다 따라서 MMU 에서는 Limit Register 라는 또 다른 레지스터를 이용해서 프로세스 주소 공간의 크기를 저장해 놓고 이것보다 큰 LA 요청이 들어오면 트랩을 걸어 기각시키게 된다 Dynamic Loading, Overlay § 일단 Dynamic Loading 이라는 것은 프로세스의 전체가 메모리에 올라가는 것이 아닌 필요한 부분만 올라가는 기법을 의미한다 이렇게 하는 이유는 당연히 메모리 효율을 올리기 위함 → 프로그램에는 자주 사용되지 않는 오류 처리 루틴이 많이 포함되어 있기 때문에 프로세스 전체를 올리는 것은 자주 사용하지 않는 부분까지 모두 올리는 것이어서 비효율적이다 Dynamic Loading 의 정확한 정의는 OS의 힘을 빌리지 않고 메모리에 동적으로 적재되는 것을 뜻한다 현대의 OS 에서는 뒤에 나올 페이징 기법을 이용해서 프로세스를 동적으로 메모리에 올리게 되는데 이것은 Dynamic Loading 이 아님 하지만 이 용어를 딱히 구별해서 사용하지는 않는다 → 정확한 정의와는 무관하게 페이징 기법을 사용하는 것도 Dynamic Loading 이라고 부르긴 한다 Overlay 라는 것은 Dynamic Loading 과 유사하지만 용어가 등장한 배경이 좀 다르다 일단 Overlay 도 프로세스를 쪼개서 메모리에 올리는 방법이지만 Overlay 는 메모리의 크기가 너무 작아 프로세스 하나조차 올릴 수 없는 시절에 프로그램을 작성할 때 어느부분을 올릴지 수작업으로 프로그래밍하는 방법을 의미한다 하지만 Dynamic Loading 의 경우에는 메모리의 크기는 넉넉하지만 사용율을 높이기 위해 라이브러리의 힘을 빌려서 동적으로 적재하는 것을 일컫는다 Swapping § 일단 Swapping 이라는 것은 프로세스 전체를 디스크 등의 Backing store 로 쫒아내는 것을 말한다 앞선 강의에서 잠깐 언급되었던 것 처럼 Swapping 은 중기 스케줄러 (Mid-term Scheduler, Swapper) 에 의해 어떤 놈이 방출될지 결정된다 당연히 우선순위가 높은 놈 보다는 낮은 놈을 방출시키는게 좋겠제 → 이것을 Swapper 가 결정하게 되는 것 이 Swapping 은 Runtime Binding 이 필수적이다 Compile Time Binding 이나 Load Time Binding 의 경우에는 Swap out 되었어도 원래 위치로 되돌아 와야 하기 때문에 비효율적 Runtime Binding 이 되어야 Swap in 될 때 비어있는 공간으로 쓱 드갈 수 있기 때문에 필수적이다 Swapping 에서는 읽어들여야 할 데이터의 양이 많기 때문에 대부분 Transfer Time 이 차지한다고 한다 이놈은 뒤에 디스크 부분에서 배울거라는데 디스크가 데이터를 읽어들일 때는 디스크 헤드가 움직이는 Search Time 하고 데이터를 읽어서 보내는 Transfer Time 이 있는데 파일입출력같은 경우에는 Transfer Time 보다는 Search Time 이 더 오래 걸리는 반면 Swapping 의 경우에는 보내야 할 데이터의 양이 많아 Transfer Time 이 더 오래걸린다고 하더라 이놈도 페이징 기법과 연루되면서 용어가 좀 모호하게 쓰인다 원래는 프로세스 전체가 디스크로 쫒겨나는 것을 의미하지만 정확한 정의와 다르게 페이징 기법에 따라 페이지가 쫒겨나는 것도 Swapping 이라고들 하더라 Dynamic Linking § 일단 Static Linking 이라는 용어부터 알 필요가 있다 gcc 로 컴파일 할때 보면 라이브러리들을 오브젝트 파일로 만들어서 링크시켜주는 과정을 통해 라이브러리 내에 있던 코드가 내 코드에 포함되도록 하자네 이렇게 라이브러리에 있던 코드를 내 코드에 포함시키는 것을 Static Linking 이라고 한다 반면에 Dynamic Linking 은 라이브러리 코드를 내 코드에 포함시키지 않고 필요에 따라 불러오는 것을 의미한다 Dynamic Linking 을 하면 라이브러리 코드는 별도의 코드로 존재하고 내가 해당 코드를 사용할 때에는 코드 전체를 가져오는 것이 아니라 해당 코드를 참조할 수 있는 작은 코드 조각 (해당 코드를 가리키는 포인터라고 생각하면 됨 → Stub 이라고 부르더라)을 코드에 넣어서 실행시점에 링크시켜 주는 것을 의미한다 리눅스에서 ."/><meta property="og:image" content="https://mdg.haeramk.im/static/og-image.png"/><meta property="og:width" content="1200"/><meta property="og:height" content="675"/><link rel="icon" href="../../../../static/icon.png"/><meta name="description" content="이화여자대학교 컴퓨터공학과 반효경 교수님의 &amp;quot;운영체제 (KOCW)&amp;quot; 강의를 필기한 내용입니다. 다소 잘못된 내용과 구어적 표현 이 포함되어 있을 수 있습니다. Logical, Physical, Symbolic Address § Logical Address (Virtual Address): 프로세스 각각이 가지는 가상 주소 공간 속의 주소 즉 메모리 전체에 이 프로세스 하나만 올라가있다고 상상했을 때의 주소를 의미한다 따라서 메모리 주소는 0번부터 시작 이제부터는 별다줄로다가 LA라 표현해보자고 Physical Address: 실제 메모리의 주소 실제 메모리의 주소이기 때문에 하위 주소에는 커널이 들어가고 상위 주소에 유저 프로세스들이 올라가게 된다 얘는 PA 라 표현해보자고 Symbolic Address 라는 것은 코드 작성시에의 변수를 의미하는 것 즉, 코드에는 메모리 주소가 아닌 사람이 읽을 수 있는 형태의 문자열인 변수를 사용하게 되는데 이것을 Symbolic Address 라고 하는 것 Address Binding § Address Binding: LA 를 PA 로 바꾸는 과정 메모리에 접근하기 위해서는 LA 가 아니라 PA 가 필요한데 이를 위해 주소 변환 과정이 필요하게 된다 Binding 시점에 따른 분류 § Binding 시점에 따라 종류를 세 가지로 나눠볼 수 있다 Compile Time Binding: 컴파일 시점에 PA 까지 결정되는 것 컴파일 시점에는 SA 가 LA 로 바뀌기 때문에 이때의 주소를 PA로 사용한다는 것은 항상 LA와 PA 가 같고 프로세스는 항상 (별도의 조치가 없는 한) PA 0번부터 적재되게 된다 뭐 당연히 현대의 컴퓨터에서는 사용되지 않았지만 옛날에 컴퓨터에서 하나의 프로세스만 작동되던 시절에는 이런 방식의 바인딩을 사용했다더라 LA 와 PA 가 같기 때문에 이러한 코드를 Absolute Code(절대 코드) 라고 부르고 컴파일러는 이것을 생성하게 된다 Load Time Binding: 프로그램이 프로세스가 되어 메모리에 적재되는 시점에 PA 를 결정하는 것 얘는 위에놈보다 좀 더 합리적이제 메모리 사용 현황은 계속해서 바뀌어서 컴파일 시점에는 메모리의 어느 부분에 적재할지 알기 힘들기 때문에 메모리에 적재할때 LA 와 PA 를 바인딩하자는 개념 이때에는 컴파일러가 Relocatable Code (재배치 가능 코드) 를 생성한다 Runtime Binding: Load Time Binding 과 유사하나 최초에 메모리에 적재된 이후에도 새롭게 바인딩이 될 수 있는 방법 이것은 이제 프로세스의 Swapping 을 지원하기 위해 나온 것이다 왜냐면 프로세스가 Swap out 되면 디스크로 쫒겨나게 되는데 이후에 다시 Swap in 할 때 기존의 PA 가 아닌 새로운 PA 에 바인딩될 수 있도록 해야 하기 때문 당연히 요즘의 운영체제에서는 이 방법을 사용한다 프로세스가 시작되고 종료되기 전까지 PA 가 계속 바뀔 수 있으므로 주소 변환 과정을 CPU 가 아닌 MMU 라는 별도의 하드웨어를 이용해 처리한다 CPU 입장에서 § 위 그림을 자세히 보면 코드가 적재되는 위치만 바뀌고 코드에 작성되어 있는 주소는 바뀌지 않잖어 따라서 CPU가 사용하는 (바라보는) 주소는 LA 이다 왜냐하면 코드에 작성되어 있는 주소를 바꾸기 위해서는 컴파일을 새로 해야 되는데 Compile Time Binding 이 아닌 이상 불가능 하기 때문에 코드에 작성되어 있는 주소는 LA 로 놔두고 적재 위치만 바꾸게 되는 것 Memory Management Unit (MMU) § MMU 는 주소 변환을 해주는 하드웨어 유닛인데 다음과 같은 방식으로 작동한다 일단 CPU 가 LA 를 이용해 주소를 달라고 요청 LA 는 무적권 0번부터 시작하기 때문에 LA 가 곧 프로세스 주소 공간의 시작점으로부터의 Offset 을 나타냄 → 프로세스가 적재되어 있는 실제 메모리 상의 시작점의 주소만 알면 여기에 LA 를 더함으로써 PA 를 구할 수 있다 이 시작점의 주소는 MMU 내의 Base Register (BA) 혹은 Relocation Register 에 저장된다 PA 를 알아낸 이후에는 여기에 저장되어 있던 것을 읽어 CPU 로 전달 위의 그림이 MMU 의 작동 과정을 나타내는 그림인데 MMU가 주소 변환을 할 때에는 LA 가 유효한지를 먼저 검사하게 된다 왜냐면 만약 프로세스의 주소 공간의 크기가 3000일 때 이것보다 큰 LA 요청이 들어오게 된다면 프로세스 바깥의 주소 공간을 참조하게 되는 것 이므로 다른 프로세스의 주소공간에 무단 침입하는 셈이기 때문이다 따라서 MMU 에서는 Limit Register 라는 또 다른 레지스터를 이용해서 프로세스 주소 공간의 크기를 저장해 놓고 이것보다 큰 LA 요청이 들어오면 트랩을 걸어 기각시키게 된다 Dynamic Loading, Overlay § 일단 Dynamic Loading 이라는 것은 프로세스의 전체가 메모리에 올라가는 것이 아닌 필요한 부분만 올라가는 기법을 의미한다 이렇게 하는 이유는 당연히 메모리 효율을 올리기 위함 → 프로그램에는 자주 사용되지 않는 오류 처리 루틴이 많이 포함되어 있기 때문에 프로세스 전체를 올리는 것은 자주 사용하지 않는 부분까지 모두 올리는 것이어서 비효율적이다 Dynamic Loading 의 정확한 정의는 OS의 힘을 빌리지 않고 메모리에 동적으로 적재되는 것을 뜻한다 현대의 OS 에서는 뒤에 나올 페이징 기법을 이용해서 프로세스를 동적으로 메모리에 올리게 되는데 이것은 Dynamic Loading 이 아님 하지만 이 용어를 딱히 구별해서 사용하지는 않는다 → 정확한 정의와는 무관하게 페이징 기법을 사용하는 것도 Dynamic Loading 이라고 부르긴 한다 Overlay 라는 것은 Dynamic Loading 과 유사하지만 용어가 등장한 배경이 좀 다르다 일단 Overlay 도 프로세스를 쪼개서 메모리에 올리는 방법이지만 Overlay 는 메모리의 크기가 너무 작아 프로세스 하나조차 올릴 수 없는 시절에 프로그램을 작성할 때 어느부분을 올릴지 수작업으로 프로그래밍하는 방법을 의미한다 하지만 Dynamic Loading 의 경우에는 메모리의 크기는 넉넉하지만 사용율을 높이기 위해 라이브러리의 힘을 빌려서 동적으로 적재하는 것을 일컫는다 Swapping § 일단 Swapping 이라는 것은 프로세스 전체를 디스크 등의 Backing store 로 쫒아내는 것을 말한다 앞선 강의에서 잠깐 언급되었던 것 처럼 Swapping 은 중기 스케줄러 (Mid-term Scheduler, Swapper) 에 의해 어떤 놈이 방출될지 결정된다 당연히 우선순위가 높은 놈 보다는 낮은 놈을 방출시키는게 좋겠제 → 이것을 Swapper 가 결정하게 되는 것 이 Swapping 은 Runtime Binding 이 필수적이다 Compile Time Binding 이나 Load Time Binding 의 경우에는 Swap out 되었어도 원래 위치로 되돌아 와야 하기 때문에 비효율적 Runtime Binding 이 되어야 Swap in 될 때 비어있는 공간으로 쓱 드갈 수 있기 때문에 필수적이다 Swapping 에서는 읽어들여야 할 데이터의 양이 많기 때문에 대부분 Transfer Time 이 차지한다고 한다 이놈은 뒤에 디스크 부분에서 배울거라는데 디스크가 데이터를 읽어들일 때는 디스크 헤드가 움직이는 Search Time 하고 데이터를 읽어서 보내는 Transfer Time 이 있는데 파일입출력같은 경우에는 Transfer Time 보다는 Search Time 이 더 오래 걸리는 반면 Swapping 의 경우에는 보내야 할 데이터의 양이 많아 Transfer Time 이 더 오래걸린다고 하더라 이놈도 페이징 기법과 연루되면서 용어가 좀 모호하게 쓰인다 원래는 프로세스 전체가 디스크로 쫒겨나는 것을 의미하지만 정확한 정의와 다르게 페이징 기법에 따라 페이지가 쫒겨나는 것도 Swapping 이라고들 하더라 Dynamic Linking § 일단 Static Linking 이라는 용어부터 알 필요가 있다 gcc 로 컴파일 할때 보면 라이브러리들을 오브젝트 파일로 만들어서 링크시켜주는 과정을 통해 라이브러리 내에 있던 코드가 내 코드에 포함되도록 하자네 이렇게 라이브러리에 있던 코드를 내 코드에 포함시키는 것을 Static Linking 이라고 한다 반면에 Dynamic Linking 은 라이브러리 코드를 내 코드에 포함시키지 않고 필요에 따라 불러오는 것을 의미한다 Dynamic Linking 을 하면 라이브러리 코드는 별도의 코드로 존재하고 내가 해당 코드를 사용할 때에는 코드 전체를 가져오는 것이 아니라 해당 코드를 참조할 수 있는 작은 코드 조각 (해당 코드를 가리키는 포인터라고 생각하면 됨 → Stub 이라고 부르더라)을 코드에 넣어서 실행시점에 링크시켜 주는 것을 의미한다 리눅스에서 ."/><meta name="generator" content="Quartz"/><link rel="preconnect" href="https://fonts.googleapis.com"/><link rel="preconnect" href="https://fonts.gstatic.com"/><link href="../../../../index.css" rel="stylesheet" type="text/css" spa-preserve/><link href="https://cdn.jsdelivr.net/npm/katex@0.16.0/dist/katex.min.css" rel="stylesheet" type="text/css" spa-preserve/><link href="https://fonts.googleapis.com/css2?family=IBM Plex Mono&amp;family=Gowun Batang:wght@400;700&amp;family=Gowun Dodum:ital,wght@0,400;0,600;1,400;1,600&amp;display=swap" rel="stylesheet" type="text/css" spa-preserve/><script src="../../../../prescript.js" type="application/javascript" spa-preserve></script><script type="application/javascript" spa-preserve>const fetchData = fetch(`../../../../static/contentIndex.json`).then(data => data.json())</script></head><body data-slug="gardens/os/originals/os.bahn.ewha.kocw.net/08-1.-Memory-Address"><div id="quartz-root" class="page"><div id="quartz-body"><div class="left sidebar"><h1 class="page-title "><a href="../../../..">Madison Digital Garden</a></h1><div class="spacer mobile-only"></div><div class="search "><div id="search-icon"><p>Search</p><div></div><svg tabIndex="0" aria-labelledby="title desc" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 19.9 19.7"><title id="title">Search</title><desc id="desc">Search</desc><g class="search-path" fill="none"><path stroke-linecap="square" d="M18.5 18.3l-5.4-5.4"></path><circle cx="8" cy="8" r="7"></circle></g></svg></div><div id="search-container"><div id="search-space"><input autocomplete="off" id="search-bar" name="search" type="text" aria-label="Search for something" placeholder="Search for something"/><div id="results-container"></div></div></div></div><div class="darkmode "><input class="toggle" id="darkmode-toggle" type="checkbox" tabIndex="-1"/><label id="toggle-label-light" for="darkmode-toggle" tabIndex="-1"><svg xmlns="http://www.w3.org/2000/svg" xmlnsXlink="http://www.w3.org/1999/xlink" version="1.1" id="dayIcon" x="0px" y="0px" viewBox="0 0 35 35" style="enable-background:new 0 0 35 35;" xmlSpace="preserve"><title>Light mode</title><path d="M6,17.5C6,16.672,5.328,16,4.5,16h-3C0.672,16,0,16.672,0,17.5    S0.672,19,1.5,19h3C5.328,19,6,18.328,6,17.5z M7.5,26c-0.414,0-0.789,0.168-1.061,0.439l-2,2C4.168,28.711,4,29.086,4,29.5    C4,30.328,4.671,31,5.5,31c0.414,0,0.789-0.168,1.06-0.44l2-2C8.832,28.289,9,27.914,9,27.5C9,26.672,8.329,26,7.5,26z M17.5,6    C18.329,6,19,5.328,19,4.5v-3C19,0.672,18.329,0,17.5,0S16,0.672,16,1.5v3C16,5.328,16.671,6,17.5,6z M27.5,9    c0.414,0,0.789-0.168,1.06-0.439l2-2C30.832,6.289,31,5.914,31,5.5C31,4.672,30.329,4,29.5,4c-0.414,0-0.789,0.168-1.061,0.44    l-2,2C26.168,6.711,26,7.086,26,7.5C26,8.328,26.671,9,27.5,9z M6.439,8.561C6.711,8.832,7.086,9,7.5,9C8.328,9,9,8.328,9,7.5    c0-0.414-0.168-0.789-0.439-1.061l-2-2C6.289,4.168,5.914,4,5.5,4C4.672,4,4,4.672,4,5.5c0,0.414,0.168,0.789,0.439,1.06    L6.439,8.561z M33.5,16h-3c-0.828,0-1.5,0.672-1.5,1.5s0.672,1.5,1.5,1.5h3c0.828,0,1.5-0.672,1.5-1.5S34.328,16,33.5,16z     M28.561,26.439C28.289,26.168,27.914,26,27.5,26c-0.828,0-1.5,0.672-1.5,1.5c0,0.414,0.168,0.789,0.439,1.06l2,2    C28.711,30.832,29.086,31,29.5,31c0.828,0,1.5-0.672,1.5-1.5c0-0.414-0.168-0.789-0.439-1.061L28.561,26.439z M17.5,29    c-0.829,0-1.5,0.672-1.5,1.5v3c0,0.828,0.671,1.5,1.5,1.5s1.5-0.672,1.5-1.5v-3C19,29.672,18.329,29,17.5,29z M17.5,7    C11.71,7,7,11.71,7,17.5S11.71,28,17.5,28S28,23.29,28,17.5S23.29,7,17.5,7z M17.5,25c-4.136,0-7.5-3.364-7.5-7.5    c0-4.136,3.364-7.5,7.5-7.5c4.136,0,7.5,3.364,7.5,7.5C25,21.636,21.636,25,17.5,25z"></path></svg></label><label id="toggle-label-dark" for="darkmode-toggle" tabIndex="-1"><svg xmlns="http://www.w3.org/2000/svg" xmlnsXlink="http://www.w3.org/1999/xlink" version="1.1" id="nightIcon" x="0px" y="0px" viewBox="0 0 100 100" style="enable-background='new 0 0 100 100'" xmlSpace="preserve"><title>Dark mode</title><path d="M96.76,66.458c-0.853-0.852-2.15-1.064-3.23-0.534c-6.063,2.991-12.858,4.571-19.655,4.571  C62.022,70.495,50.88,65.88,42.5,57.5C29.043,44.043,25.658,23.536,34.076,6.47c0.532-1.08,0.318-2.379-0.534-3.23  c-0.851-0.852-2.15-1.064-3.23-0.534c-4.918,2.427-9.375,5.619-13.246,9.491c-9.447,9.447-14.65,22.008-14.65,35.369  c0,13.36,5.203,25.921,14.65,35.368s22.008,14.65,35.368,14.65c13.361,0,25.921-5.203,35.369-14.65  c3.872-3.871,7.064-8.328,9.491-13.246C97.826,68.608,97.611,67.309,96.76,66.458z"></path></svg></label></div></div><div class="center"><div class="page-header"><div class="popover-hint"><h1 class="article-title ">08-1. Memory Address</h1><p class="content-meta ">Aug 26, 2024, 14 min read</p></div></div><article class="popover-hint"><blockquote class="callout" data-callout="info">
<div class="callout-title">
                  <div class="callout-icon"><svg xmlns="http://www.w3.org/2000/svg" width="100%" height="100%" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="10"></circle><line x1="12" y1="16" x2="12" y2="12"></line><line x1="12" y1="8" x2="12.01" y2="8"></line></svg></div>
                  <div class="callout-title-inner"><p>이화여자대학교 컴퓨터공학과 반효경 교수님의 &quot;운영체제 (KOCW)&quot; 강의를 필기한 내용입니다. </p></div>
                  
                </div>
</blockquote>
<blockquote class="callout" data-callout="warning">
<div class="callout-title">
                  <div class="callout-icon"><svg xmlns="http://www.w3.org/2000/svg" width="100%" height="100%" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="m21.73 18-8-14a2 2 0 0 0-3.48 0l-8 14A2 2 0 0 0 4 21h16a2 2 0 0 0 1.73-3Z"></path><line x1="12" y1="9" x2="12" y2="13"></line><line x1="12" y1="17" x2="12.01" y2="17"></line></svg></div>
                  <div class="callout-title-inner"><p>다소 잘못된 내용과 구어적 표현 이 포함되어 있을 수 있습니다. </p></div>
                  
                </div>
</blockquote>
<h2 id="logical-physical-symbolic-address">Logical, Physical, Symbolic Address<a aria-hidden="true" tabindex="-1" href="#logical-physical-symbolic-address" class="internal"> §</a></h2>
<p><img src="../../../../gardens/os/originals/os.bahn.ewha.kocw.net/images/Screen_Shot_2022-09-26_at_9.49.05_AM.png" alt="Screen Shot 2022-09-26 at 9.49.05 AM.png"/></p>
<ul>
<li><em><strong>Logical Address (Virtual Address)</strong></em>: 프로세스 각각이 가지는 가상 주소 공간 속의 주소
<ul>
<li>즉 메모리 전체에 이 프로세스 하나만 올라가있다고 상상했을 때의 주소를 의미한다</li>
<li>따라서 메모리 주소는 0번부터 시작</li>
<li>이제부터는 별다줄로다가 LA라 표현해보자고</li>
</ul>
</li>
<li><em><strong>Physical Address</strong></em>: 실제 메모리의 주소
<ul>
<li>실제 메모리의 주소이기 때문에 하위 주소에는 커널이 들어가고 상위 주소에 유저 프로세스들이 올라가게 된다</li>
<li>얘는 PA 라 표현해보자고</li>
</ul>
</li>
<li><em><strong>Symbolic Address</strong></em> 라는 것은 코드 작성시에의 변수를 의미하는 것
<ul>
<li>즉, 코드에는 메모리 주소가 아닌 사람이 읽을 수 있는 형태의 문자열인 변수를 사용하게 되는데 이것을 Symbolic Address 라고 하는 것</li>
</ul>
</li>
</ul>
<h2 id="address-binding">Address Binding<a aria-hidden="true" tabindex="-1" href="#address-binding" class="internal"> §</a></h2>
<ul>
<li><em><strong>Address Binding</strong></em>: LA 를 PA 로 바꾸는 과정
<ul>
<li>메모리에 접근하기 위해서는 LA 가 아니라 PA 가 필요한데 이를 위해 주소 변환 과정이 필요하게 된다</li>
</ul>
</li>
</ul>
<h3 id="binding-시점에-따른-분류">Binding 시점에 따른 분류<a aria-hidden="true" tabindex="-1" href="#binding-시점에-따른-분류" class="internal"> §</a></h3>
<ul>
<li>Binding 시점에 따라 종류를 세 가지로 나눠볼 수 있다</li>
</ul>
<p><img src="../../../../gardens/os/originals/os.bahn.ewha.kocw.net/images/Screen_Shot_2022-09-26_at_9.57.37_AM.png" alt="Screen Shot 2022-09-26 at 9.57.37 AM.png"/></p>
<ul>
<li><em><strong>Compile Time Binding</strong></em>: 컴파일 시점에 PA 까지 결정되는 것
<ul>
<li>컴파일 시점에는 SA 가 LA 로 바뀌기 때문에 이때의 주소를 PA로 사용한다는 것은</li>
<li>항상 LA와 PA 가 같고</li>
<li>프로세스는 항상 (별도의 조치가 없는 한) PA 0번부터 적재되게 된다</li>
<li>뭐 당연히 현대의 컴퓨터에서는 사용되지 않았지만 옛날에 컴퓨터에서 하나의 프로세스만 작동되던 시절에는 이런 방식의 바인딩을 사용했다더라</li>
<li>LA 와 PA 가 같기 때문에 이러한 코드를 <em><strong>Absolute Code(절대 코드)</strong></em> 라고 부르고 컴파일러는 이것을 생성하게 된다</li>
</ul>
</li>
<li><em><strong>Load Time Binding</strong></em>: 프로그램이 프로세스가 되어 메모리에 적재되는 시점에 PA 를 결정하는 것
<ul>
<li>얘는 위에놈보다 좀 더 합리적이제</li>
<li>메모리 사용 현황은 계속해서 바뀌어서 컴파일 시점에는 메모리의 어느 부분에 적재할지 알기 힘들기 때문에 메모리에 적재할때 LA 와 PA 를 바인딩하자는 개념</li>
<li>이때에는 컴파일러가 <em><strong>Relocatable Code (재배치 가능 코드)</strong></em> 를 생성한다</li>
</ul>
</li>
<li><em><strong>Runtime Binding</strong></em>: Load Time Binding 과 유사하나 최초에 메모리에 적재된 이후에도 새롭게 바인딩이 될 수 있는 방법
<ul>
<li>이것은 이제 프로세스의 Swapping 을 지원하기 위해 나온 것이다</li>
<li>왜냐면 프로세스가 Swap out 되면 디스크로 쫒겨나게 되는데 이후에 다시 Swap in 할 때 기존의 PA 가 아닌 새로운 PA 에 바인딩될 수 있도록 해야 하기 때문</li>
<li>당연히 요즘의 운영체제에서는 이 방법을 사용한다</li>
<li>프로세스가 시작되고 종료되기 전까지 PA 가 계속 바뀔 수 있으므로 주소 변환 과정을 CPU 가 아닌 MMU 라는 별도의 하드웨어를 이용해 처리한다</li>
</ul>
</li>
</ul>
<h3 id="cpu-입장에서">CPU 입장에서<a aria-hidden="true" tabindex="-1" href="#cpu-입장에서" class="internal"> §</a></h3>
<ul>
<li>위 그림을 자세히 보면</li>
<li>코드가 적재되는 위치만 바뀌고 코드에 작성되어 있는 주소는 바뀌지 않잖어</li>
<li>따라서 CPU가 사용하는 (바라보는) 주소는 LA 이다</li>
<li>왜냐하면 코드에 작성되어 있는 주소를 바꾸기 위해서는 컴파일을 새로 해야 되는데 Compile Time Binding 이 아닌 이상 불가능 하기 때문에 코드에 작성되어 있는 주소는 LA 로 놔두고 적재 위치만 바꾸게 되는 것</li>
</ul>
<h2 id="memory-management-unit-mmu">Memory Management Unit (MMU)<a aria-hidden="true" tabindex="-1" href="#memory-management-unit-mmu" class="internal"> §</a></h2>
<p><img src="../../../../gardens/os/originals/os.bahn.ewha.kocw.net/images/Screen_Shot_2022-09-26_at_10.27.52_AM.png" alt="Screen Shot 2022-09-26 at 10.27.52 AM.png"/></p>
<ul>
<li>MMU 는 주소 변환을 해주는 하드웨어 유닛인데</li>
<li>다음과 같은 방식으로 작동한다
<ul>
<li>일단 CPU 가 LA 를 이용해 주소를 달라고 요청</li>
<li>LA 는 무적권 0번부터 시작하기 때문에 LA 가 곧 프로세스 주소 공간의 시작점으로부터의 Offset 을 나타냄 → 프로세스가 적재되어 있는 실제 메모리 상의 시작점의 주소만 알면 여기에 LA 를 더함으로써 PA 를 구할 수 있다
<ul>
<li>이 시작점의 주소는 MMU 내의 <em><strong>Base Register (BA)</strong></em> 혹은 <em><strong>Relocation Register</strong></em> 에 저장된다</li>
</ul>
</li>
<li>PA 를 알아낸 이후에는 여기에 저장되어 있던 것을 읽어 CPU 로 전달</li>
</ul>
</li>
</ul>
<p><img src="../../../../gardens/os/originals/os.bahn.ewha.kocw.net/images/Screen_Shot_2022-09-26_at_10.34.57_AM.png" alt="Screen Shot 2022-09-26 at 10.34.57 AM.png"/></p>
<ul>
<li>위의 그림이 MMU 의 작동 과정을 나타내는 그림인데</li>
<li>MMU가 주소 변환을 할 때에는 LA 가 유효한지를 먼저 검사하게 된다</li>
<li>왜냐면 만약 프로세스의 주소 공간의 크기가 3000일 때 이것보다 큰 LA 요청이 들어오게 된다면 프로세스 바깥의 주소 공간을 참조하게 되는 것 이므로 다른 프로세스의 주소공간에 무단 침입하는 셈이기 때문이다</li>
<li>따라서 MMU 에서는 <em><strong>Limit Register</strong></em> 라는 또 다른 레지스터를 이용해서 프로세스 주소 공간의 크기를 저장해 놓고 이것보다 큰 LA 요청이 들어오면 트랩을 걸어 기각시키게 된다</li>
</ul>
<h2 id="dynamic-loading-overlay">Dynamic Loading, Overlay<a aria-hidden="true" tabindex="-1" href="#dynamic-loading-overlay" class="internal"> §</a></h2>
<ul>
<li>일단 <em><strong>Dynamic Loading</strong></em> 이라는 것은 프로세스의 전체가 메모리에 올라가는 것이 아닌 필요한 부분만 올라가는 기법을 의미한다</li>
<li>이렇게 하는 이유는 당연히 메모리 효율을 올리기 위함 → 프로그램에는 자주 사용되지 않는 오류 처리 루틴이 많이 포함되어 있기 때문에 프로세스 전체를 올리는 것은 자주 사용하지 않는 부분까지 모두 올리는 것이어서 비효율적이다</li>
<li>Dynamic Loading 의 정확한 정의는 OS의 힘을 빌리지 않고 메모리에 동적으로 적재되는 것을 뜻한다
<ul>
<li>현대의 OS 에서는 뒤에 나올 페이징 기법을 이용해서 프로세스를 동적으로 메모리에 올리게 되는데 이것은 Dynamic Loading 이 아님</li>
<li>하지만 이 용어를 딱히 구별해서 사용하지는 않는다 → 정확한 정의와는 무관하게 페이징 기법을 사용하는 것도 Dynamic Loading 이라고 부르긴 한다</li>
</ul>
</li>
<li><em><strong>Overlay</strong></em> 라는 것은 Dynamic Loading 과 유사하지만 용어가 등장한 배경이 좀 다르다
<ul>
<li>일단 Overlay 도 프로세스를 쪼개서 메모리에 올리는 방법이지만</li>
<li>Overlay 는 메모리의 크기가 너무 작아 프로세스 하나조차 올릴 수 없는 시절에 프로그램을 작성할 때 어느부분을 올릴지 수작업으로 프로그래밍하는 방법을 의미한다</li>
<li>하지만 Dynamic Loading 의 경우에는 메모리의 크기는 넉넉하지만 사용율을 높이기 위해 라이브러리의 힘을 빌려서 동적으로 적재하는 것을 일컫는다</li>
</ul>
</li>
</ul>
<h2 id="swapping">Swapping<a aria-hidden="true" tabindex="-1" href="#swapping" class="internal"> §</a></h2>
<p><img src="../../../../gardens/os/originals/os.bahn.ewha.kocw.net/images/Screen_Shot_2022-09-26_at_10.56.46_AM.png" alt="Screen Shot 2022-09-26 at 10.56.46 AM.png"/></p>
<ul>
<li>일단 <em><strong>Swapping</strong></em> 이라는 것은 프로세스 전체를 디스크 등의 Backing store 로 쫒아내는 것을 말한다</li>
<li>앞선 강의에서 잠깐 언급되었던 것 처럼 Swapping 은 중기 스케줄러 (Mid-term Scheduler, Swapper) 에 의해 어떤 놈이 방출될지 결정된다
<ul>
<li>당연히 우선순위가 높은 놈 보다는 낮은 놈을 방출시키는게 좋겠제 → 이것을 Swapper 가 결정하게 되는 것</li>
</ul>
</li>
<li>이 Swapping 은 Runtime Binding 이 필수적이다
<ul>
<li>Compile Time Binding 이나 Load Time Binding 의 경우에는 Swap out 되었어도 원래 위치로 되돌아 와야 하기 때문에 비효율적</li>
<li>Runtime Binding 이 되어야 Swap in 될 때 비어있는 공간으로 쓱 드갈 수 있기 때문에 필수적이다</li>
</ul>
</li>
<li>Swapping 에서는 읽어들여야 할 데이터의 양이 많기 때문에 대부분 Transfer Time 이 차지한다고 한다
<ul>
<li>이놈은 뒤에 디스크 부분에서 배울거라는데</li>
<li>디스크가 데이터를 읽어들일 때는 디스크 헤드가 움직이는 Search Time 하고</li>
<li>데이터를 읽어서 보내는 Transfer Time 이 있는데
<ul>
<li>파일입출력같은 경우에는 Transfer Time 보다는 Search Time 이 더 오래 걸리는 반면</li>
<li>Swapping 의 경우에는 보내야 할 데이터의 양이 많아 Transfer Time 이 더 오래걸린다고 하더라</li>
</ul>
</li>
</ul>
</li>
<li>이놈도 페이징 기법과 연루되면서 용어가 좀 모호하게 쓰인다
<ul>
<li>원래는 프로세스 전체가 디스크로 쫒겨나는 것을 의미하지만</li>
<li>정확한 정의와 다르게 페이징 기법에 따라 페이지가 쫒겨나는 것도 Swapping 이라고들 하더라</li>
</ul>
</li>
</ul>
<h2 id="dynamic-linking">Dynamic Linking<a aria-hidden="true" tabindex="-1" href="#dynamic-linking" class="internal"> §</a></h2>
<ul>
<li>일단 <em><strong>Static Linking</strong></em> 이라는 용어부터 알 필요가 있다
<ul>
<li>gcc 로 컴파일 할때 보면 라이브러리들을 오브젝트 파일로 만들어서 링크시켜주는 과정을 통해 라이브러리 내에 있던 코드가 내 코드에 포함되도록 하자네</li>
<li>이렇게 라이브러리에 있던 코드를 내 코드에 포함시키는 것을 Static Linking 이라고 한다</li>
</ul>
</li>
<li>반면에 <em><strong>Dynamic Linking</strong></em> 은 라이브러리 코드를 내 코드에 포함시키지 않고 필요에 따라 불러오는 것을 의미한다
<ul>
<li>Dynamic Linking 을 하면 라이브러리 코드는 별도의 코드로 존재하고</li>
<li>내가 해당 코드를 사용할 때에는 코드 전체를 가져오는 것이 아니라 해당 코드를 참조할 수 있는 작은 코드 조각 (해당 코드를 가리키는 포인터라고 생각하면 됨 → <em><strong>Stub</strong></em> 이라고 부르더라)을 코드에 넣어서 실행시점에 링크시켜 주는 것을 의미한다</li>
<li>리눅스에서 <code>.so</code> 파일 본적 있제? 이것이 Dynamic Linking 을 위한 코드이다 → Shared Object 의 약자임</li>
<li>윈도우에서는 <code>.dll</code> 파일 본 적 있을텐데 이것이 Dynamic Linking Library 의 약자이다</li>
</ul>
</li>
</ul></article></div><div class="right sidebar"><div class="graph "><h3>Graph View</h3><div class="graph-outer"><div id="graph-container" data-cfg="{&quot;drag&quot;:true,&quot;zoom&quot;:true,&quot;depth&quot;:1,&quot;scale&quot;:1.1,&quot;repelForce&quot;:0.5,&quot;centerForce&quot;:0.3,&quot;linkDistance&quot;:30,&quot;fontSize&quot;:0.6,&quot;opacityScale&quot;:1,&quot;showTags&quot;:true,&quot;removeTags&quot;:[]}"></div><svg version="1.1" id="global-graph-icon" xmlns="http://www.w3.org/2000/svg" xmlnsXlink="http://www.w3.org/1999/xlink" x="0px" y="0px" viewBox="0 0 55 55" fill="currentColor" xmlSpace="preserve"><path d="M49,0c-3.309,0-6,2.691-6,6c0,1.035,0.263,2.009,0.726,2.86l-9.829,9.829C32.542,17.634,30.846,17,29,17
	s-3.542,0.634-4.898,1.688l-7.669-7.669C16.785,10.424,17,9.74,17,9c0-2.206-1.794-4-4-4S9,6.794,9,9s1.794,4,4,4
	c0.74,0,1.424-0.215,2.019-0.567l7.669,7.669C21.634,21.458,21,23.154,21,25s0.634,3.542,1.688,4.897L10.024,42.562
	C8.958,41.595,7.549,41,6,41c-3.309,0-6,2.691-6,6s2.691,6,6,6s6-2.691,6-6c0-1.035-0.263-2.009-0.726-2.86l12.829-12.829
	c1.106,0.86,2.44,1.436,3.898,1.619v10.16c-2.833,0.478-5,2.942-5,5.91c0,3.309,2.691,6,6,6s6-2.691,6-6c0-2.967-2.167-5.431-5-5.91
	v-10.16c1.458-0.183,2.792-0.759,3.898-1.619l7.669,7.669C41.215,39.576,41,40.26,41,41c0,2.206,1.794,4,4,4s4-1.794,4-4
	s-1.794-4-4-4c-0.74,0-1.424,0.215-2.019,0.567l-7.669-7.669C36.366,28.542,37,26.846,37,25s-0.634-3.542-1.688-4.897l9.665-9.665
	C46.042,11.405,47.451,12,49,12c3.309,0,6-2.691,6-6S52.309,0,49,0z M11,9c0-1.103,0.897-2,2-2s2,0.897,2,2s-0.897,2-2,2
	S11,10.103,11,9z M6,51c-2.206,0-4-1.794-4-4s1.794-4,4-4s4,1.794,4,4S8.206,51,6,51z M33,49c0,2.206-1.794,4-4,4s-4-1.794-4-4
	s1.794-4,4-4S33,46.794,33,49z M29,31c-3.309,0-6-2.691-6-6s2.691-6,6-6s6,2.691,6,6S32.309,31,29,31z M47,41c0,1.103-0.897,2-2,2
	s-2-0.897-2-2s0.897-2,2-2S47,39.897,47,41z M49,10c-2.206,0-4-1.794-4-4s1.794-4,4-4s4,1.794,4,4S51.206,10,49,10z"></path></svg></div><div id="global-graph-outer"><div id="global-graph-container" data-cfg="{&quot;drag&quot;:true,&quot;zoom&quot;:true,&quot;depth&quot;:-1,&quot;scale&quot;:0.9,&quot;repelForce&quot;:0.5,&quot;centerForce&quot;:0.3,&quot;linkDistance&quot;:30,&quot;fontSize&quot;:0.6,&quot;opacityScale&quot;:1,&quot;showTags&quot;:true,&quot;removeTags&quot;:[]}"></div></div></div><div class="toc desktop-only"><button type="button" id="toc"><h3>Table of Contents</h3><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="fold"><polyline points="6 9 12 15 18 9"></polyline></svg></button><div id="toc-content"><ul class="overflow"><li class="depth-0"><a href="#logical-physical-symbolic-address" data-for="logical-physical-symbolic-address">Logical, Physical, Symbolic Address</a></li><li class="depth-0"><a href="#address-binding" data-for="address-binding">Address Binding</a></li><li class="depth-1"><a href="#binding-시점에-따른-분류" data-for="binding-시점에-따른-분류">Binding 시점에 따른 분류</a></li><li class="depth-1"><a href="#cpu-입장에서" data-for="cpu-입장에서">CPU 입장에서</a></li><li class="depth-0"><a href="#memory-management-unit-mmu" data-for="memory-management-unit-mmu">Memory Management Unit (MMU)</a></li><li class="depth-0"><a href="#dynamic-loading-overlay" data-for="dynamic-loading-overlay">Dynamic Loading, Overlay</a></li><li class="depth-0"><a href="#swapping" data-for="swapping">Swapping</a></li><li class="depth-0"><a href="#dynamic-linking" data-for="dynamic-linking">Dynamic Linking</a></li></ul></div></div><div class="backlinks "><h3>Backlinks</h3><ul class="overflow"><li><a href="../../../../gardens/os/originals/os.bahn.ewha.kocw.net/(이화여대)-운영체제-강의록" class="internal">(이화여대) 운영체제 강의록</a></li></ul></div></div></div><footer class><hr/><p>Created with <a href="https://quartz.jzhao.xyz/">Quartz v4.1.0</a>, © 2024</p><ul><li><a href="https://github.com/haeramkeem">GitHub</a></li><li><a href="www.linkedin.com/in/haeram-kim-277404220">LinkedIn</a></li><li><a href="mailto:haeram.kim1@gmail.com">Email</a></li></ul></footer></div></body><script type="application/javascript">// quartz/components/scripts/quartz/components/scripts/callout.inline.ts
function toggleCallout() {
  const outerBlock = this.parentElement;
  outerBlock.classList.toggle(`is-collapsed`);
  const collapsed = outerBlock.classList.contains(`is-collapsed`);
  const height = collapsed ? this.scrollHeight : outerBlock.scrollHeight;
  outerBlock.style.maxHeight = height + `px`;
  let current = outerBlock;
  let parent = outerBlock.parentElement;
  while (parent) {
    if (!parent.classList.contains(`callout`)) {
      return;
    }
    const collapsed2 = parent.classList.contains(`is-collapsed`);
    const height2 = collapsed2 ? parent.scrollHeight : parent.scrollHeight + current.scrollHeight;
    parent.style.maxHeight = height2 + `px`;
    current = parent;
    parent = parent.parentElement;
  }
}
function setupCallout() {
  const collapsible = document.getElementsByClassName(
    `callout is-collapsible`
  );
  for (const div of collapsible) {
    const title = div.firstElementChild;
    if (title) {
      title.removeEventListener(`click`, toggleCallout);
      title.addEventListener(`click`, toggleCallout);
      const collapsed = div.classList.contains(`is-collapsed`);
      const height = collapsed ? title.scrollHeight : div.scrollHeight;
      div.style.maxHeight = height + `px`;
    }
  }
}
document.addEventListener(`nav`, setupCallout);
window.addEventListener(`resize`, setupCallout);
</script><script type="module">
          import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.esm.min.mjs';
          const darkMode = document.documentElement.getAttribute('saved-theme') === 'dark'
          mermaid.initialize({
            startOnLoad: false,
            securityLevel: 'loose',
            theme: darkMode ? 'dark' : 'default'
          });
          document.addEventListener('nav', async () => {
            await mermaid.run({
              querySelector: '.mermaid'
            })
          });
          </script><script src="https://cdn.jsdelivr.net/npm/katex@0.16.7/dist/contrib/copy-tex.min.js" type="application/javascript"></script><script src="https://www.googletagmanager.com/gtag/js?id=G-N68CCP1QHG" type="application/javascript"></script><script src="../../../../postscript.js" type="module"></script></html>