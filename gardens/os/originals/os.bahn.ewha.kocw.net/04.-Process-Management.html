<!DOCTYPE html>
<html><head><title>04. Process Management</title><meta charSet="utf-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:title" content="04. Process Management"/><meta property="og:description" content="이화여자대학교 컴퓨터공학과 반효경 교수님의 &amp;quot;운영체제 (KOCW)&amp;quot; 강의를 필기한 내용입니다. 다소 잘못된 내용과 구어적 표현 이 포함되어 있을 수 있습니다. Process Lifecycle § Process Creation § 프로세스는 (Init process 가 아니라면)부모프로세스가 반드시 존재하고, 부모 프로세스를 복제하는 방식으로 자식 프로세스가 생성된다 뭐 init process 는 알다시피 sysvinit 이나 systemd 등이 있겠제 따라서 프로세스는 init process 를 루트로 하는 트리형식의 계층 구조를 형성하게 된다 이렇게 자식을 복제하는 것은 fork() 시스템 콜을 이용해 수행할 수 있다 프로세스 생성이 시스템 콜인 이유는 사용자 프로세스가 직접 하기에는 어려운 작업이고 아마 보안상의 문제도 껴있을거다 자식 프로세스도 당연히 프로세스니까 자원을 할당받을텐데 여기에는 몇가지 정책(모델) 이 존재한다 자원을 부모와 공유하여 운영체제로부터 받지 않는 모델 자원을 부모와 일부만 공유하고 나머지는 운영체제로부터 할당받는 모델 부모와 공유하지 않고 전부 운영체제로부터 할당받는 모델 생각해보면 자식 프로세스는 부모 프로세스와 독립적인 프로세스이기 때문에 자원을 공유하지 않고 운영체제로부터 할당받는게 맞는 거 같지만 UNIX 같은 경우에는 효율성을 위해 일단 부모와 공유하는 방식을 사용한다 뭔소리냐면 fork() 과정에서 부모꺼를 복제한다고 했자네 근데 자원을 복제하면 결국에는 똑같은게 두개가 생길거 아님 → 뭐 프로세스의 Data, Code, Stack 같은게 똑같은게 두개가 생기게 될거아님 이게 좀 낭비같은거야 그래서 UNIX 에서는 일단 자원을 복사하지 않고 공유하고 있다가 부모랑 달라지면 그때 복사를 하는 방식을 이용한다 즉 Lazy copy 라고 말할 수 있는거임 → 이걸 Copy-On-Write (COW) 라고 표현한다 복제하는 과정을 좀 더 자세히 살펴보면 일단 fork() 가 불려지면 운영체제는 PID 를 제외한 부모의 모든 것(뭐 PCB나 바이너리 같은것들 → 앞에서 배운 Process context 에서 PID 만 뺀거라고 생각해도 된다)을 복사한다 그리고 자식 프로세스에게 새로운 주속 공간을 할당한다 하지만 fork() 만 존재한다면 모든 프로세스가 부모랑 같은 작업만 할거 아니냐 → 그래서 (일반적으로는) fork() 이후에 exec() 이라는 시스템 콜이 사용된다 exec() 은 기존에 존재하던 프로세스에 새로운 프로그램을 덮어 씌우는 시스템 콜인데 일반적으로 fork() 이후에 exec() 시스템 콜이 호출되는 식으로 프로그램이 프로세스로 변환된다 따라서 프로세스의 생성은 fork → exec 이 두가지 단계를 거친다고 할 수 있다 물론 저 두 단계는 독립적이어서 fork() 만 해서 부모를 복사하기만 할 수도 있다 Process Execution § 자식 프로세스가 생성되었을 때 부모가 취할 수 있는 동작은 두가지가 있는데 그냥 별개의 프로세스로써 자식이랑 같이 공존하며 실행되거나 자식 프로세스가 종료되어야 진행이 가능한 경우에는 block 을 먹어서 자식이 종료될때까지 기다릴 수도 있다 (wait() 시스템 콜) Process Termination § 프로세스가 자발적으로 종료될 때에는 일단 exit() 시스템 콜을 이용한다 프로그래밍 언어에서 지원하는 라이브러리(뭐 예를 들면 go 의 os 같은 거) 를 통해 exit() 시스템 콜을 호출할 수도 있고 아니면 프로그램 코드가 종료되면 (뭐 마지막 중괄호가 닫히는 등의 main() 함수가 리턴되는 시점) exit() 시스템 콜이 작동되도록 컴파일러가 넣어주는 등의 방법 등 여러가지의 방법이 있지만 어쨋든 자발적으로 프로세스가 종료될때는 exit() 시스템 콜이 무조건 호출된다 exit() 이 호출된 다음에는 자식이 부모에게 output data 를 보내게 되고 프로세스의 각종 자원들이 운영체제한테 반납된다 그럼 자발적이지 않은 경우는 무엇이냐 → 부모 프로세스가 자식의 수행을 종료시키는 경우가 존재한다 뭐 자식이 너무 많은 자원을 먹어서 한계치를 넘어선 경우랄지 자식이 하고 있는 작업이 불필요해진 경우랄지 부모가 종료된 경우랄지 운영체제는 (init process 가 아닌 이상) 부모가 없는 프로세스가 존재하도록 하지 않는다 따라서 부모가 종료될때는 자식을 전부 종료시킨 후에 종료되도록 하는데 자식한테 또 자식이 있을 경우에는 또 그 자식이 종료되는 절차를 밟을 거 아님 그래서 부모가 종료될때는 자식을도 단계적으로 종료되게 된다 Process Syscall § Fork § 이제 이건 fork() 시스템 콜에 대한 C 언어 코드 예제인데 일단 흔히 나올 수 있는 질문 중 하나는 부모 코드에 fork() 가 있는데 부모 코드를 그대로 복제하면 자식 코드에도 fork() 가 있을 것이고 그럼 자식도 fork() 를 해서 자식이 무한대로 생성되는거 아니냐 인데 아니다 앞서 fork() 를 할 때에는 Process context 전체를 복사한다고 했자네 따라서 PC 값도 복사가 되기 때문에 자식 프로세스는 프로그램의 맨 처음부터 실행하는 것이 아니라 fork() 가 호출된 바로 다음 시점부터 실행된다 그럼 PC 값이 복사된다면 부모와 자식은 같은 Physical memory address 의 instruction 을 실행하게 될까 그것도 아니다 왜냐면 PC 에 들어가는 값은 Virtual memory address 이기 때문에 PC 값이 같긴 하지만 실제로 참조하는 Address space 는 다르고 따라서 다른 Physical memory address 를 참조하게 된다 Physical memory address 에 대해서 CPU 는 알지 못한다 → CPU 가 사용하는 주소는 전부 Logical (뭐 Virtual address랑 거의 같다고 재철소장님이 그랬으니까) 이고 이걸 Physical address 로 바꾸는 건 CPU 가 아니라 Memory Management Module 이 BASE 랑 LIMIT 레지스터 값을 이용해 수행한다 참고 Difference between program counter in the executable and program counter in the main memory Does the program counter generate the virtual address or a physical address in a cpu? 부모와 자식이 코드가 동일하다면 어떻게 다른 작업을 하도록 할 수 있을 까? C 언어에 구현되어 있는 fork() 함수는 호출했을 때에 PID 값을 반환하도록 되어 있는데 생각해보면 호출된 이후에는 부모와 자식 이렇게 프로세스가 두개가 생기므로 fork() 함수는 각 프로세스에게 두번 PID 값을 반환한다고 생각할 수 있다 근데 이때 부모 프로세스에게는 양수 정수값을 반환하는 방식으로 생성된 자식 프로세스의 PID 값을 반환해주고 자식 프로세스에게는 0을 반환해준다 이걸 이용해서 하나의 코드로 부모와 자식에게 다른 일을 시킬 수 있다 Exec § exec() 시스템 콜은 위에서 말한 것처럼 새로운 프로그램으로 현재 프로세스를 덮어씌우는 것을 수행한다 그래서 C 언어에서는 이 시스템 콜을 위해 execlp() 라는 함수를 제공해주는데 뭐 문법은 위에 사진 보던가 너가 찾아봐라 3번째 인자부터 해당 프로그램의 Args 들이 들어가는데 마지막 인자는 null string 을 넣어서 닫아줘야 한다네 중요한건 exec() 시스템 콜을 호출하고 나면 새로운 프로그램이기 때문에 main() 함수의 맨 첫번째 줄부터 실행하게 된다 어찌보면 당연한 얘기지 → 프로그램이 새로 프로세스가 됐는데 당연히 Process context 는 없는게 맞지 다음은 exec() 을 실행하고 난 뒤에는 원래의 프로그램으로 되돌아오지는 못한다는 거다 이것도 당연한 얘기다 → 기존의 프로세스가 새로운 프로그램으로 덮어씌워졌으니까 원래꺼는 없어지고 되돌아오지도 못하는게 인지상정 마지막으로는 fork() 와 exec() 은 별개의 시스템 콜이기 때문에 fork() 없이도 exec() 을 호출하는게 가능하다는 거다 따라서 이때에는 자식이 생기는 방식이 아니라 그냥 나 자신이 새로 태어나게 된다 Wait § wait() 은 별거 없다 그냥 부모가 자식 끝날때까지 block 되어 기다리게 하는 시스템 콜이 wait() 이다 그래서 wait() 이 호출되면 커널은 해당 프로세스를 block 시켰다가 해당 프로세스의 자식 프로세스가 모두 종료되면 다시 ready 로 바꾼다 위 그림은 그냥 예제고 → 읽어보면 걍 별거 없다 wait() 을 이용한다고 할 수 있는 프로그램이 Shell 프로그램이다 결국에는 쉘의 경우에도 입력한 프로그램을 시키는 것이기 때문에 해당 프로그램을 자식 프로세스호 실행시키고 wait 하다가 끝나면 다시 커서를 깜빡이게 하는 방식으로 활용한다."/><meta property="og:image" content="https://mdg.haeramk.im/static/og-image.png"/><meta property="og:width" content="1200"/><meta property="og:height" content="675"/><link rel="icon" href="../../../../static/icon.png"/><meta name="description" content="이화여자대학교 컴퓨터공학과 반효경 교수님의 &amp;quot;운영체제 (KOCW)&amp;quot; 강의를 필기한 내용입니다. 다소 잘못된 내용과 구어적 표현 이 포함되어 있을 수 있습니다. Process Lifecycle § Process Creation § 프로세스는 (Init process 가 아니라면)부모프로세스가 반드시 존재하고, 부모 프로세스를 복제하는 방식으로 자식 프로세스가 생성된다 뭐 init process 는 알다시피 sysvinit 이나 systemd 등이 있겠제 따라서 프로세스는 init process 를 루트로 하는 트리형식의 계층 구조를 형성하게 된다 이렇게 자식을 복제하는 것은 fork() 시스템 콜을 이용해 수행할 수 있다 프로세스 생성이 시스템 콜인 이유는 사용자 프로세스가 직접 하기에는 어려운 작업이고 아마 보안상의 문제도 껴있을거다 자식 프로세스도 당연히 프로세스니까 자원을 할당받을텐데 여기에는 몇가지 정책(모델) 이 존재한다 자원을 부모와 공유하여 운영체제로부터 받지 않는 모델 자원을 부모와 일부만 공유하고 나머지는 운영체제로부터 할당받는 모델 부모와 공유하지 않고 전부 운영체제로부터 할당받는 모델 생각해보면 자식 프로세스는 부모 프로세스와 독립적인 프로세스이기 때문에 자원을 공유하지 않고 운영체제로부터 할당받는게 맞는 거 같지만 UNIX 같은 경우에는 효율성을 위해 일단 부모와 공유하는 방식을 사용한다 뭔소리냐면 fork() 과정에서 부모꺼를 복제한다고 했자네 근데 자원을 복제하면 결국에는 똑같은게 두개가 생길거 아님 → 뭐 프로세스의 Data, Code, Stack 같은게 똑같은게 두개가 생기게 될거아님 이게 좀 낭비같은거야 그래서 UNIX 에서는 일단 자원을 복사하지 않고 공유하고 있다가 부모랑 달라지면 그때 복사를 하는 방식을 이용한다 즉 Lazy copy 라고 말할 수 있는거임 → 이걸 Copy-On-Write (COW) 라고 표현한다 복제하는 과정을 좀 더 자세히 살펴보면 일단 fork() 가 불려지면 운영체제는 PID 를 제외한 부모의 모든 것(뭐 PCB나 바이너리 같은것들 → 앞에서 배운 Process context 에서 PID 만 뺀거라고 생각해도 된다)을 복사한다 그리고 자식 프로세스에게 새로운 주속 공간을 할당한다 하지만 fork() 만 존재한다면 모든 프로세스가 부모랑 같은 작업만 할거 아니냐 → 그래서 (일반적으로는) fork() 이후에 exec() 이라는 시스템 콜이 사용된다 exec() 은 기존에 존재하던 프로세스에 새로운 프로그램을 덮어 씌우는 시스템 콜인데 일반적으로 fork() 이후에 exec() 시스템 콜이 호출되는 식으로 프로그램이 프로세스로 변환된다 따라서 프로세스의 생성은 fork → exec 이 두가지 단계를 거친다고 할 수 있다 물론 저 두 단계는 독립적이어서 fork() 만 해서 부모를 복사하기만 할 수도 있다 Process Execution § 자식 프로세스가 생성되었을 때 부모가 취할 수 있는 동작은 두가지가 있는데 그냥 별개의 프로세스로써 자식이랑 같이 공존하며 실행되거나 자식 프로세스가 종료되어야 진행이 가능한 경우에는 block 을 먹어서 자식이 종료될때까지 기다릴 수도 있다 (wait() 시스템 콜) Process Termination § 프로세스가 자발적으로 종료될 때에는 일단 exit() 시스템 콜을 이용한다 프로그래밍 언어에서 지원하는 라이브러리(뭐 예를 들면 go 의 os 같은 거) 를 통해 exit() 시스템 콜을 호출할 수도 있고 아니면 프로그램 코드가 종료되면 (뭐 마지막 중괄호가 닫히는 등의 main() 함수가 리턴되는 시점) exit() 시스템 콜이 작동되도록 컴파일러가 넣어주는 등의 방법 등 여러가지의 방법이 있지만 어쨋든 자발적으로 프로세스가 종료될때는 exit() 시스템 콜이 무조건 호출된다 exit() 이 호출된 다음에는 자식이 부모에게 output data 를 보내게 되고 프로세스의 각종 자원들이 운영체제한테 반납된다 그럼 자발적이지 않은 경우는 무엇이냐 → 부모 프로세스가 자식의 수행을 종료시키는 경우가 존재한다 뭐 자식이 너무 많은 자원을 먹어서 한계치를 넘어선 경우랄지 자식이 하고 있는 작업이 불필요해진 경우랄지 부모가 종료된 경우랄지 운영체제는 (init process 가 아닌 이상) 부모가 없는 프로세스가 존재하도록 하지 않는다 따라서 부모가 종료될때는 자식을 전부 종료시킨 후에 종료되도록 하는데 자식한테 또 자식이 있을 경우에는 또 그 자식이 종료되는 절차를 밟을 거 아님 그래서 부모가 종료될때는 자식을도 단계적으로 종료되게 된다 Process Syscall § Fork § 이제 이건 fork() 시스템 콜에 대한 C 언어 코드 예제인데 일단 흔히 나올 수 있는 질문 중 하나는 부모 코드에 fork() 가 있는데 부모 코드를 그대로 복제하면 자식 코드에도 fork() 가 있을 것이고 그럼 자식도 fork() 를 해서 자식이 무한대로 생성되는거 아니냐 인데 아니다 앞서 fork() 를 할 때에는 Process context 전체를 복사한다고 했자네 따라서 PC 값도 복사가 되기 때문에 자식 프로세스는 프로그램의 맨 처음부터 실행하는 것이 아니라 fork() 가 호출된 바로 다음 시점부터 실행된다 그럼 PC 값이 복사된다면 부모와 자식은 같은 Physical memory address 의 instruction 을 실행하게 될까 그것도 아니다 왜냐면 PC 에 들어가는 값은 Virtual memory address 이기 때문에 PC 값이 같긴 하지만 실제로 참조하는 Address space 는 다르고 따라서 다른 Physical memory address 를 참조하게 된다 Physical memory address 에 대해서 CPU 는 알지 못한다 → CPU 가 사용하는 주소는 전부 Logical (뭐 Virtual address랑 거의 같다고 재철소장님이 그랬으니까) 이고 이걸 Physical address 로 바꾸는 건 CPU 가 아니라 Memory Management Module 이 BASE 랑 LIMIT 레지스터 값을 이용해 수행한다 참고 Difference between program counter in the executable and program counter in the main memory Does the program counter generate the virtual address or a physical address in a cpu? 부모와 자식이 코드가 동일하다면 어떻게 다른 작업을 하도록 할 수 있을 까? C 언어에 구현되어 있는 fork() 함수는 호출했을 때에 PID 값을 반환하도록 되어 있는데 생각해보면 호출된 이후에는 부모와 자식 이렇게 프로세스가 두개가 생기므로 fork() 함수는 각 프로세스에게 두번 PID 값을 반환한다고 생각할 수 있다 근데 이때 부모 프로세스에게는 양수 정수값을 반환하는 방식으로 생성된 자식 프로세스의 PID 값을 반환해주고 자식 프로세스에게는 0을 반환해준다 이걸 이용해서 하나의 코드로 부모와 자식에게 다른 일을 시킬 수 있다 Exec § exec() 시스템 콜은 위에서 말한 것처럼 새로운 프로그램으로 현재 프로세스를 덮어씌우는 것을 수행한다 그래서 C 언어에서는 이 시스템 콜을 위해 execlp() 라는 함수를 제공해주는데 뭐 문법은 위에 사진 보던가 너가 찾아봐라 3번째 인자부터 해당 프로그램의 Args 들이 들어가는데 마지막 인자는 null string 을 넣어서 닫아줘야 한다네 중요한건 exec() 시스템 콜을 호출하고 나면 새로운 프로그램이기 때문에 main() 함수의 맨 첫번째 줄부터 실행하게 된다 어찌보면 당연한 얘기지 → 프로그램이 새로 프로세스가 됐는데 당연히 Process context 는 없는게 맞지 다음은 exec() 을 실행하고 난 뒤에는 원래의 프로그램으로 되돌아오지는 못한다는 거다 이것도 당연한 얘기다 → 기존의 프로세스가 새로운 프로그램으로 덮어씌워졌으니까 원래꺼는 없어지고 되돌아오지도 못하는게 인지상정 마지막으로는 fork() 와 exec() 은 별개의 시스템 콜이기 때문에 fork() 없이도 exec() 을 호출하는게 가능하다는 거다 따라서 이때에는 자식이 생기는 방식이 아니라 그냥 나 자신이 새로 태어나게 된다 Wait § wait() 은 별거 없다 그냥 부모가 자식 끝날때까지 block 되어 기다리게 하는 시스템 콜이 wait() 이다 그래서 wait() 이 호출되면 커널은 해당 프로세스를 block 시켰다가 해당 프로세스의 자식 프로세스가 모두 종료되면 다시 ready 로 바꾼다 위 그림은 그냥 예제고 → 읽어보면 걍 별거 없다 wait() 을 이용한다고 할 수 있는 프로그램이 Shell 프로그램이다 결국에는 쉘의 경우에도 입력한 프로그램을 시키는 것이기 때문에 해당 프로그램을 자식 프로세스호 실행시키고 wait 하다가 끝나면 다시 커서를 깜빡이게 하는 방식으로 활용한다."/><meta name="generator" content="Quartz"/><link rel="preconnect" href="https://fonts.googleapis.com"/><link rel="preconnect" href="https://fonts.gstatic.com"/><link href="../../../../index.css" rel="stylesheet" type="text/css" spa-preserve/><link href="https://cdn.jsdelivr.net/npm/katex@0.16.0/dist/katex.min.css" rel="stylesheet" type="text/css" spa-preserve/><link href="https://fonts.googleapis.com/css2?family=IBM Plex Mono&amp;family=Gowun Batang:wght@400;700&amp;family=Gowun Dodum:ital,wght@0,400;0,600;1,400;1,600&amp;display=swap" rel="stylesheet" type="text/css" spa-preserve/><script src="../../../../prescript.js" type="application/javascript" spa-preserve></script><script type="application/javascript" spa-preserve>const fetchData = fetch(`../../../../static/contentIndex.json`).then(data => data.json())</script></head><body data-slug="gardens/os/originals/os.bahn.ewha.kocw.net/04.-Process-Management"><div id="quartz-root" class="page"><div id="quartz-body"><div class="left sidebar"><h1 class="page-title "><a href="../../../..">Madison Digital Garden</a></h1><div class="spacer mobile-only"></div><div class="search "><div id="search-icon"><p>Search</p><div></div><svg tabIndex="0" aria-labelledby="title desc" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 19.9 19.7"><title id="title">Search</title><desc id="desc">Search</desc><g class="search-path" fill="none"><path stroke-linecap="square" d="M18.5 18.3l-5.4-5.4"></path><circle cx="8" cy="8" r="7"></circle></g></svg></div><div id="search-container"><div id="search-space"><input autocomplete="off" id="search-bar" name="search" type="text" aria-label="Search for something" placeholder="Search for something"/><div id="results-container"></div></div></div></div><div class="darkmode "><input class="toggle" id="darkmode-toggle" type="checkbox" tabIndex="-1"/><label id="toggle-label-light" for="darkmode-toggle" tabIndex="-1"><svg xmlns="http://www.w3.org/2000/svg" xmlnsXlink="http://www.w3.org/1999/xlink" version="1.1" id="dayIcon" x="0px" y="0px" viewBox="0 0 35 35" style="enable-background:new 0 0 35 35;" xmlSpace="preserve"><title>Light mode</title><path d="M6,17.5C6,16.672,5.328,16,4.5,16h-3C0.672,16,0,16.672,0,17.5    S0.672,19,1.5,19h3C5.328,19,6,18.328,6,17.5z M7.5,26c-0.414,0-0.789,0.168-1.061,0.439l-2,2C4.168,28.711,4,29.086,4,29.5    C4,30.328,4.671,31,5.5,31c0.414,0,0.789-0.168,1.06-0.44l2-2C8.832,28.289,9,27.914,9,27.5C9,26.672,8.329,26,7.5,26z M17.5,6    C18.329,6,19,5.328,19,4.5v-3C19,0.672,18.329,0,17.5,0S16,0.672,16,1.5v3C16,5.328,16.671,6,17.5,6z M27.5,9    c0.414,0,0.789-0.168,1.06-0.439l2-2C30.832,6.289,31,5.914,31,5.5C31,4.672,30.329,4,29.5,4c-0.414,0-0.789,0.168-1.061,0.44    l-2,2C26.168,6.711,26,7.086,26,7.5C26,8.328,26.671,9,27.5,9z M6.439,8.561C6.711,8.832,7.086,9,7.5,9C8.328,9,9,8.328,9,7.5    c0-0.414-0.168-0.789-0.439-1.061l-2-2C6.289,4.168,5.914,4,5.5,4C4.672,4,4,4.672,4,5.5c0,0.414,0.168,0.789,0.439,1.06    L6.439,8.561z M33.5,16h-3c-0.828,0-1.5,0.672-1.5,1.5s0.672,1.5,1.5,1.5h3c0.828,0,1.5-0.672,1.5-1.5S34.328,16,33.5,16z     M28.561,26.439C28.289,26.168,27.914,26,27.5,26c-0.828,0-1.5,0.672-1.5,1.5c0,0.414,0.168,0.789,0.439,1.06l2,2    C28.711,30.832,29.086,31,29.5,31c0.828,0,1.5-0.672,1.5-1.5c0-0.414-0.168-0.789-0.439-1.061L28.561,26.439z M17.5,29    c-0.829,0-1.5,0.672-1.5,1.5v3c0,0.828,0.671,1.5,1.5,1.5s1.5-0.672,1.5-1.5v-3C19,29.672,18.329,29,17.5,29z M17.5,7    C11.71,7,7,11.71,7,17.5S11.71,28,17.5,28S28,23.29,28,17.5S23.29,7,17.5,7z M17.5,25c-4.136,0-7.5-3.364-7.5-7.5    c0-4.136,3.364-7.5,7.5-7.5c4.136,0,7.5,3.364,7.5,7.5C25,21.636,21.636,25,17.5,25z"></path></svg></label><label id="toggle-label-dark" for="darkmode-toggle" tabIndex="-1"><svg xmlns="http://www.w3.org/2000/svg" xmlnsXlink="http://www.w3.org/1999/xlink" version="1.1" id="nightIcon" x="0px" y="0px" viewBox="0 0 100 100" style="enable-background='new 0 0 100 100'" xmlSpace="preserve"><title>Dark mode</title><path d="M96.76,66.458c-0.853-0.852-2.15-1.064-3.23-0.534c-6.063,2.991-12.858,4.571-19.655,4.571  C62.022,70.495,50.88,65.88,42.5,57.5C29.043,44.043,25.658,23.536,34.076,6.47c0.532-1.08,0.318-2.379-0.534-3.23  c-0.851-0.852-2.15-1.064-3.23-0.534c-4.918,2.427-9.375,5.619-13.246,9.491c-9.447,9.447-14.65,22.008-14.65,35.369  c0,13.36,5.203,25.921,14.65,35.368s22.008,14.65,35.368,14.65c13.361,0,25.921-5.203,35.369-14.65  c3.872-3.871,7.064-8.328,9.491-13.246C97.826,68.608,97.611,67.309,96.76,66.458z"></path></svg></label></div></div><div class="center"><div class="page-header"><div class="popover-hint"><h1 class="article-title ">04. Process Management</h1><p class="content-meta ">Aug 21, 2024, 16 min read</p></div></div><article class="popover-hint"><blockquote class="callout" data-callout="info">
<div class="callout-title">
                  <div class="callout-icon"><svg xmlns="http://www.w3.org/2000/svg" width="100%" height="100%" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="10"></circle><line x1="12" y1="16" x2="12" y2="12"></line><line x1="12" y1="8" x2="12.01" y2="8"></line></svg></div>
                  <div class="callout-title-inner"><p>이화여자대학교 컴퓨터공학과 반효경 교수님의 &quot;운영체제 (KOCW)&quot; 강의를 필기한 내용입니다. </p></div>
                  
                </div>
</blockquote>
<blockquote class="callout" data-callout="warning">
<div class="callout-title">
                  <div class="callout-icon"><svg xmlns="http://www.w3.org/2000/svg" width="100%" height="100%" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="m21.73 18-8-14a2 2 0 0 0-3.48 0l-8 14A2 2 0 0 0 4 21h16a2 2 0 0 0 1.73-3Z"></path><line x1="12" y1="9" x2="12" y2="13"></line><line x1="12" y1="17" x2="12.01" y2="17"></line></svg></div>
                  <div class="callout-title-inner"><p>다소 잘못된 내용과 구어적 표현 이 포함되어 있을 수 있습니다. </p></div>
                  
                </div>
</blockquote>
<h2 id="process-lifecycle">Process Lifecycle<a aria-hidden="true" tabindex="-1" href="#process-lifecycle" class="internal"> §</a></h2>
<h3 id="process-creation">Process Creation<a aria-hidden="true" tabindex="-1" href="#process-creation" class="internal"> §</a></h3>
<ul>
<li>프로세스는 (Init process 가 아니라면)부모프로세스가 반드시 존재하고, 부모 프로세스를 복제하는 방식으로 자식 프로세스가 생성된다
<ul>
<li>뭐 init process 는 알다시피 <code>sysvinit</code> 이나 <code>systemd</code> 등이 있겠제</li>
<li>따라서 프로세스는 init process 를 루트로 하는 트리형식의 계층 구조를 형성하게 된다</li>
<li>이렇게 자식을 복제하는 것은 <code>fork()</code> 시스템 콜을 이용해 수행할 수 있다</li>
<li>프로세스 생성이 시스템 콜인 이유는 사용자 프로세스가 직접 하기에는 어려운 작업이고 아마 보안상의 문제도 껴있을거다</li>
</ul>
</li>
<li>자식 프로세스도 당연히 프로세스니까 자원을 할당받을텐데 여기에는 몇가지 정책(모델) 이 존재한다
<ol>
<li>자원을 부모와 공유하여 운영체제로부터 받지 않는 모델</li>
<li>자원을 부모와 일부만 공유하고 나머지는 운영체제로부터 할당받는 모델</li>
<li>부모와 공유하지 않고 전부 운영체제로부터 할당받는 모델</li>
</ol>
<ul>
<li>생각해보면 자식 프로세스는 부모 프로세스와 독립적인 프로세스이기 때문에 자원을 공유하지 않고 운영체제로부터 할당받는게 맞는 거 같지만</li>
<li>UNIX 같은 경우에는 효율성을 위해 일단 부모와 공유하는 방식을 사용한다
<ul>
<li>뭔소리냐면</li>
<li><code>fork()</code> 과정에서 부모꺼를 복제한다고 했자네</li>
<li>근데 자원을 복제하면 결국에는 똑같은게 두개가 생길거 아님 → 뭐 프로세스의 Data, Code, Stack 같은게 똑같은게 두개가 생기게 될거아님</li>
<li>이게 좀 낭비같은거야</li>
<li>그래서 UNIX 에서는 일단 자원을 복사하지 않고 공유하고 있다가 부모랑 달라지면 그때 복사를 하는 방식을 이용한다</li>
<li>즉 Lazy copy 라고 말할 수 있는거임 → 이걸 <em><strong>Copy-On-Write (COW)</strong></em> 라고 표현한다</li>
</ul>
</li>
</ul>
</li>
<li>복제하는 과정을 좀 더 자세히 살펴보면
<ol>
<li>일단 <code>fork()</code> 가 불려지면 운영체제는 PID 를 제외한 부모의 모든 것(뭐 PCB나 바이너리 같은것들 → 앞에서 배운 Process context 에서 PID 만 뺀거라고 생각해도 된다)을 복사한다</li>
<li>그리고 자식 프로세스에게 새로운 주속 공간을 할당한다</li>
</ol>
</li>
<li>하지만 <code>fork()</code> 만 존재한다면 모든 프로세스가 부모랑 같은 작업만 할거 아니냐 → 그래서 (일반적으로는) <code>fork()</code> 이후에 <code>exec()</code> 이라는 시스템 콜이 사용된다
<ul>
<li><code>exec()</code> 은 기존에 존재하던 프로세스에 새로운 프로그램을 덮어 씌우는 시스템 콜인데</li>
<li>일반적으로 <code>fork()</code> 이후에 <code>exec()</code> 시스템 콜이 호출되는 식으로 프로그램이 프로세스로 변환된다</li>
<li>따라서 프로세스의 생성은 fork → exec 이 두가지 단계를 거친다고 할 수 있다</li>
<li>물론 저 두 단계는 독립적이어서 <code>fork()</code> 만 해서 부모를 복사하기만 할 수도 있다</li>
</ul>
</li>
</ul>
<h3 id="process-execution">Process Execution<a aria-hidden="true" tabindex="-1" href="#process-execution" class="internal"> §</a></h3>
<ul>
<li>자식 프로세스가 생성되었을 때 부모가 취할 수 있는 동작은 두가지가 있는데
<ol>
<li>그냥 별개의 프로세스로써 자식이랑 같이 공존하며 실행되거나</li>
<li>자식 프로세스가 종료되어야 진행이 가능한 경우에는 block 을 먹어서 자식이 종료될때까지 기다릴 수도 있다 (<code>wait()</code> 시스템 콜)</li>
</ol>
</li>
</ul>
<h3 id="process-termination">Process Termination<a aria-hidden="true" tabindex="-1" href="#process-termination" class="internal"> §</a></h3>
<ul>
<li>프로세스가 자발적으로 종료될 때에는 일단 <code>exit()</code> 시스템 콜을 이용한다
<ul>
<li>프로그래밍 언어에서 지원하는 라이브러리(뭐 예를 들면 go 의 <code>os</code> 같은 거) 를 통해 <code>exit()</code> 시스템 콜을 호출할 수도 있고</li>
<li>아니면 프로그램 코드가 종료되면 (뭐 마지막 중괄호가 닫히는 등의 <code>main()</code> 함수가 리턴되는 시점) <code>exit()</code> 시스템 콜이 작동되도록 컴파일러가 넣어주는 등의 방법 등</li>
<li>여러가지의 방법이 있지만 어쨋든 자발적으로 프로세스가 종료될때는 <code>exit()</code> 시스템 콜이 무조건 호출된다</li>
<li><code>exit()</code> 이 호출된 다음에는 자식이 부모에게 output data 를 보내게 되고</li>
<li>프로세스의 각종 자원들이 운영체제한테 반납된다</li>
</ul>
</li>
<li>그럼 자발적이지 않은 경우는 무엇이냐 → 부모 프로세스가 자식의 수행을 종료시키는 경우가 존재한다
<ul>
<li>뭐 자식이 너무 많은 자원을 먹어서 한계치를 넘어선 경우랄지</li>
<li>자식이 하고 있는 작업이 불필요해진 경우랄지</li>
<li>부모가 종료된 경우랄지
<ul>
<li>운영체제는 (init process 가 아닌 이상) 부모가 없는 프로세스가 존재하도록 하지 않는다</li>
<li>따라서 부모가 종료될때는 자식을 전부 종료시킨 후에 종료되도록 하는데</li>
<li>자식한테 또 자식이 있을 경우에는 또 그 자식이 종료되는 절차를 밟을 거 아님</li>
<li>그래서 부모가 종료될때는 자식을도 단계적으로 종료되게 된다</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="process-syscall">Process Syscall<a aria-hidden="true" tabindex="-1" href="#process-syscall" class="internal"> §</a></h2>
<h3 id="fork">Fork<a aria-hidden="true" tabindex="-1" href="#fork" class="internal"> §</a></h3>
<p><img src="../../../../gardens/os/originals/os.bahn.ewha.kocw.net/images/Screen_Shot_2022-07-24_at_9.03.01_PM.png" alt="Screen Shot 2022-07-24 at 9.03.01 PM.png"/></p>
<ul>
<li>이제 이건 <code>fork()</code> 시스템 콜에 대한 C 언어 코드 예제인데</li>
<li>일단 흔히 나올 수 있는 질문 중 하나는 부모 코드에 <code>fork()</code> 가 있는데 부모 코드를 그대로 복제하면 자식 코드에도 <code>fork()</code> 가 있을 것이고 그럼 자식도 <code>fork()</code> 를 해서 자식이 무한대로 생성되는거 아니냐 인데
<ul>
<li>아니다</li>
<li>앞서 <code>fork()</code> 를 할 때에는 Process context 전체를 복사한다고 했자네</li>
<li>따라서 PC 값도 복사가 되기 때문에 자식 프로세스는 프로그램의 맨 처음부터 실행하는 것이 아니라 <code>fork()</code> 가 호출된 바로 다음 시점부터 실행된다</li>
</ul>
</li>
<li>그럼 PC 값이 복사된다면 부모와 자식은 같은 Physical memory address 의 instruction 을 실행하게 될까
<ul>
<li>그것도 아니다</li>
<li>왜냐면 PC 에 들어가는 값은 Virtual memory address 이기 때문에 PC 값이 같긴 하지만 실제로 참조하는 Address space 는 다르고 따라서 다른 Physical memory address 를 참조하게 된다</li>
<li>Physical memory address 에 대해서 CPU 는 알지 못한다 → CPU 가 사용하는 주소는 전부 Logical (뭐 Virtual address랑 거의 같다고 재철소장님이 그랬으니까) 이고 이걸 Physical address 로 바꾸는 건 CPU 가 아니라 Memory Management Module 이 BASE 랑 LIMIT 레지스터 값을 이용해 수행한다</li>
<li>참고
<ul>
<li><a href="https://stackoverflow.com/a/35519586" class="external">Difference between program counter in the executable and program counter in the main memory</a></li>
<li><a href="https://qr.ae/pvMrgG" class="external">Does the program counter generate the virtual address or a physical address in a cpu?</a></li>
</ul>
</li>
</ul>
</li>
<li>부모와 자식이 코드가 동일하다면 어떻게 다른 작업을 하도록 할 수 있을 까?
<ul>
<li>C 언어에 구현되어 있는 <code>fork()</code> 함수는 호출했을 때에 PID 값을 반환하도록 되어 있는데</li>
<li>생각해보면 호출된 이후에는 부모와 자식 이렇게 프로세스가 두개가 생기므로 <code>fork()</code> 함수는 각 프로세스에게 두번 PID 값을 반환한다고 생각할 수 있다</li>
<li>근데 이때 부모 프로세스에게는 양수 정수값을 반환하는 방식으로 생성된 자식 프로세스의 PID 값을 반환해주고</li>
<li>자식 프로세스에게는 0을 반환해준다</li>
<li>이걸 이용해서 하나의 코드로 부모와 자식에게 다른 일을 시킬 수 있다</li>
</ul>
</li>
</ul>
<h3 id="exec">Exec<a aria-hidden="true" tabindex="-1" href="#exec" class="internal"> §</a></h3>
<p><img src="../../../../gardens/os/originals/os.bahn.ewha.kocw.net/images/Screen_Shot_2022-07-24_at_10.10.57_PM.png" alt="Screen Shot 2022-07-24 at 10.10.57 PM.png"/></p>
<ul>
<li><code>exec()</code> 시스템 콜은 위에서 말한 것처럼 새로운 프로그램으로 현재 프로세스를 덮어씌우는 것을 수행한다</li>
<li>그래서 C 언어에서는 이 시스템 콜을 위해 <code>execlp()</code> 라는 함수를 제공해주는데</li>
<li>뭐 문법은 위에 사진 보던가 너가 찾아봐라
<ul>
<li>3번째 인자부터 해당 프로그램의 Args 들이 들어가는데</li>
<li>마지막 인자는 null string 을 넣어서 닫아줘야 한다네</li>
</ul>
</li>
<li>중요한건 <code>exec()</code> 시스템 콜을 호출하고 나면 새로운 프로그램이기 때문에 <code>main()</code> 함수의 맨 첫번째 줄부터 실행하게 된다
<ul>
<li>어찌보면 당연한 얘기지 → 프로그램이 새로 프로세스가 됐는데 당연히 Process context 는 없는게 맞지</li>
</ul>
</li>
<li>다음은 <code>exec()</code> 을 실행하고 난 뒤에는 원래의 프로그램으로 되돌아오지는 못한다는 거다
<ul>
<li>이것도 당연한 얘기다 → 기존의 프로세스가 새로운 프로그램으로 덮어씌워졌으니까 원래꺼는 없어지고 되돌아오지도 못하는게 인지상정</li>
</ul>
</li>
<li>마지막으로는 <code>fork()</code> 와 <code>exec()</code> 은 별개의 시스템 콜이기 때문에 <code>fork()</code> 없이도 <code>exec()</code> 을 호출하는게 가능하다는 거다
<ul>
<li>따라서 이때에는 자식이 생기는 방식이 아니라 그냥 나 자신이 새로 태어나게 된다</li>
</ul>
</li>
</ul>
<h3 id="wait">Wait<a aria-hidden="true" tabindex="-1" href="#wait" class="internal"> §</a></h3>
<p><img src="../../../../gardens/os/originals/os.bahn.ewha.kocw.net/images/Screen_Shot_2022-07-24_at_10.00.26_PM.png" alt="Screen Shot 2022-07-24 at 10.00.26 PM.png"/></p>
<ul>
<li><code>wait()</code> 은 별거 없다</li>
<li>그냥 부모가 자식 끝날때까지 block 되어 기다리게 하는 시스템 콜이 <code>wait()</code> 이다
<ul>
<li>그래서 <code>wait()</code> 이 호출되면 커널은 해당 프로세스를 block 시켰다가</li>
<li>해당 프로세스의 자식 프로세스가 모두 종료되면 다시 ready 로 바꾼다</li>
</ul>
</li>
<li>위 그림은 그냥 예제고 → 읽어보면 걍 별거 없다</li>
<li><code>wait()</code> 을 이용한다고 할 수 있는 프로그램이 Shell 프로그램이다
<ul>
<li>결국에는 쉘의 경우에도 입력한 프로그램을 시키는 것이기 때문에 해당 프로그램을 자식 프로세스호 실행시키고 wait 하다가 끝나면 다시 커서를 깜빡이게 하는 방식으로 활용한다.</li>
</ul>
</li>
</ul>
<h2 id="inter-process-conmunication-ipc">Inter Process Conmunication (IPC)<a aria-hidden="true" tabindex="-1" href="#inter-process-conmunication-ipc" class="internal"> §</a></h2>
<ul>
<li><em><strong>Independent Process</strong></em>: 프로세스는 기본적으로 각자 독립적으로 작동하고 다른 프로세스에 영향을 끼지지 않는다 (뭐 부모 - 자식 관계는 예외)</li>
<li><em><strong>Cooperating Process</strong></em>: IPC 를 이용하면 다른 프로세스의 수행에 영향을 끼칠 수 있다</li>
</ul>
<h3 id="message-passing">Message Passing<a aria-hidden="true" tabindex="-1" href="#message-passing" class="internal"> §</a></h3>
<p><img src="../../../../gardens/os/originals/os.bahn.ewha.kocw.net/images/Screen_Shot_2022-07-24_at_10.41.31_PM.png" alt="Screen Shot 2022-07-24 at 10.41.31 PM.png"/></p>
<ul>
<li>IPC 의 분류중에 <em><strong>Message Passing</strong></em> 은 일단 커널을 브로커로 해서 메시지를 전달하는 방법 (Message System)이다
<ul>
<li>따라서 공유 메모리나 공유 변수 등을 사용하지 않는다</li>
</ul>
</li>
<li>뭐 인터페이스가 두가지 종류가 있다네
<ol>
<li><em><strong>Direct Communication</strong></em>
<img src="../../../../gardens/os/originals/os.bahn.ewha.kocw.net/images/Screen_Shot_2022-07-24_at_10.38.16_PM.png" alt="Screen Shot 2022-07-24 at 10.38.16 PM.png"/>
<ul>
<li>얘는 수신 프로세스를 명확하게 명시하는 방식이랜다</li>
</ul>
</li>
<li><em><strong>Indirect Communication</strong></em>
<img src="../../../../gardens/os/originals/os.bahn.ewha.kocw.net/images/Screen_Shot_2022-07-24_at_10.39.00_PM.png" alt="Screen Shot 2022-07-24 at 10.39.00 PM.png"/>
<ul>
<li>그리고 얘는 수신 프로세스를 명시하지 않고 메일박스(?) 나 포트번호 등을 이용해서 메시지를 간접적으로 전달하는 방식이라네</li>
</ul>
</li>
</ol>
</li>
</ul>
<h3 id="shared-memory">Shared Memory<a aria-hidden="true" tabindex="-1" href="#shared-memory" class="internal"> §</a></h3>
<p><img src="../../../../gardens/os/originals/os.bahn.ewha.kocw.net/images/Screen_Shot_2022-07-24_at_10.42.38_PM.png" alt="Screen Shot 2022-07-24 at 10.42.38 PM.png"/></p>
<ul>
<li>얘는 말 그대로 공유 메모리를 커널로부터 할당받아서 두 프로세스가 메모리에 존재하는 데이터를 공유하는 방법이다</li>
<li>얘도 당연히 커널의 힘을 빌려야 하긴 하지만 Message Passing 의 경우에는 매번 커널에 의존하지만 얘는 공유 메모리를 처음 매핑할때만 커널에 의존한다는 차이점 정도가 존재한다</li>
</ul>
<h3 id="thread">Thread<a aria-hidden="true" tabindex="-1" href="#thread" class="internal"> §</a></h3>
<ul>
<li>뭐 쓰레드는 프로세스가 아니기 때문에 IPC 라고 하기에는 좀 뭐하지만</li>
<li>Thread 끼리는 메모리를 공유하기 때문에 통신이 아주 간편맨하댄다</li>
</ul></article></div><div class="right sidebar"><div class="graph "><h3>Graph View</h3><div class="graph-outer"><div id="graph-container" data-cfg="{&quot;drag&quot;:true,&quot;zoom&quot;:true,&quot;depth&quot;:1,&quot;scale&quot;:1.1,&quot;repelForce&quot;:0.5,&quot;centerForce&quot;:0.3,&quot;linkDistance&quot;:30,&quot;fontSize&quot;:0.6,&quot;opacityScale&quot;:1,&quot;showTags&quot;:true,&quot;removeTags&quot;:[]}"></div><svg version="1.1" id="global-graph-icon" xmlns="http://www.w3.org/2000/svg" xmlnsXlink="http://www.w3.org/1999/xlink" x="0px" y="0px" viewBox="0 0 55 55" fill="currentColor" xmlSpace="preserve"><path d="M49,0c-3.309,0-6,2.691-6,6c0,1.035,0.263,2.009,0.726,2.86l-9.829,9.829C32.542,17.634,30.846,17,29,17
	s-3.542,0.634-4.898,1.688l-7.669-7.669C16.785,10.424,17,9.74,17,9c0-2.206-1.794-4-4-4S9,6.794,9,9s1.794,4,4,4
	c0.74,0,1.424-0.215,2.019-0.567l7.669,7.669C21.634,21.458,21,23.154,21,25s0.634,3.542,1.688,4.897L10.024,42.562
	C8.958,41.595,7.549,41,6,41c-3.309,0-6,2.691-6,6s2.691,6,6,6s6-2.691,6-6c0-1.035-0.263-2.009-0.726-2.86l12.829-12.829
	c1.106,0.86,2.44,1.436,3.898,1.619v10.16c-2.833,0.478-5,2.942-5,5.91c0,3.309,2.691,6,6,6s6-2.691,6-6c0-2.967-2.167-5.431-5-5.91
	v-10.16c1.458-0.183,2.792-0.759,3.898-1.619l7.669,7.669C41.215,39.576,41,40.26,41,41c0,2.206,1.794,4,4,4s4-1.794,4-4
	s-1.794-4-4-4c-0.74,0-1.424,0.215-2.019,0.567l-7.669-7.669C36.366,28.542,37,26.846,37,25s-0.634-3.542-1.688-4.897l9.665-9.665
	C46.042,11.405,47.451,12,49,12c3.309,0,6-2.691,6-6S52.309,0,49,0z M11,9c0-1.103,0.897-2,2-2s2,0.897,2,2s-0.897,2-2,2
	S11,10.103,11,9z M6,51c-2.206,0-4-1.794-4-4s1.794-4,4-4s4,1.794,4,4S8.206,51,6,51z M33,49c0,2.206-1.794,4-4,4s-4-1.794-4-4
	s1.794-4,4-4S33,46.794,33,49z M29,31c-3.309,0-6-2.691-6-6s2.691-6,6-6s6,2.691,6,6S32.309,31,29,31z M47,41c0,1.103-0.897,2-2,2
	s-2-0.897-2-2s0.897-2,2-2S47,39.897,47,41z M49,10c-2.206,0-4-1.794-4-4s1.794-4,4-4s4,1.794,4,4S51.206,10,49,10z"></path></svg></div><div id="global-graph-outer"><div id="global-graph-container" data-cfg="{&quot;drag&quot;:true,&quot;zoom&quot;:true,&quot;depth&quot;:-1,&quot;scale&quot;:0.9,&quot;repelForce&quot;:0.5,&quot;centerForce&quot;:0.3,&quot;linkDistance&quot;:30,&quot;fontSize&quot;:0.6,&quot;opacityScale&quot;:1,&quot;showTags&quot;:true,&quot;removeTags&quot;:[]}"></div></div></div><div class="toc desktop-only"><button type="button" id="toc"><h3>Table of Contents</h3><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="fold"><polyline points="6 9 12 15 18 9"></polyline></svg></button><div id="toc-content"><ul class="overflow"><li class="depth-0"><a href="#process-lifecycle" data-for="process-lifecycle">Process Lifecycle</a></li><li class="depth-1"><a href="#process-creation" data-for="process-creation">Process Creation</a></li><li class="depth-1"><a href="#process-execution" data-for="process-execution">Process Execution</a></li><li class="depth-1"><a href="#process-termination" data-for="process-termination">Process Termination</a></li><li class="depth-0"><a href="#process-syscall" data-for="process-syscall">Process Syscall</a></li><li class="depth-1"><a href="#fork" data-for="fork">Fork</a></li><li class="depth-1"><a href="#exec" data-for="exec">Exec</a></li><li class="depth-1"><a href="#wait" data-for="wait">Wait</a></li><li class="depth-0"><a href="#inter-process-conmunication-ipc" data-for="inter-process-conmunication-ipc">Inter Process Conmunication (IPC)</a></li><li class="depth-1"><a href="#message-passing" data-for="message-passing">Message Passing</a></li><li class="depth-1"><a href="#shared-memory" data-for="shared-memory">Shared Memory</a></li><li class="depth-1"><a href="#thread" data-for="thread">Thread</a></li></ul></div></div><div class="backlinks "><h3>Backlinks</h3><ul class="overflow"><li><a href="../../../../gardens/os/originals/os.bahn.ewha.kocw.net/(이화여대)-운영체제-강의록" class="internal">(이화여대) 운영체제 강의록</a></li></ul></div></div></div><footer class><hr/><p>Created with <a href="https://quartz.jzhao.xyz/">Quartz v4.1.0</a>, © 2024</p><ul><li><a href="https://github.com/haeramkeem">GitHub</a></li><li><a href="www.linkedin.com/in/haeram-kim-277404220">LinkedIn</a></li><li><a href="mailto:haeram.kim1@gmail.com">Email</a></li></ul></footer></div></body><script type="application/javascript">// quartz/components/scripts/quartz/components/scripts/callout.inline.ts
function toggleCallout() {
  const outerBlock = this.parentElement;
  outerBlock.classList.toggle(`is-collapsed`);
  const collapsed = outerBlock.classList.contains(`is-collapsed`);
  const height = collapsed ? this.scrollHeight : outerBlock.scrollHeight;
  outerBlock.style.maxHeight = height + `px`;
  let current = outerBlock;
  let parent = outerBlock.parentElement;
  while (parent) {
    if (!parent.classList.contains(`callout`)) {
      return;
    }
    const collapsed2 = parent.classList.contains(`is-collapsed`);
    const height2 = collapsed2 ? parent.scrollHeight : parent.scrollHeight + current.scrollHeight;
    parent.style.maxHeight = height2 + `px`;
    current = parent;
    parent = parent.parentElement;
  }
}
function setupCallout() {
  const collapsible = document.getElementsByClassName(
    `callout is-collapsible`
  );
  for (const div of collapsible) {
    const title = div.firstElementChild;
    if (title) {
      title.removeEventListener(`click`, toggleCallout);
      title.addEventListener(`click`, toggleCallout);
      const collapsed = div.classList.contains(`is-collapsed`);
      const height = collapsed ? title.scrollHeight : div.scrollHeight;
      div.style.maxHeight = height + `px`;
    }
  }
}
document.addEventListener(`nav`, setupCallout);
window.addEventListener(`resize`, setupCallout);
</script><script type="module">
          import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.esm.min.mjs';
          const darkMode = document.documentElement.getAttribute('saved-theme') === 'dark'
          mermaid.initialize({
            startOnLoad: false,
            securityLevel: 'loose',
            theme: darkMode ? 'dark' : 'default'
          });
          document.addEventListener('nav', async () => {
            await mermaid.run({
              querySelector: '.mermaid'
            })
          });
          </script><script src="https://cdn.jsdelivr.net/npm/katex@0.16.7/dist/contrib/copy-tex.min.js" type="application/javascript"></script><script src="https://www.googletagmanager.com/gtag/js?id=G-N68CCP1QHG" type="application/javascript"></script><script src="../../../../postscript.js" type="module"></script></html>