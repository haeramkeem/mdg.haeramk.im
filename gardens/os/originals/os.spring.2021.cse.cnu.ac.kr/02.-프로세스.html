<!DOCTYPE html>
<html><head><title>02. 프로세스</title><meta charSet="utf-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:title" content="02. 프로세스"/><meta property="og:description" content="충남대학교 컴퓨터공학과 류재철 교수님의 &amp;quot;운영체제 및 실습&amp;quot; 강의를 필기한 내용입니다. 다소 잘못된 내용과 구어적 표현 이 포함되어 있을 수 있습니다. 프로그램 실행에서의 OS의 역할 § 자원들(메모리 등)을 여러 프로세스들에게 적절하게 분배하고 관리함 프로세스가 계속 변경되며 실행되어 동시에 실행되는것처럼 보이게 한다 이렇게 프로세스와 IO디바이스들을 관리하는것이 OS가 하는 일이다 프로세스 § 실행의 단위, OS의 관리의 단위, 실행됐지만 아직 죽지는 않은 것 프로그램 코드 와 그 코드와 연결된 여러개의 데이터로 구성된다 코드(text) : 내가 짠 프로그램 소스파일 코드에 연동되는 데이터는 구체적으로 global 변수는 data에, local변수와 함수는 stack에, 동적할당을 위한 공간은 heap에(단 heap은 data와 합쳐 그냥 data로 하나로 퉁쳐서 부르기도 한다), 그리고 나머지 필요한 자료들은 PCB에 저장된다 OS는 프로세스 단위로 메모리를 할당하고 관리한다 PCB에 저장되는 정보들 § PCB = Process Control Block : 프로세스의 정보들을 담은 구역(자료구조)."/><meta property="og:image" content="https://mdg.haeramk.im/static/og-image.png"/><meta property="og:width" content="1200"/><meta property="og:height" content="675"/><link rel="icon" href="../../../../static/icon.png"/><meta name="description" content="충남대학교 컴퓨터공학과 류재철 교수님의 &amp;quot;운영체제 및 실습&amp;quot; 강의를 필기한 내용입니다. 다소 잘못된 내용과 구어적 표현 이 포함되어 있을 수 있습니다. 프로그램 실행에서의 OS의 역할 § 자원들(메모리 등)을 여러 프로세스들에게 적절하게 분배하고 관리함 프로세스가 계속 변경되며 실행되어 동시에 실행되는것처럼 보이게 한다 이렇게 프로세스와 IO디바이스들을 관리하는것이 OS가 하는 일이다 프로세스 § 실행의 단위, OS의 관리의 단위, 실행됐지만 아직 죽지는 않은 것 프로그램 코드 와 그 코드와 연결된 여러개의 데이터로 구성된다 코드(text) : 내가 짠 프로그램 소스파일 코드에 연동되는 데이터는 구체적으로 global 변수는 data에, local변수와 함수는 stack에, 동적할당을 위한 공간은 heap에(단 heap은 data와 합쳐 그냥 data로 하나로 퉁쳐서 부르기도 한다), 그리고 나머지 필요한 자료들은 PCB에 저장된다 OS는 프로세스 단위로 메모리를 할당하고 관리한다 PCB에 저장되는 정보들 § PCB = Process Control Block : 프로세스의 정보들을 담은 구역(자료구조)."/><meta name="generator" content="Quartz"/><link rel="preconnect" href="https://fonts.googleapis.com"/><link rel="preconnect" href="https://fonts.gstatic.com"/><link href="../../../../index.css" rel="stylesheet" type="text/css" spa-preserve/><link href="https://cdn.jsdelivr.net/npm/katex@0.16.0/dist/katex.min.css" rel="stylesheet" type="text/css" spa-preserve/><link href="https://fonts.googleapis.com/css2?family=IBM Plex Mono&amp;family=Gowun Batang:wght@400;700&amp;family=Gowun Dodum:ital,wght@0,400;0,600;1,400;1,600&amp;display=swap" rel="stylesheet" type="text/css" spa-preserve/><script src="../../../../prescript.js" type="application/javascript" spa-preserve></script><script type="application/javascript" spa-preserve>const fetchData = fetch(`../../../../static/contentIndex.json`).then(data => data.json())</script></head><body data-slug="gardens/os/originals/os.spring.2021.cse.cnu.ac.kr/02.-프로세스"><div id="quartz-root" class="page"><div id="quartz-body"><div class="left sidebar"><h1 class="page-title "><a href="../../../..">Madison Digital Garden</a></h1><div class="spacer mobile-only"></div><div class="search "><div id="search-icon"><p>Search</p><div></div><svg tabIndex="0" aria-labelledby="title desc" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 19.9 19.7"><title id="title">Search</title><desc id="desc">Search</desc><g class="search-path" fill="none"><path stroke-linecap="square" d="M18.5 18.3l-5.4-5.4"></path><circle cx="8" cy="8" r="7"></circle></g></svg></div><div id="search-container"><div id="search-space"><input autocomplete="off" id="search-bar" name="search" type="text" aria-label="Search for something" placeholder="Search for something"/><div id="results-container"></div></div></div></div><div class="darkmode "><input class="toggle" id="darkmode-toggle" type="checkbox" tabIndex="-1"/><label id="toggle-label-light" for="darkmode-toggle" tabIndex="-1"><svg xmlns="http://www.w3.org/2000/svg" xmlnsXlink="http://www.w3.org/1999/xlink" version="1.1" id="dayIcon" x="0px" y="0px" viewBox="0 0 35 35" style="enable-background:new 0 0 35 35;" xmlSpace="preserve"><title>Light mode</title><path d="M6,17.5C6,16.672,5.328,16,4.5,16h-3C0.672,16,0,16.672,0,17.5    S0.672,19,1.5,19h3C5.328,19,6,18.328,6,17.5z M7.5,26c-0.414,0-0.789,0.168-1.061,0.439l-2,2C4.168,28.711,4,29.086,4,29.5    C4,30.328,4.671,31,5.5,31c0.414,0,0.789-0.168,1.06-0.44l2-2C8.832,28.289,9,27.914,9,27.5C9,26.672,8.329,26,7.5,26z M17.5,6    C18.329,6,19,5.328,19,4.5v-3C19,0.672,18.329,0,17.5,0S16,0.672,16,1.5v3C16,5.328,16.671,6,17.5,6z M27.5,9    c0.414,0,0.789-0.168,1.06-0.439l2-2C30.832,6.289,31,5.914,31,5.5C31,4.672,30.329,4,29.5,4c-0.414,0-0.789,0.168-1.061,0.44    l-2,2C26.168,6.711,26,7.086,26,7.5C26,8.328,26.671,9,27.5,9z M6.439,8.561C6.711,8.832,7.086,9,7.5,9C8.328,9,9,8.328,9,7.5    c0-0.414-0.168-0.789-0.439-1.061l-2-2C6.289,4.168,5.914,4,5.5,4C4.672,4,4,4.672,4,5.5c0,0.414,0.168,0.789,0.439,1.06    L6.439,8.561z M33.5,16h-3c-0.828,0-1.5,0.672-1.5,1.5s0.672,1.5,1.5,1.5h3c0.828,0,1.5-0.672,1.5-1.5S34.328,16,33.5,16z     M28.561,26.439C28.289,26.168,27.914,26,27.5,26c-0.828,0-1.5,0.672-1.5,1.5c0,0.414,0.168,0.789,0.439,1.06l2,2    C28.711,30.832,29.086,31,29.5,31c0.828,0,1.5-0.672,1.5-1.5c0-0.414-0.168-0.789-0.439-1.061L28.561,26.439z M17.5,29    c-0.829,0-1.5,0.672-1.5,1.5v3c0,0.828,0.671,1.5,1.5,1.5s1.5-0.672,1.5-1.5v-3C19,29.672,18.329,29,17.5,29z M17.5,7    C11.71,7,7,11.71,7,17.5S11.71,28,17.5,28S28,23.29,28,17.5S23.29,7,17.5,7z M17.5,25c-4.136,0-7.5-3.364-7.5-7.5    c0-4.136,3.364-7.5,7.5-7.5c4.136,0,7.5,3.364,7.5,7.5C25,21.636,21.636,25,17.5,25z"></path></svg></label><label id="toggle-label-dark" for="darkmode-toggle" tabIndex="-1"><svg xmlns="http://www.w3.org/2000/svg" xmlnsXlink="http://www.w3.org/1999/xlink" version="1.1" id="nightIcon" x="0px" y="0px" viewBox="0 0 100 100" style="enable-background='new 0 0 100 100'" xmlSpace="preserve"><title>Dark mode</title><path d="M96.76,66.458c-0.853-0.852-2.15-1.064-3.23-0.534c-6.063,2.991-12.858,4.571-19.655,4.571  C62.022,70.495,50.88,65.88,42.5,57.5C29.043,44.043,25.658,23.536,34.076,6.47c0.532-1.08,0.318-2.379-0.534-3.23  c-0.851-0.852-2.15-1.064-3.23-0.534c-4.918,2.427-9.375,5.619-13.246,9.491c-9.447,9.447-14.65,22.008-14.65,35.369  c0,13.36,5.203,25.921,14.65,35.368s22.008,14.65,35.368,14.65c13.361,0,25.921-5.203,35.369-14.65  c3.872-3.871,7.064-8.328,9.491-13.246C97.826,68.608,97.611,67.309,96.76,66.458z"></path></svg></label></div></div><div class="center"><div class="page-header"><div class="popover-hint"><h1 class="article-title ">02. 프로세스</h1><p class="content-meta ">Oct 07, 2024, 16 min read</p></div></div><article class="popover-hint"><blockquote class="callout" data-callout="info">
<div class="callout-title">
                  <div class="callout-icon"><svg xmlns="http://www.w3.org/2000/svg" width="100%" height="100%" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="10"></circle><line x1="12" y1="16" x2="12" y2="12"></line><line x1="12" y1="8" x2="12.01" y2="8"></line></svg></div>
                  <div class="callout-title-inner"><p>충남대학교 컴퓨터공학과 류재철 교수님의 &quot;운영체제 및 실습&quot; 강의를 필기한 내용입니다. </p></div>
                  
                </div>
</blockquote>
<blockquote class="callout" data-callout="warning">
<div class="callout-title">
                  <div class="callout-icon"><svg xmlns="http://www.w3.org/2000/svg" width="100%" height="100%" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="m21.73 18-8-14a2 2 0 0 0-3.48 0l-8 14A2 2 0 0 0 4 21h16a2 2 0 0 0 1.73-3Z"></path><line x1="12" y1="9" x2="12" y2="13"></line><line x1="12" y1="17" x2="12.01" y2="17"></line></svg></div>
                  <div class="callout-title-inner"><p>다소 잘못된 내용과 구어적 표현 이 포함되어 있을 수 있습니다. </p></div>
                  
                </div>
</blockquote>
<h2 id="프로그램-실행에서의-os의-역할">프로그램 실행에서의 OS의 역할<a aria-hidden="true" tabindex="-1" href="#프로그램-실행에서의-os의-역할" class="internal"> §</a></h2>
<ul>
<li>자원들(메모리 등)을 여러 프로세스들에게 적절하게 분배하고 관리함</li>
<li>프로세스가 계속 변경되며 실행되어 동시에 실행되는것처럼 보이게 한다</li>
<li>이렇게 프로세스와 IO디바이스들을 관리하는것이 OS가 하는 일이다</li>
</ul>
<h2 id="프로세스">프로세스<a aria-hidden="true" tabindex="-1" href="#프로세스" class="internal"> §</a></h2>
<ul>
<li>실행의 단위, OS의 관리의 단위, 실행됐지만 아직 죽지는 않은 것</li>
<li>프로그램 <strong>코드</strong> 와 그 코드와 연결된 여러개의 <strong>데이터</strong>로 구성된다</li>
<li><strong>코드(text)</strong> : 내가 짠 프로그램 소스파일</li>
<li>코드에 연동되는 <strong>데이터</strong>는 구체적으로 global 변수는 data에, local변수와 함수는 stack에, 동적할당을 위한 공간은 heap에(단 heap은 data와 합쳐 그냥 data로 하나로 퉁쳐서 부르기도 한다), 그리고 나머지 필요한 자료들은 PCB에 저장된다</li>
<li>OS는 프로세스 단위로 메모리를 할당하고 관리한다</li>
</ul>
<h2 id="pcb에-저장되는-정보들">PCB에 저장되는 정보들<a aria-hidden="true" tabindex="-1" href="#pcb에-저장되는-정보들" class="internal"> §</a></h2>
<ul>
<li><strong>PCB = Process Control Block</strong> : 프로세스의 정보들을 담은 구역(자료구조). 프로그램이 프로세스가 되기 위해서는 이 공간을 반드시 할당받아야 한다</li>
<li><strong>identifier</strong> : 유닉스에서 PID같은놈. 프로세스들의 고유 번호이다</li>
<li><strong>state</strong> : 프로세스의 현재 상태. 현재 실행중인건지, 기다리는 것인지 등등의 상태들이 저당된다</li>
<li><strong>priority</strong> : 프로세스들 간의 우선순위. 시스템 프로세스 같은 중요한 것들이 먼저 구동될 있도록 우선순위가 매겨져있다. 하지만 하나의 프로세스가 cpu를 monopolize하는것을 막기 위해 우선순위는 계속 바뀌게 된다</li>
<li>그리고 cpu로 들어갈때 레지스터에 쓸 값들 - <strong>program counter</strong>(다름 실행할 명령어의 주소), <strong>memory pointer</strong>(이 프로세스가 저장되어있는 메모리의 주소) 등등의 정보들이 저장되게 된다</li>
</ul>
<h2 id="system-kernel-user-process">System, Kernel, User Process<a aria-hidden="true" tabindex="-1" href="#system-kernel-user-process" class="internal"> §</a></h2>
<ul>
<li>OS도 하나의 프로그램이므로 OS의 여러 기능들도 프로세스화되어 구동되게 된다</li>
<li>이 OS의 프로세스를 <strong>system process</strong>라고 하며 그 중에서도 중요한 애들인 커널이 프로세스화 된 것이 <strong>kernel process(daemon)</strong> 이다. Kernel process같은 중요한 기능들은 항상 메모리에 상주한다 &lt;-> 반대로 우리가 만든 프로그램들이 프로세스화되면 <strong>user process</strong>라고 하는 것</li>
</ul>
<h2 id="dispatch-context-switch">Dispatch, Context switch<a aria-hidden="true" tabindex="-1" href="#dispatch-context-switch" class="internal"> §</a></h2>
<ul>
<li><strong>Dispatch</strong> : ready상태인 프로세스들 중 가장 우선순위가 높은놈을 running상태로 바꿔 cpu를 할당하는 일을 말함</li>
<li><strong>Context switch</strong> : 프로세스가 전환 후 새로운 프로세스가 실행되는것을 의미함</li>
<li><strong>Dispatcher</strong> : 새로운 프로세스를 Dispatch하여 Context switch하는 일을 전담하는 kernel process</li>
<li>여기서 중요한점은 새로운 프로세스가 Dispatch된 이후 새 프로세스가 실행되는것을 보고 Context switch가 일어났다라고 말한다 - 새로운 프로세스로 교체하는 “과정”을 Context switch라고 하는게 아니다 이말이야 - 따라서 Dispatch이후 Context Switch가 일어나는게 맞는거다</li>
</ul>
<h2 id="process-실행과정---2-state-process-model">Process 실행과정 - 2 state process model<a aria-hidden="true" tabindex="-1" href="#process-실행과정---2-state-process-model" class="internal"> §</a></h2>
<p><img src="../../../../gardens/os/originals/os.spring.2021.cse.cnu.ac.kr/images/2/image1.png" alt="%E1%84%8B%E1%85%B5%E1%84%85%E1%85%A9%E1%86%AB02%20-%20%E1%84%91%E1%85%B3%E1%84%85%E1%85%A9%E1%84%89%E1%85%A6%E1%84%89%E1%85%B3%20abcc0abd8daa4524bf7af87f2e874e9c/image1.png"/></p>
<ul>
<li>프로세스가 생성되면(<strong>Enter / Creation</strong>) 먼저 **Not Running(Ready)**상태가 된다 - Dispatch를 기다리는 상태</li>
<li>이제 이 프로세스가 Dispatch되면 <strong>Running</strong>상태가 된다 - 실행되는 상태</li>
<li>그리고 또 이놈이 실행되다가 타임아웃 등의 인터럽트를 받으면 다시 Not Running의 상태로 간다 - <strong>pause</strong>된다</li>
<li>또 Dispatch되면 Running상태로 가고 이 과정을 반복하가 종료 (<strong>Exit / Termination</strong>)된다</li>
<li>따라서 프로그램이 fork()되어 프로세스로 creation이 됐다가 exit()되어 다시 프로그램의 상태로 termination될때까지 수많은 pause와 dispatch를 거친다</li>
<li>하지만 system process들은 잘 terminate되지 않는다 - 중요하므로</li>
<li>우리가 코딩할때도. system call을 이용해 creation, dispatch, pause, terminate를 직접적으로 명령할 수도 있다 - <strong>fork(), exec(), wait(), exit()</strong></li>
<li>Not Running중인 프로세스들은 queue로 관리된다→ dispatch되면 queue에서 빠지고 pause되면 다시 queue로 들어간다</li>
</ul>
<h2 id="sys-call--fork함수">sys call : fork()함수<a aria-hidden="true" tabindex="-1" href="#sys-call--fork함수" class="internal"> §</a></h2>
<ul>
<li>프로세스가 실행되다가 fork()가 실행되면 새로 프로세스가 하나 더 만들어지는데 이때 fork()를 호출한놈이 <strong>parent</strong> 이고 만들어진 놈이 <strong>child</strong> 이다</li>
<li>fork()를 호출하면 parent와 동일한 놈이 하나더 child로 만들어지게 된다</li>
<li>나머지는 전부 같으나 다른점이 몇가지 있다
<ol>
<li>PID(identifier) 가 다르다 - 부모자식은 구별할 수 있어야 하므로</li>
<li>fork()함수의 리턴값은 부모의 경우 자식의 PID, 자식의 경우 0을 리턴한다</li>
</ol>
</li>
<li>child프로세스가 끝나기 전에 parent가 끝나면 좀 골치아파진다 - 원칙적으로 child가 끝나야 parent를 끝낸다 - <strong>cascade termination</strong> 이라고 한다</li>
<li>하지만 부득이하게 parent가 끝나면 parent의 parent가 child의 parent로 바뀌게 된다</li>
</ul>
<h2 id="termination-condition">Termination condition<a aria-hidden="true" tabindex="-1" href="#termination-condition" class="internal"> §</a></h2>
<ol>
<li><strong>Normal completion</strong> : 정상종료</li>
<li>timeout과는 별개로 cpu를 차지하는 총 시간도 중요하다 - 무한루프에 빠졌을 가능성이 있으므로 - cpu를 차지하는 총 시간이 너무 긴 경우에도 강제로 termination하게 된다 - timeout과는 별개의 개념이다 - timeout의 경우에는 cpu를 연속적으로 사용하는 시간을 말하고 이때에는 이 cpu를 잡고있는 총 시간을 말하는거 -무한루프가 아닌 원래 시간을 많이 잡아먹는 일이면 작업관리자에 승인을 요청하는 작업을 해줘야 된다</li>
<li><strong>Memory unavailable</strong> : 더이상 가용 가능한 메모리가 없을 경우</li>
</ol>
<h2 id="process-실행과정---5-state-process-model">Process 실행과정 - 5 state process model<a aria-hidden="true" tabindex="-1" href="#process-실행과정---5-state-process-model" class="internal"> §</a></h2>
<p><img src="../../../../gardens/os/originals/os.spring.2021.cse.cnu.ac.kr/images/2/image2.png" alt="%E1%84%8B%E1%85%B5%E1%84%85%E1%85%A9%E1%86%AB02%20-%20%E1%84%91%E1%85%B3%E1%84%85%E1%85%A9%E1%84%89%E1%85%A6%E1%84%89%E1%85%B3%20abcc0abd8daa4524bf7af87f2e874e9c/image2.png"/></p>
<ol>
<li><strong>New</strong> : 새로 들어와서 프로세스로 바꾸는 과정 - 여러 resource들을 할당받는 상태 - 프로세스화가 끝나면 <strong>admit</strong>되어 다음 단계로 간다</li>
<li><strong>Ready</strong> : 프로세스화가 끝난 상태 - dispatch되어 running되기만 기다리는 상태이다</li>
<li><strong>Running</strong> : dispatch후 실행중인 상태 - 실행이 끝나면 <strong>release</strong>되어 다음 단계로 간다
<ul>
<li>다만 timeout이 발생하면 다시 ready로 가게 된다 - timeout의 경우에는 어떤 이벤트가 일어나 지금 당장 실행할 수 없는 상태가 아니므로</li>
<li>ready 상태에 있는 놈들은 queue에서 기다리게 된다</li>
</ul>
</li>
<li><strong>Blocked</strong> : 키보드 입력이라거나 그러한 이벤트로 인해 잠깐 멈춘 상태 - <strong>event wait</strong>
<ul>
<li>얘네는 지금 바로 다시 실행할 수 있는 상태가 아니기 때문에 ready로는 가지 못하게 되는거다 - 따라서 이벤트가 처리되어(<strong>event occurs</strong>) 다시 running 가능해지면 running되는게 아니라 ready 단게로 가게 된다</li>
<li><strong>event queue</strong>라는 것이 존재해서 event가 처리될때까지 queue에 머문다 - 그리고 event가 끝나면 ready queue로 옮겨져 또 기다리게 된다</li>
</ul>
</li>
<li><strong>Exit</strong> : 프로세스가 종료되어 new에서의 역순으로 처리되는 과정 - resource를 전부 반납하게 된다</li>
</ol>
<h2 id="process-swapping---7-state-process-model">Process Swapping - 7 state process model<a aria-hidden="true" tabindex="-1" href="#process-swapping---7-state-process-model" class="internal"> §</a></h2>
<p><img src="../../../../gardens/os/originals/os.spring.2021.cse.cnu.ac.kr/images/2/image3.png" alt="%E1%84%8B%E1%85%B5%E1%84%85%E1%85%A9%E1%86%AB02%20-%20%E1%84%91%E1%85%B3%E1%84%85%E1%85%A9%E1%84%89%E1%85%A6%E1%84%89%E1%85%B3%20abcc0abd8daa4524bf7af87f2e874e9c/image3.png"/></p>
<ul>
<li>중요한 이벤트가 발생해서 당장 실행해야 되는데 메모리에 공간이 없으면 덜 중요한 애들이 메모리를 양보하고 하드디스크로 내려간다 - <strong>swap-out</strong></li>
<li>이벤트가 종료되어 얘네들이 다시 메모리로 올라오는 것을 <strong>swap-in</strong> 이라고 한다</li>
<li>이렇게 프로세스가 잠깐 하드로 내려가게 되는 것을 <strong>suspend</strong>라고 한다</li>
<li>이런 suspend를 관리하기 위해 suspend state가 존재한다 - ready상태에서 swap-out를 먹으면 <strong>ready / suspend</strong>로 가고 blocked 상태에서 swap-out를 먹으면 <strong>blocked / suspend</strong>로 간다</li>
<li>그리고 얘네들이 다시 swap-in을 먹으면. 원래의 상태로 돌아오게 된다 - 무조건 ready로 올라오는게 아니다!!</li>
<li>당연하게도 일단 메모리에 있어야(ready 혹은 blocked여야) running 상태로 갈 수 있다 - suspend에서 바로 running으로 가지는 못한다</li>
<li>하지만 running에서 suspend를 먹어서 내려갈 수는 있다</li>
<li>또한 지금 메모리가 부족한 경우에는 프로세스가 만들어지자마자 ready / suspend로 갈 수도 있다</li>
</ul>
<h2 id="figure-311">Figure 3.11<a aria-hidden="true" tabindex="-1" href="#figure-311" class="internal"> §</a></h2>
<p><img src="../../../../gardens/os/originals/os.spring.2021.cse.cnu.ac.kr/images/2/image4.png" alt="%E1%84%8B%E1%85%B5%E1%84%85%E1%85%A9%E1%86%AB02%20-%20%E1%84%91%E1%85%B3%E1%84%85%E1%85%A9%E1%84%89%E1%85%A6%E1%84%89%E1%85%B3%20abcc0abd8daa4524bf7af87f2e874e9c/image4.png"/></p>
<ul>
<li>processes에 process table의 시작주소가 들어있고 그 테이블에 process들의 주소들이 들어있다</li>
<li>여기서 process table이 PCB table이다 - 실제로는 프로세스를 구성하는 PCB, 데이터 등등이 어느 한곳에 같이 모여있는게 아니다 이말이야 - 그림에서의 process image에는 PCB는 안들어있고 그 나머지인 text, data, heap등이 저장되어 있는 구조이다</li>
<li>process table은 pointer를 이용해서 가변길이로 할 수도 있지만 중간에 포인터를 잃어버리면 나가리기 때문에 불변길이로 선언하는 경우가 많다 - 다만 n이 시스템에 존재할 수 있는 process들의 총 갯수이기 때문에 n을 적당한 크기로 정하는 것이 중요하다 - n이 너무 크면 메모리를 너무 많이 먹고 n이 너무 작으면 process가 생성되기 힘들다 - 이 table의 일부가 비어있어야 process가 생성될 수 있기 때문</li>
<li>뭐 나머지 memory table, io table 등등도 다 비슷하다</li>
<li>그리고 이 table들의 주소를 담고 있는 structure가 존재하는 형태이다</li>
<li>process table은 메모리에 상주하게 되는데 보통 이 n값이 굉장히 크기 때문에 메모리의 많은 부분을 차지하게 된다 - 그래서 PCB의 중요한 부분만 남기고 나머지 PCB중 덜 중요한 정보들은 하드디스크로 넘기게 되는데 이 부분이 <strong>u-area</strong>이다 - 다만 running 상태가 되면 이 u-area는 메모리로 다시 올라오게 된다 - state에 따라 어디 있을지 결정되는 것</li>
</ul>
<h2 id="process-creation-과정">Process creation 과정<a aria-hidden="true" tabindex="-1" href="#process-creation-과정" class="internal"> §</a></h2>
<ul>
<li>creation : Id 만들기 → process를 위한 공간 할당 → PCB 생성 → 필요한 포인터들 연결 → 다른 자료구조들 생성</li>
<li>terminate : 이것의 역순이다</li>
</ul>
<h2 id="ready-blocked-queue의-구현">Ready, Blocked Queue의 구현<a aria-hidden="true" tabindex="-1" href="#ready-blocked-queue의-구현" class="internal"> §</a></h2>
<p><img src="../../../../gardens/os/originals/os.spring.2021.cse.cnu.ac.kr/images/2/image5.png" alt="%E1%84%8B%E1%85%B5%E1%84%85%E1%85%A9%E1%86%AB02%20-%20%E1%84%91%E1%85%B3%E1%84%85%E1%85%A9%E1%84%89%E1%85%A6%E1%84%89%E1%85%B3%20abcc0abd8daa4524bf7af87f2e874e9c/image5.png"/></p>
<ul>
<li>보면 큐라고 해서 이 프로세스들이 물리적으로 막 움직이는게 아니다 - 이렇게 linked-list형태로 구성되게 된다</li>
<li>루트 노드에는 첫번째 프로세스의 PCB.state의 주소가 담기고 이 PCB.state에는 다음 프로세스의 PCB.state의 주소가 담기는 식으로 다음 프로세스를 계속 가리키는 식으로 큐가 구현되어있더라 이말이야</li>
</ul>
<h2 id="interrupt-vs-trap">Interrupt vs trap<a aria-hidden="true" tabindex="-1" href="#interrupt-vs-trap" class="internal"> §</a></h2>
<ul>
<li><strong>Interrupt</strong> : 프로세스의 외부에서 이벤트가 발생해서 멈추는 것
<ol>
<li>interrupt가 발생하면 실행 모드가 user → kernel mode로 바뀐다</li>
<li>user의 process가 멈추고 kernel의 interrupt handler가 실행되게 된다 - 다음 실행할 instruction의 주소가 interrupt handler의 첫주소로 설정되는 것</li>
<li>interrupt가 끝나면 다시 원래의 instruction 주소로 돌아오며 실행모드도 user mode 로 바뀌게 된다</li>
</ol>
</li>
<li><strong>Trap</strong> : 프로세스의 내부에서 이벤트가 일어나 멈추는 것</li>
</ul>
<h2 id="context-switching이-일어나기까지의-과정">Context switching이 일어나기까지의 과정<a aria-hidden="true" tabindex="-1" href="#context-switching이-일어나기까지의-과정" class="internal"> §</a></h2>
<ol>
<li>중단된 시점의 레지스터 값을 전부 진행중인 프로세스의 메모리로 옮긴다(<strong>stop &amp; save</strong>)</li>
<li>state를 바꾼다(running → ready나 다른 상태들)</li>
<li>queue에 추가한다</li>
<li>다음 process를 선택한다(<strong>select</strong>)</li>
<li>그 process의 state를 변경한다(ready → running)</li>
<li>process의 메모리에서 레지스터 값들을 다 가져오는 등 새 프로세스의 중단지점으로 다 restore한다(<strong>restore</strong>)</li>
<li>바뀐 process를 진행한다</li>
</ol></article></div><div class="right sidebar"><div class="graph "><h3>Graph View</h3><div class="graph-outer"><div id="graph-container" data-cfg="{&quot;drag&quot;:true,&quot;zoom&quot;:true,&quot;depth&quot;:1,&quot;scale&quot;:1.1,&quot;repelForce&quot;:0.5,&quot;centerForce&quot;:0.3,&quot;linkDistance&quot;:30,&quot;fontSize&quot;:0.6,&quot;opacityScale&quot;:1,&quot;showTags&quot;:true,&quot;removeTags&quot;:[]}"></div><svg version="1.1" id="global-graph-icon" xmlns="http://www.w3.org/2000/svg" xmlnsXlink="http://www.w3.org/1999/xlink" x="0px" y="0px" viewBox="0 0 55 55" fill="currentColor" xmlSpace="preserve"><path d="M49,0c-3.309,0-6,2.691-6,6c0,1.035,0.263,2.009,0.726,2.86l-9.829,9.829C32.542,17.634,30.846,17,29,17
	s-3.542,0.634-4.898,1.688l-7.669-7.669C16.785,10.424,17,9.74,17,9c0-2.206-1.794-4-4-4S9,6.794,9,9s1.794,4,4,4
	c0.74,0,1.424-0.215,2.019-0.567l7.669,7.669C21.634,21.458,21,23.154,21,25s0.634,3.542,1.688,4.897L10.024,42.562
	C8.958,41.595,7.549,41,6,41c-3.309,0-6,2.691-6,6s2.691,6,6,6s6-2.691,6-6c0-1.035-0.263-2.009-0.726-2.86l12.829-12.829
	c1.106,0.86,2.44,1.436,3.898,1.619v10.16c-2.833,0.478-5,2.942-5,5.91c0,3.309,2.691,6,6,6s6-2.691,6-6c0-2.967-2.167-5.431-5-5.91
	v-10.16c1.458-0.183,2.792-0.759,3.898-1.619l7.669,7.669C41.215,39.576,41,40.26,41,41c0,2.206,1.794,4,4,4s4-1.794,4-4
	s-1.794-4-4-4c-0.74,0-1.424,0.215-2.019,0.567l-7.669-7.669C36.366,28.542,37,26.846,37,25s-0.634-3.542-1.688-4.897l9.665-9.665
	C46.042,11.405,47.451,12,49,12c3.309,0,6-2.691,6-6S52.309,0,49,0z M11,9c0-1.103,0.897-2,2-2s2,0.897,2,2s-0.897,2-2,2
	S11,10.103,11,9z M6,51c-2.206,0-4-1.794-4-4s1.794-4,4-4s4,1.794,4,4S8.206,51,6,51z M33,49c0,2.206-1.794,4-4,4s-4-1.794-4-4
	s1.794-4,4-4S33,46.794,33,49z M29,31c-3.309,0-6-2.691-6-6s2.691-6,6-6s6,2.691,6,6S32.309,31,29,31z M47,41c0,1.103-0.897,2-2,2
	s-2-0.897-2-2s0.897-2,2-2S47,39.897,47,41z M49,10c-2.206,0-4-1.794-4-4s1.794-4,4-4s4,1.794,4,4S51.206,10,49,10z"></path></svg></div><div id="global-graph-outer"><div id="global-graph-container" data-cfg="{&quot;drag&quot;:true,&quot;zoom&quot;:true,&quot;depth&quot;:-1,&quot;scale&quot;:0.9,&quot;repelForce&quot;:0.5,&quot;centerForce&quot;:0.3,&quot;linkDistance&quot;:30,&quot;fontSize&quot;:0.6,&quot;opacityScale&quot;:1,&quot;showTags&quot;:true,&quot;removeTags&quot;:[]}"></div></div></div><div class="toc desktop-only"><button type="button" id="toc"><h3>Table of Contents</h3><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="fold"><polyline points="6 9 12 15 18 9"></polyline></svg></button><div id="toc-content"><ul class="overflow"><li class="depth-0"><a href="#프로그램-실행에서의-os의-역할" data-for="프로그램-실행에서의-os의-역할">프로그램 실행에서의 OS의 역할</a></li><li class="depth-0"><a href="#프로세스" data-for="프로세스">프로세스</a></li><li class="depth-0"><a href="#pcb에-저장되는-정보들" data-for="pcb에-저장되는-정보들">PCB에 저장되는 정보들</a></li><li class="depth-0"><a href="#system-kernel-user-process" data-for="system-kernel-user-process">System, Kernel, User Process</a></li><li class="depth-0"><a href="#dispatch-context-switch" data-for="dispatch-context-switch">Dispatch, Context switch</a></li><li class="depth-0"><a href="#process-실행과정---2-state-process-model" data-for="process-실행과정---2-state-process-model">Process 실행과정 - 2 state process model</a></li><li class="depth-0"><a href="#sys-call--fork함수" data-for="sys-call--fork함수">sys call : fork()함수</a></li><li class="depth-0"><a href="#termination-condition" data-for="termination-condition">Termination condition</a></li><li class="depth-0"><a href="#process-실행과정---5-state-process-model" data-for="process-실행과정---5-state-process-model">Process 실행과정 - 5 state process model</a></li><li class="depth-0"><a href="#process-swapping---7-state-process-model" data-for="process-swapping---7-state-process-model">Process Swapping - 7 state process model</a></li><li class="depth-0"><a href="#figure-311" data-for="figure-311">Figure 3.11</a></li><li class="depth-0"><a href="#process-creation-과정" data-for="process-creation-과정">Process creation 과정</a></li><li class="depth-0"><a href="#ready-blocked-queue의-구현" data-for="ready-blocked-queue의-구현">Ready, Blocked Queue의 구현</a></li><li class="depth-0"><a href="#interrupt-vs-trap" data-for="interrupt-vs-trap">Interrupt vs trap</a></li><li class="depth-0"><a href="#context-switching이-일어나기까지의-과정" data-for="context-switching이-일어나기까지의-과정">Context switching이 일어나기까지의 과정</a></li></ul></div></div><div class="backlinks "><h3>Backlinks</h3><ul class="overflow"><li><a href="../../../../gardens/os/originals/os.spring.2021.cse.cnu.ac.kr/(충남대)-운영체제-강의록" class="internal">(충남대) 운영체제 강의록</a></li></ul></div></div></div><footer class><hr/><p>Created with <a href="https://quartz.jzhao.xyz/">Quartz v4.1.0</a>, © 2024</p><ul><li><a href="https://github.com/haeramkeem">GitHub</a></li><li><a href="www.linkedin.com/in/haeram-kim-277404220">LinkedIn</a></li><li><a href="mailto:haeram.kim1@gmail.com">Email</a></li></ul></footer></div></body><script type="application/javascript">// quartz/components/scripts/quartz/components/scripts/callout.inline.ts
function toggleCallout() {
  const outerBlock = this.parentElement;
  outerBlock.classList.toggle(`is-collapsed`);
  const collapsed = outerBlock.classList.contains(`is-collapsed`);
  const height = collapsed ? this.scrollHeight : outerBlock.scrollHeight;
  outerBlock.style.maxHeight = height + `px`;
  let current = outerBlock;
  let parent = outerBlock.parentElement;
  while (parent) {
    if (!parent.classList.contains(`callout`)) {
      return;
    }
    const collapsed2 = parent.classList.contains(`is-collapsed`);
    const height2 = collapsed2 ? parent.scrollHeight : parent.scrollHeight + current.scrollHeight;
    parent.style.maxHeight = height2 + `px`;
    current = parent;
    parent = parent.parentElement;
  }
}
function setupCallout() {
  const collapsible = document.getElementsByClassName(
    `callout is-collapsible`
  );
  for (const div of collapsible) {
    const title = div.firstElementChild;
    if (title) {
      title.removeEventListener(`click`, toggleCallout);
      title.addEventListener(`click`, toggleCallout);
      const collapsed = div.classList.contains(`is-collapsed`);
      const height = collapsed ? title.scrollHeight : div.scrollHeight;
      div.style.maxHeight = height + `px`;
    }
  }
}
document.addEventListener(`nav`, setupCallout);
window.addEventListener(`resize`, setupCallout);
</script><script type="module">
          import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.esm.min.mjs';
          const darkMode = document.documentElement.getAttribute('saved-theme') === 'dark'
          mermaid.initialize({
            startOnLoad: false,
            securityLevel: 'loose',
            theme: darkMode ? 'dark' : 'default'
          });
          document.addEventListener('nav', async () => {
            await mermaid.run({
              querySelector: '.mermaid'
            })
          });
          </script><script src="https://cdn.jsdelivr.net/npm/katex@0.16.7/dist/contrib/copy-tex.min.js" type="application/javascript"></script><script src="https://www.googletagmanager.com/gtag/js?id=G-N68CCP1QHG" type="application/javascript"></script><script src="../../../../postscript.js" type="module"></script></html>