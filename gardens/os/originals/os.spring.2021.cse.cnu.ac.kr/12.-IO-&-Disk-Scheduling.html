<!DOCTYPE html>
<html><head><title>12. IO &amp; Disk Scheduling</title><meta charSet="utf-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:title" content="12. IO &amp; Disk Scheduling"/><meta property="og:description" content="충남대학교 컴퓨터공학과 류재철 교수님의 &amp;quot;운영체제 및 실습&amp;quot; 강의를 필기한 내용입니다. 다소 잘못된 내용과 구어적 표현 이 포함되어 있을 수 있습니다. IO Device § Human Reachable : 키보드나 모니터, 마우스같은거 Machine Reachable : USB, 센서같은거 Communication : 통신을 위한 장비 IO장비는 하드웨어면으로나 소프트웨어 면으로나 장비마다 다양하기 때문에 이쪽을 개발하는 것은 전문성을 요구하는 쉽지 않은 일이다 IO Techniques § 구분 § 보면 Programmed IO는 IO 처리를 구현한 프로그램이 있어서 프로세서가 직접 이 프로세스를 실행시키며 디스크에서 파일을 읽어오는 것을 의미한다 Interrupt-Driven IO는 블락이 먹기 전까지 실행하다 IO가 필요해져서 블락을 먹으면 다른 프로세스를 실행하고 IO가 완료되면 인터럽트를 걸어서 다시 복귀하는 형태를 의미한다 Direct Memory Access는 Interrupt Driven IO의 진화버전으로써 프로세서가 아닌 IO처리 담당 프로세서가 별도로 존재해서 걔가 IO를 처리하고 끝나면 인터럽트를 거는 일을 의미한다 Programmed IO와 나머지 둘의 가장 큰 차이점은 Busy Waiting이다 - Programmed IO는 프로세서가 직접 IO처리 프로세스를 실행시키며 IO처리를 해 기존의 프로세스가 기다리는 와중에도 프로세서를 사용하지만 Interrupt-Driven IO나 Direct Memory Access 는 IO처리를 프로세서가 직접 하지 않아 프로세서는 다른 프로세스를 돌릴 수 있게 한다 발전과정 § Programmed IO형태에서 IO 전용의 IO module / Controller가 등장한다 IO module / Controller는 한가지 형태의 IO를 전담하는 것이라고 생각하면 된다 하지만 Interrupt 기능은 없어서 CPU가 수시로 IO가 종료되었는지 확인해줘야 되는 Busy Waiting이 여전히 존재했기 때문에 IO Interrupt가 추가된다 - 얘가 추가되고 나서는 Busy Waiting을 하지 않음 IO module / Controller가 하드와 메모리를 직접적으로 제어하는 DMA가 추가됨 DMA가 IO와 관련된 모든 일을 전담하는 것으로 생각하면 될거같다 IO Module / Controller들을 DMA가 관리하게 되는 것 CPU가 DMA에게 IO를 맡기기만 하면 얘가 알아서 다 처리하는 형태 IO module / Controller가 별도의 프로세서로 분리됨 - IO만을 위한 특별한 Instruction을 실행시키며 IO를 처리한다 4, 5번에서 하드와 메모리를 직접적으로 제어하는 프로세서를 별도로 분리한 것을 IO Channel이라고도 표현한다 이전까지는 DMA도 메인메모리를 공유했지만 이제는 DMA전용의 메모리가 별도로 분리되어서 더 빠르게 작동할 수 있게 됐다 옛날에는 데이터를 주고받는 Bus가 하나여서 여기에 DMA나 IO Module / Controller들이 전부 연결되어있었지만 - Single Bus, Detached DMA bus에는 DMA만 붙고 그 아래 IO Module / Controller들이 있는 형태로 바뀌었다가 - Single Bus, Integrated DMA 이제는 System bus에는 DMA하나만 붙고 그 아래 IO Bus가 별도로 존재해 IO Module / Controller가 사용하는 Bus가 별도로 분리되게 된다 IO 설계 § Efficiency : IO들은 프로세서나 메모리보다 처리속도가 더 늦기 때문에 이런 처리속도가 느린 IO 하드웨어들을 어떻게 효율적으로 관리하는가 Generality : IO의 인터페이스가 다 제각각이어서 그것을 이용하려는 프로그래머가 IO에 따라 다른 방법을 사용해야한다면 매우 불편 - IO의 사용법(인터페이스)을 통일시켜서 간편하게 사용할 수 있게끔 하는 것 위 그림은 세 IO를 예시로 든건데 보면 맨 아래 3개가 하드웨어로 구현된 IO 이다 그리고 그 위에가 OS 레벨 이며 맨 위의 user process에서는 OS가 제공해주는 API들을 이용해 사용자가 프로그램을 짜게 되는 것 우선 Logical Peripheral Device를 보면 Logical IO에서 open, read, write, close등의 API등을 사용자에게 제공한다 그리고 이런 API를 사용해 명령을 내리면 Logical IO에서 그것을 처리해 표준화된 인터페이스를 제공하는 Device IO로 전달하게 된다 Device IO가 이런 표준화된 인터페이스를 제공하기 때문에 우리는 HW레벨의 지식 없이 간편하게 HW를 제어할 수 있는 것이다 Communication Port에서도 동일하게 Communication Architecture을 이용해 사용자에게 API를 제공하고, 그것을 처리해 Device IO로 넘겨주게 된다 File System에서는 일단 Directory Management는 우리가 문자열 형태로 전달한 파일의 경로를 File Descriptor로 바꾸는 역할을 한다 File Descriptor 별거 아니다 - 프로세스는 고유한 pid를 갖고있듯이 파일도 File Descriptor 라는 고유한 번호를 갖게 된다 그리고 File System에서 파일에 대한 Open, Read, Write, Close 명령어를 제공해준다 그리고 Physical Organization에서는 Virtual Address를 Physical Address로 변환하는 등의 일을 하게 된다 Buffering § Data IO size § 일단 Device는 IO로 갖고오는 데이터의 크기에 따라 두가지로 나눌 수 있다 Block Oriented Device - 얘는 블럭(IO에서는 페이지를 블럭이라고 표현한다)단위로 IO를 처리하는 Device를 말한다 보통 Machine Reachable Device가 블럭단위로 IO처리하므로 이놈이 여기에 들어간다 Stream Oriented Device - 예는 바이트나 워드 단위로 IO를 처리하는 Device를 의미한다 보통 Human Reachable Device가 바이트나 워드 단위로 IO를 처리하므로 이놈이 여기에 들어간다 따라서 Block Oriented Device가 블럭단위로 갖고오므로 Stream Oriented Device보다 갖고오는 양이 많다 Buffer § 일단 Buffer라는 것은 IO를 통해 가져온 데이터를 메인메모리의 OS파트에 잠깐 저장하기 위한 용도로의 공간을 의미한다."/><meta property="og:image" content="https://mdg.haeramk.im/static/og-image.png"/><meta property="og:width" content="1200"/><meta property="og:height" content="675"/><link rel="icon" href="../../../../static/icon.png"/><meta name="description" content="충남대학교 컴퓨터공학과 류재철 교수님의 &amp;quot;운영체제 및 실습&amp;quot; 강의를 필기한 내용입니다. 다소 잘못된 내용과 구어적 표현 이 포함되어 있을 수 있습니다. IO Device § Human Reachable : 키보드나 모니터, 마우스같은거 Machine Reachable : USB, 센서같은거 Communication : 통신을 위한 장비 IO장비는 하드웨어면으로나 소프트웨어 면으로나 장비마다 다양하기 때문에 이쪽을 개발하는 것은 전문성을 요구하는 쉽지 않은 일이다 IO Techniques § 구분 § 보면 Programmed IO는 IO 처리를 구현한 프로그램이 있어서 프로세서가 직접 이 프로세스를 실행시키며 디스크에서 파일을 읽어오는 것을 의미한다 Interrupt-Driven IO는 블락이 먹기 전까지 실행하다 IO가 필요해져서 블락을 먹으면 다른 프로세스를 실행하고 IO가 완료되면 인터럽트를 걸어서 다시 복귀하는 형태를 의미한다 Direct Memory Access는 Interrupt Driven IO의 진화버전으로써 프로세서가 아닌 IO처리 담당 프로세서가 별도로 존재해서 걔가 IO를 처리하고 끝나면 인터럽트를 거는 일을 의미한다 Programmed IO와 나머지 둘의 가장 큰 차이점은 Busy Waiting이다 - Programmed IO는 프로세서가 직접 IO처리 프로세스를 실행시키며 IO처리를 해 기존의 프로세스가 기다리는 와중에도 프로세서를 사용하지만 Interrupt-Driven IO나 Direct Memory Access 는 IO처리를 프로세서가 직접 하지 않아 프로세서는 다른 프로세스를 돌릴 수 있게 한다 발전과정 § Programmed IO형태에서 IO 전용의 IO module / Controller가 등장한다 IO module / Controller는 한가지 형태의 IO를 전담하는 것이라고 생각하면 된다 하지만 Interrupt 기능은 없어서 CPU가 수시로 IO가 종료되었는지 확인해줘야 되는 Busy Waiting이 여전히 존재했기 때문에 IO Interrupt가 추가된다 - 얘가 추가되고 나서는 Busy Waiting을 하지 않음 IO module / Controller가 하드와 메모리를 직접적으로 제어하는 DMA가 추가됨 DMA가 IO와 관련된 모든 일을 전담하는 것으로 생각하면 될거같다 IO Module / Controller들을 DMA가 관리하게 되는 것 CPU가 DMA에게 IO를 맡기기만 하면 얘가 알아서 다 처리하는 형태 IO module / Controller가 별도의 프로세서로 분리됨 - IO만을 위한 특별한 Instruction을 실행시키며 IO를 처리한다 4, 5번에서 하드와 메모리를 직접적으로 제어하는 프로세서를 별도로 분리한 것을 IO Channel이라고도 표현한다 이전까지는 DMA도 메인메모리를 공유했지만 이제는 DMA전용의 메모리가 별도로 분리되어서 더 빠르게 작동할 수 있게 됐다 옛날에는 데이터를 주고받는 Bus가 하나여서 여기에 DMA나 IO Module / Controller들이 전부 연결되어있었지만 - Single Bus, Detached DMA bus에는 DMA만 붙고 그 아래 IO Module / Controller들이 있는 형태로 바뀌었다가 - Single Bus, Integrated DMA 이제는 System bus에는 DMA하나만 붙고 그 아래 IO Bus가 별도로 존재해 IO Module / Controller가 사용하는 Bus가 별도로 분리되게 된다 IO 설계 § Efficiency : IO들은 프로세서나 메모리보다 처리속도가 더 늦기 때문에 이런 처리속도가 느린 IO 하드웨어들을 어떻게 효율적으로 관리하는가 Generality : IO의 인터페이스가 다 제각각이어서 그것을 이용하려는 프로그래머가 IO에 따라 다른 방법을 사용해야한다면 매우 불편 - IO의 사용법(인터페이스)을 통일시켜서 간편하게 사용할 수 있게끔 하는 것 위 그림은 세 IO를 예시로 든건데 보면 맨 아래 3개가 하드웨어로 구현된 IO 이다 그리고 그 위에가 OS 레벨 이며 맨 위의 user process에서는 OS가 제공해주는 API들을 이용해 사용자가 프로그램을 짜게 되는 것 우선 Logical Peripheral Device를 보면 Logical IO에서 open, read, write, close등의 API등을 사용자에게 제공한다 그리고 이런 API를 사용해 명령을 내리면 Logical IO에서 그것을 처리해 표준화된 인터페이스를 제공하는 Device IO로 전달하게 된다 Device IO가 이런 표준화된 인터페이스를 제공하기 때문에 우리는 HW레벨의 지식 없이 간편하게 HW를 제어할 수 있는 것이다 Communication Port에서도 동일하게 Communication Architecture을 이용해 사용자에게 API를 제공하고, 그것을 처리해 Device IO로 넘겨주게 된다 File System에서는 일단 Directory Management는 우리가 문자열 형태로 전달한 파일의 경로를 File Descriptor로 바꾸는 역할을 한다 File Descriptor 별거 아니다 - 프로세스는 고유한 pid를 갖고있듯이 파일도 File Descriptor 라는 고유한 번호를 갖게 된다 그리고 File System에서 파일에 대한 Open, Read, Write, Close 명령어를 제공해준다 그리고 Physical Organization에서는 Virtual Address를 Physical Address로 변환하는 등의 일을 하게 된다 Buffering § Data IO size § 일단 Device는 IO로 갖고오는 데이터의 크기에 따라 두가지로 나눌 수 있다 Block Oriented Device - 얘는 블럭(IO에서는 페이지를 블럭이라고 표현한다)단위로 IO를 처리하는 Device를 말한다 보통 Machine Reachable Device가 블럭단위로 IO처리하므로 이놈이 여기에 들어간다 Stream Oriented Device - 예는 바이트나 워드 단위로 IO를 처리하는 Device를 의미한다 보통 Human Reachable Device가 바이트나 워드 단위로 IO를 처리하므로 이놈이 여기에 들어간다 따라서 Block Oriented Device가 블럭단위로 갖고오므로 Stream Oriented Device보다 갖고오는 양이 많다 Buffer § 일단 Buffer라는 것은 IO를 통해 가져온 데이터를 메인메모리의 OS파트에 잠깐 저장하기 위한 용도로의 공간을 의미한다."/><meta name="generator" content="Quartz"/><link rel="preconnect" href="https://fonts.googleapis.com"/><link rel="preconnect" href="https://fonts.gstatic.com"/><link href="../../../../index.css" rel="stylesheet" type="text/css" spa-preserve/><link href="https://cdn.jsdelivr.net/npm/katex@0.16.0/dist/katex.min.css" rel="stylesheet" type="text/css" spa-preserve/><link href="https://fonts.googleapis.com/css2?family=IBM Plex Mono&amp;family=Gowun Batang:wght@400;700&amp;family=Gowun Dodum:ital,wght@0,400;0,600;1,400;1,600&amp;display=swap" rel="stylesheet" type="text/css" spa-preserve/><script src="../../../../prescript.js" type="application/javascript" spa-preserve></script><script type="application/javascript" spa-preserve>const fetchData = fetch(`../../../../static/contentIndex.json`).then(data => data.json())</script></head><body data-slug="gardens/os/originals/os.spring.2021.cse.cnu.ac.kr/12.-IO-&amp;-Disk-Scheduling"><div id="quartz-root" class="page"><div id="quartz-body"><div class="left sidebar"><h1 class="page-title "><a href="../../../..">Madison Digital Garden</a></h1><div class="spacer mobile-only"></div><div class="search "><div id="search-icon"><p>Search</p><div></div><svg tabIndex="0" aria-labelledby="title desc" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 19.9 19.7"><title id="title">Search</title><desc id="desc">Search</desc><g class="search-path" fill="none"><path stroke-linecap="square" d="M18.5 18.3l-5.4-5.4"></path><circle cx="8" cy="8" r="7"></circle></g></svg></div><div id="search-container"><div id="search-space"><input autocomplete="off" id="search-bar" name="search" type="text" aria-label="Search for something" placeholder="Search for something"/><div id="results-container"></div></div></div></div><div class="darkmode "><input class="toggle" id="darkmode-toggle" type="checkbox" tabIndex="-1"/><label id="toggle-label-light" for="darkmode-toggle" tabIndex="-1"><svg xmlns="http://www.w3.org/2000/svg" xmlnsXlink="http://www.w3.org/1999/xlink" version="1.1" id="dayIcon" x="0px" y="0px" viewBox="0 0 35 35" style="enable-background:new 0 0 35 35;" xmlSpace="preserve"><title>Light mode</title><path d="M6,17.5C6,16.672,5.328,16,4.5,16h-3C0.672,16,0,16.672,0,17.5    S0.672,19,1.5,19h3C5.328,19,6,18.328,6,17.5z M7.5,26c-0.414,0-0.789,0.168-1.061,0.439l-2,2C4.168,28.711,4,29.086,4,29.5    C4,30.328,4.671,31,5.5,31c0.414,0,0.789-0.168,1.06-0.44l2-2C8.832,28.289,9,27.914,9,27.5C9,26.672,8.329,26,7.5,26z M17.5,6    C18.329,6,19,5.328,19,4.5v-3C19,0.672,18.329,0,17.5,0S16,0.672,16,1.5v3C16,5.328,16.671,6,17.5,6z M27.5,9    c0.414,0,0.789-0.168,1.06-0.439l2-2C30.832,6.289,31,5.914,31,5.5C31,4.672,30.329,4,29.5,4c-0.414,0-0.789,0.168-1.061,0.44    l-2,2C26.168,6.711,26,7.086,26,7.5C26,8.328,26.671,9,27.5,9z M6.439,8.561C6.711,8.832,7.086,9,7.5,9C8.328,9,9,8.328,9,7.5    c0-0.414-0.168-0.789-0.439-1.061l-2-2C6.289,4.168,5.914,4,5.5,4C4.672,4,4,4.672,4,5.5c0,0.414,0.168,0.789,0.439,1.06    L6.439,8.561z M33.5,16h-3c-0.828,0-1.5,0.672-1.5,1.5s0.672,1.5,1.5,1.5h3c0.828,0,1.5-0.672,1.5-1.5S34.328,16,33.5,16z     M28.561,26.439C28.289,26.168,27.914,26,27.5,26c-0.828,0-1.5,0.672-1.5,1.5c0,0.414,0.168,0.789,0.439,1.06l2,2    C28.711,30.832,29.086,31,29.5,31c0.828,0,1.5-0.672,1.5-1.5c0-0.414-0.168-0.789-0.439-1.061L28.561,26.439z M17.5,29    c-0.829,0-1.5,0.672-1.5,1.5v3c0,0.828,0.671,1.5,1.5,1.5s1.5-0.672,1.5-1.5v-3C19,29.672,18.329,29,17.5,29z M17.5,7    C11.71,7,7,11.71,7,17.5S11.71,28,17.5,28S28,23.29,28,17.5S23.29,7,17.5,7z M17.5,25c-4.136,0-7.5-3.364-7.5-7.5    c0-4.136,3.364-7.5,7.5-7.5c4.136,0,7.5,3.364,7.5,7.5C25,21.636,21.636,25,17.5,25z"></path></svg></label><label id="toggle-label-dark" for="darkmode-toggle" tabIndex="-1"><svg xmlns="http://www.w3.org/2000/svg" xmlnsXlink="http://www.w3.org/1999/xlink" version="1.1" id="nightIcon" x="0px" y="0px" viewBox="0 0 100 100" style="enable-background='new 0 0 100 100'" xmlSpace="preserve"><title>Dark mode</title><path d="M96.76,66.458c-0.853-0.852-2.15-1.064-3.23-0.534c-6.063,2.991-12.858,4.571-19.655,4.571  C62.022,70.495,50.88,65.88,42.5,57.5C29.043,44.043,25.658,23.536,34.076,6.47c0.532-1.08,0.318-2.379-0.534-3.23  c-0.851-0.852-2.15-1.064-3.23-0.534c-4.918,2.427-9.375,5.619-13.246,9.491c-9.447,9.447-14.65,22.008-14.65,35.369  c0,13.36,5.203,25.921,14.65,35.368s22.008,14.65,35.368,14.65c13.361,0,25.921-5.203,35.369-14.65  c3.872-3.871,7.064-8.328,9.491-13.246C97.826,68.608,97.611,67.309,96.76,66.458z"></path></svg></label></div><div class="recent-notes desktop-only"><h3>Recent</h3><ul class="recent-ul"><li class="recent-li"><div class="section"><div class="desc"><h3><a href="../../../.." class="internal">매디쏜 디지딸 갈든</a></h3></div><p class="meta">Dec 16, 2024</p><ul class="tags"></ul></div></li><li class="recent-li"><div class="section"><div class="desc"><h3><a href="../../../../gardens/sw-eng/originals/softwareengineering.fall.2021.cse.cnu.ac.kr/부록---시험대비)-요약정리" class="internal">부록 - 시험대비) 요약정리</a></h3></div><p class="meta">Dec 16, 2024</p><ul class="tags"></ul></div></li><li class="recent-li"><div class="section"><div class="desc"><h3><a href="../../../../gardens/web/originals/webprogramming.fall.2021.cse.cnu.ac.kr/(충남대)-웹-프로그래밍-강의록" class="internal">(충남대) 웹 프로그래밍 강의록</a></h3></div><p class="meta">Dec 16, 2024</p><ul class="tags"></ul></div></li></ul></div></div><div class="center"><div class="page-header"><div class="popover-hint"><h1 class="article-title ">12. IO &amp; Disk Scheduling</h1><p class="content-meta ">Jun 07, 2021, 22 min read</p><ul class="tags "><li><a href="../../../../tags/originals" class="internal tag-link">#originals</a></li><li><a href="../../../../tags/cnu-os21s" class="internal tag-link">#cnu-os21s</a></li></ul></div></div><article class="popover-hint"><blockquote class="callout" data-callout="info">
<div class="callout-title">
                  <div class="callout-icon"><svg xmlns="http://www.w3.org/2000/svg" width="100%" height="100%" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="10"></circle><line x1="12" y1="16" x2="12" y2="12"></line><line x1="12" y1="8" x2="12.01" y2="8"></line></svg></div>
                  <div class="callout-title-inner"><p>충남대학교 컴퓨터공학과 류재철 교수님의 &quot;운영체제 및 실습&quot; 강의를 필기한 내용입니다. </p></div>
                  
                </div>
</blockquote>
<blockquote class="callout" data-callout="warning">
<div class="callout-title">
                  <div class="callout-icon"><svg xmlns="http://www.w3.org/2000/svg" width="100%" height="100%" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="m21.73 18-8-14a2 2 0 0 0-3.48 0l-8 14A2 2 0 0 0 4 21h16a2 2 0 0 0 1.73-3Z"></path><line x1="12" y1="9" x2="12" y2="13"></line><line x1="12" y1="17" x2="12.01" y2="17"></line></svg></div>
                  <div class="callout-title-inner"><p>다소 잘못된 내용과 구어적 표현 이 포함되어 있을 수 있습니다. </p></div>
                  
                </div>
</blockquote>
<h2 id="io-device">IO Device<a aria-hidden="true" tabindex="-1" href="#io-device" class="internal"> §</a></h2>
<ul>
<li><em>Human Reachable</em> : 키보드나 모니터, 마우스같은거</li>
<li><em>Machine Reachable</em> : USB, 센서같은거</li>
<li><em>Communication</em> : 통신을 위한 장비</li>
<li>IO장비는 하드웨어면으로나 소프트웨어 면으로나 장비마다 다양하기 때문에 이쪽을 개발하는 것은 전문성을 요구하는 쉽지 않은 일이다</li>
</ul>
<h2 id="io-techniques">IO Techniques<a aria-hidden="true" tabindex="-1" href="#io-techniques" class="internal"> §</a></h2>
<h3 id="구분">구분<a aria-hidden="true" tabindex="-1" href="#구분" class="internal"> §</a></h3>
<p><img src="../../../../gardens/os/originals/os.spring.2021.cse.cnu.ac.kr/images/12/image1.png" alt="스크린샷 2021-06-13 오전 11.20.03.png"/></p>
<ul>
<li>보면</li>
<li><em>Programmed IO</em>는 IO 처리를 구현한 프로그램이 있어서 프로세서가 직접 이 프로세스를 실행시키며 디스크에서 파일을 읽어오는 것을 의미한다</li>
<li><em>Interrupt-Driven IO</em>는 블락이 먹기 전까지 실행하다 IO가 필요해져서 블락을 먹으면 다른 프로세스를 실행하고 IO가 완료되면 인터럽트를 걸어서 다시 복귀하는 형태를 의미한다</li>
<li><em>Direct Memory Access</em>는 Interrupt Driven IO의 진화버전으로써 프로세서가 아닌 IO처리 담당 프로세서가 별도로 존재해서 걔가 IO를 처리하고 끝나면 인터럽트를 거는 일을 의미한다</li>
<li>Programmed IO와 나머지 둘의 가장 큰 차이점은 <em>Busy Waiting</em>이다 - <em>Programmed IO</em>는 프로세서가 직접 IO처리 프로세스를 실행시키며 IO처리를 해 기존의 프로세스가 기다리는 와중에도 프로세서를 사용하지만 <em>Interrupt-Driven IO</em>나 <em>Direct Memory Access</em> 는 IO처리를 프로세서가 직접 하지 않아 프로세서는 다른 프로세스를 돌릴 수 있게 한다</li>
</ul>
<h3 id="발전과정">발전과정<a aria-hidden="true" tabindex="-1" href="#발전과정" class="internal"> §</a></h3>
<p><img src="../../../../gardens/os/originals/os.spring.2021.cse.cnu.ac.kr/images/12/image2.png" alt="스크린샷 2021-06-13 오전 11.32.23.png"/></p>
<ol>
<li>Programmed IO형태에서</li>
<li>IO 전용의 <em>IO module / Controller</em>가 등장한다
<ul>
<li><em>IO module / Controller</em>는 한가지 형태의 IO를 전담하는 것이라고 생각하면 된다</li>
</ul>
</li>
<li>하지만 Interrupt 기능은 없어서 CPU가 수시로 IO가 종료되었는지 확인해줘야 되는 Busy Waiting이 여전히 존재했기 때문에 <em>IO Interrupt</em>가 추가된다 - 얘가 추가되고 나서는 Busy Waiting을 하지 않음</li>
<li>IO module / Controller가 하드와 메모리를 직접적으로 제어하는 DMA가 추가됨
<ul>
<li>DMA가 IO와 관련된 모든 일을 전담하는 것으로 생각하면 될거같다</li>
<li>IO Module / Controller들을 DMA가 관리하게 되는 것</li>
<li>CPU가 DMA에게 IO를 맡기기만 하면 얘가 알아서 다 처리하는 형태</li>
</ul>
</li>
<li>IO module / Controller가 별도의 프로세서로 분리됨 - IO만을 위한 특별한 Instruction을 실행시키며 IO를 처리한다
<ul>
<li>4, 5번에서 하드와 메모리를 직접적으로 제어하는 프로세서를 별도로 분리한 것을 <em>IO Channel</em>이라고도 표현한다</li>
</ul>
</li>
<li>이전까지는 DMA도 메인메모리를 공유했지만 이제는 DMA전용의 메모리가 별도로 분리되어서 더 빠르게 작동할 수 있게 됐다</li>
</ol>
<p><img src="../../../../gardens/os/originals/os.spring.2021.cse.cnu.ac.kr/images/12/image3.png" alt="스크린샷 2021-06-13 오전 11.47.32.png"/></p>
<ul>
<li>옛날에는 데이터를 주고받는 Bus가 하나여서 여기에 DMA나 IO Module / Controller들이 전부 연결되어있었지만 - <em>Single Bus, Detached DMA</em></li>
<li>bus에는 DMA만 붙고 그 아래 IO Module / Controller들이 있는 형태로 바뀌었다가 - <em>Single Bus, Integrated DMA</em></li>
<li>이제는 System bus에는 DMA하나만 붙고 그 아래 <em>IO Bus</em>가 별도로 존재해 IO Module / Controller가 사용하는 Bus가 별도로 분리되게 된다</li>
</ul>
<h2 id="io-설계">IO 설계<a aria-hidden="true" tabindex="-1" href="#io-설계" class="internal"> §</a></h2>
<ul>
<li><em>Efficiency</em> : IO들은 프로세서나 메모리보다 처리속도가 더 늦기 때문에 이런 처리속도가 느린 IO 하드웨어들을 어떻게 효율적으로 관리하는가</li>
<li><em>Generality</em> : IO의 인터페이스가 다 제각각이어서 그것을 이용하려는 프로그래머가 IO에 따라 다른 방법을 사용해야한다면 매우 불편 - IO의 사용법(인터페이스)을 통일시켜서 간편하게 사용할 수 있게끔 하는 것</li>
</ul>
<p><img src="../../../../gardens/os/originals/os.spring.2021.cse.cnu.ac.kr/images/12/image15.png" alt="스크린샷 2021-06-13 오후 12.00.55.png"/></p>
<ul>
<li>위 그림은 세 IO를 예시로 든건데</li>
<li>보면 <em>맨 아래 3개가 하드웨어로 구현된 IO</em> 이다</li>
<li>그리고 <em>그 위에가 OS 레벨</em> 이며 <em>맨 위의 user process에서는 OS가 제공해주는 API들을 이용해 사용자가 프로그램을 짜게 되는 것</em></li>
<li>우선 <em>Logical Peripheral Device</em>를 보면
<ul>
<li><em>Logical IO</em>에서 open, read, write, close등의 API등을 사용자에게 제공한다</li>
<li>그리고 이런 API를 사용해 명령을 내리면 Logical IO에서 그것을 처리해 표준화된 인터페이스를 제공하는 Device IO로 전달하게 된다</li>
<li>Device IO가 이런 표준화된 인터페이스를 제공하기 때문에 우리는 HW레벨의 지식 없이 간편하게 HW를 제어할 수 있는 것이다</li>
</ul>
</li>
<li><em>Communication Port</em>에서도 동일하게 <em>Communication Architecture</em>을 이용해 사용자에게 API를 제공하고, 그것을 처리해 Device IO로 넘겨주게 된다</li>
<li><em>File System</em>에서는
<ul>
<li>일단 <em>Directory Management</em>는 우리가 문자열 형태로 전달한 파일의 경로를 File Descriptor로 바꾸는 역할을 한다
<ul>
<li><em>File Descriptor</em> 별거 아니다 - 프로세스는 고유한 pid를 갖고있듯이 파일도 File Descriptor 라는 고유한 번호를 갖게 된다</li>
</ul>
</li>
<li>그리고 <em>File System</em>에서 파일에 대한 Open, Read, Write, Close 명령어를 제공해준다</li>
<li>그리고 <em>Physical Organization</em>에서는 Virtual Address를 Physical Address로 변환하는 등의 일을 하게 된다</li>
</ul>
</li>
</ul>
<h2 id="buffering">Buffering<a aria-hidden="true" tabindex="-1" href="#buffering" class="internal"> §</a></h2>
<h3 id="data-io-size">Data IO size<a aria-hidden="true" tabindex="-1" href="#data-io-size" class="internal"> §</a></h3>
<ul>
<li>일단 Device는 IO로 갖고오는 데이터의 크기에 따라 두가지로 나눌 수 있다</li>
<li><em>Block Oriented Device</em> - 얘는 블럭(IO에서는 페이지를 블럭이라고 표현한다)단위로 IO를 처리하는 Device를 말한다
<ul>
<li>보통 Machine Reachable Device가 블럭단위로 IO처리하므로 이놈이 여기에 들어간다</li>
</ul>
</li>
<li><em>Stream Oriented Device</em> - 예는 바이트나 워드 단위로 IO를 처리하는 Device를 의미한다
<ul>
<li>보통 Human Reachable Device가 바이트나 워드 단위로 IO를 처리하므로 이놈이 여기에 들어간다</li>
</ul>
</li>
<li>따라서 <em>Block Oriented Device</em>가 블럭단위로 갖고오므로 <em>Stream Oriented Device</em>보다 갖고오는 양이 많다</li>
</ul>
<h3 id="buffer">Buffer<a aria-hidden="true" tabindex="-1" href="#buffer" class="internal"> §</a></h3>
<p><img src="../../../../gardens/os/originals/os.spring.2021.cse.cnu.ac.kr/images/12/image16.png" alt="스크린샷 2021-06-13 오후 12.28.55.png"/></p>
<ul>
<li>일단 <em>Buffer</em>라는 것은 IO를 통해 가져온 데이터를 메인메모리의 OS파트에 잠깐 저장하기 위한 용도로의 공간을 의미한다.</li>
<li>버퍼라는게 존재하지 않을 때 어떤일이 벌어지는지 보자</li>
<li>유져 프로세스가 page fault가 일어나서 OS에게 특정 페이지를 요청했다고 해보자</li>
<li>그럼 OS는 IO에게 해당 페이지를 가져오라고 시킨 뒤 다른 프로세스를 실행시키게 되는데</li>
<li>IO가 끝나게 되면 버퍼가 없기 때문에 가져온 페이지가 메인메모리의 유저 프로세스 영역으로 들어가게 된다</li>
<li>근데 만약에 유저 프로세스가 블락을 먹은 동안 메모리에 공간이 부족해져서 이놈이 Swap-out당하면 유저 프로세스가 메인메모리에 없기 때문에 IO는 가져온 데이터를 둘 곳이 없어지게 된다</li>
<li>따라서 유저 프로세스는 IO가 완료되지 않았기 때문에 블락이 풀리지 않고 IO입장에서는 데이터를 갖고와도 둘곳이 없기 때문에 IO를 완료하지 못해 계속 블락을 먹은 상태로 있게 된다 - 이것을 <em>Single Process Deadlock</em>이라고 한다
<ul>
<li>즉, 프로세스가 한개여도 버퍼가 없다면 데드락에 걸릴 수 있게 되는 것이다</li>
</ul>
</li>
</ul>
<p><img src="../../../../gardens/os/originals/os.spring.2021.cse.cnu.ac.kr/images/12/image17.png" alt="스크린샷 2021-06-13 오후 12.38.26.png"/></p>
<ul>
<li>따라서 메모리의 OS파트에 버퍼라는 공간을 두어서 유저 프로세스가 Swap-out을 당하더라도 IO가 완료될 수 있도록 하는 것이다.</li>
<li>그리고 이렇게 함으로써 Write에도 좀 더 이점을 가질 수 있다 - 유저 프로세스에서 Write가 일어났을 때 하드디스크를 바로바로 변경시키면 처리량이 많기 때문에 Write가 일어나면 일단 Buffer에 있는 페이지를 변경하고 나중에 하드에 한번에 업데이트 시킬 수 있게 한다</li>
<li>또한 IO의 성능에 대해서도 이점이 있다 - Page Fault가 일어나면 하드디스크로 가기 전에 버퍼를 먼저 찾아서 여기에 이미 내가 원하는 페이지가 존재하는지 찾아보게 된다 - 만약에 있으면 하드에 갈 필요가 없으므로 훨씬 빠르게 Page Fault가 해결됨</li>
</ul>
<p><img src="../../../../gardens/os/originals/os.spring.2021.cse.cnu.ac.kr/images/12/image18.png" alt="스크린샷 2021-06-13 오후 12.45.58.png"/></p>
<ul>
<li>근데 버퍼를 여러개 갖게 되면 하나의 버퍼에 하드에서 가져온 페이지를 쓰는 것과 동시에 다른 프로세스가 다른 버퍼레 접근하여 데이터를 가져갈 수 있으므로</li>
<li>요즘은 OS파트 안에 버퍼를 여러개 두고 여러개의 유저 프로세스가 버퍼들을 나눠서 사용하는 구조인 <em>Circular Buffering</em> 으로 운영된다</li>
</ul>
<h2 id="disk-performance">Disk Performance<a aria-hidden="true" tabindex="-1" href="#disk-performance" class="internal"> §</a></h2>
<p><img src="../../../../gardens/os/originals/os.spring.2021.cse.cnu.ac.kr/images/12/image19.png" alt/></p>
<ul>
<li>일단 디스크는 LP판처럼 생겼고 이와 유사하게 작동한다</li>
<li>먼저 디스크의 한 표면(<em>Surface</em>)에는 여러개의 <em>Track</em>이 존재한다
<ul>
<li>하나의 디스크는 앞면, 뒷면 두개의 Surface를 갖게 된다</li>
</ul>
</li>
<li>그리고 일정한 각도로 Surface를 잘라 만들어진 Track의 한 부분을 <em>Sector</em> 라고 한다</li>
<li>또한 <em>Sector</em>는 여러개의 <em>Block</em>들로 구성되어 있고 어느 Sector든 같은 수의 Block으로 구성되어 있다
<ul>
<li>그 각속도 기억나제? - 디스크 판은 같은 속도로 회전하기 때문에 한 섹터에서 같은 양의 블럭을 가져오기 위해서는 바깥쪽의 블럭은 좀 더 듬성듬성하게 위치하게 된다</li>
</ul>
</li>
<li>그리고 <em>Disk Arm</em>이 있어서 이놈이 Surface를 읽으며 데이터를 읽게 되는 것</li>
<li>따라서 디스크에서 특정 블럭을 찾는 과정은 다음과 같은 세가지의 단계를 거치게 된다
<ol>
<li>일단 Disk Arm이 특정 Track으로 움직이는 작업을 한다 - 이것을 <em>Seek</em>이라고 한다</li>
<li>그리고 Track으로 간 뒤에는 디스크가 회전하며 해당 Sector를 찾는다 - 이것을 <em>Rotational Delay</em>라고 한다</li>
<li>마지막으로 디스크에서 비트들을 읽어 전송하는 <em>Data Transfer</em>과정이 있다</li>
</ol>
</li>
<li>여기에 걸리는 시간을 보면
<ul>
<li><em>Data Transfer</em>는 그냥 읽어서 전송하는 것이기 때문에 시간을 별로 잡아먹지 않는다</li>
<li>하지만 <em>Seek</em>의 경우에는 Disk Arm이 물리적으로 움직여야 되므로 가장 오래 걸리게 되고</li>
<li><em>Rotational Delay</em>도 디스크를 회전시켜야 되기 때문에 적지 않은 시간이 걸린다</li>
<li>즉, Seek > Rotational Delay > Data Transfer 의 순서대로 시간이 소요된다</li>
</ul>
</li>
<li>특정 주소를 이용해 디스크의 위치를 알아내는 과정은 다음과 같다
<ol>
<li>일단 Logical Address를 이용해 Page# 을 알아낸다</li>
<li>그리고 그 Page# 를 Block# 로 바꾸게 된다</li>
<li>그리고 Block# 을 이용해 해당 Block이 어느 Track에 있는지 알아낸다</li>
</ol>
<ul>
<li>이 과정이 정확히 어떻게 이루어지는지는 안알랴줌</li>
</ul>
</li>
<li>근데 이제 Seek이 제일 오래 걸리기 때문에 이 시간을 줄여야 되고 따라서 일련의 Track# 들이 주어졌을 때 Disk Arm을 어떻게 움직여서 어떤 순서로 Track을 읽어야 할지가 <em>Disk Scheduling</em>이다</li>
</ul>
<h2 id="disk-scheduling">Disk Scheduling<a aria-hidden="true" tabindex="-1" href="#disk-scheduling" class="internal"> §</a></h2>
<p><img src="../../../../gardens/os/originals/os.spring.2021.cse.cnu.ac.kr/images/12/image5.png" alt="스크린샷 2021-06-13 오후 1.20.29.png"/></p>
<p><img src="../../../../gardens/os/originals/os.spring.2021.cse.cnu.ac.kr/images/12/image4.png" alt="스크린샷 2021-06-13 오후 1.20.14.png"/></p>
<ul>
<li><em>FIFO</em> : 말그대로 들어온 순서대로 처리하는 것
<ul>
<li>Track# 이 Arm이 효율적으로 움직일 수 있는 동선대로 들어오는게 아니기 때문에 가장 최악의 시간이 걸린다</li>
</ul>
</li>
<li><em>SSTF(Shortest Serve Time First)</em> : 얘는 지금 현재의 위치에서 가장 가까이 있는 놈을 처리한다
<ul>
<li>보면 가장 효율적으로 움직이기 때문에 Seek가 제일 적게 걸리는 것을 알 수 있다</li>
<li>하지만 매번 Queue를 전부 확인해서 나랑 가장 가까운 놈을 찾아야 하기 때문에 실제로 사용하기에는 무리가 있다</li>
</ul>
</li>
<li><em>SCAN</em> : 얘는 엘리베이터마냥 한방향으로 가면서 그 방향에 있는애들 다 처리하고, 끝나면 다시 방향을 틀어 그 방향에 있는애들 다 처리하는 방식이다</li>
<li><em>C-SCAN</em> : SCAN은 양방향으로 움직이며 해당 방향에 있는 애들을 다 처리하는 반면, 얘는 한방향으로만 움직인다 - 한방향으로 움직이며 애들을 다 처리하고, 처리가 끝나면 다시 0번으로 복귀해 한방향으로 움직이게 되는 것
<ul>
<li>즉, 0번으로 복귀할때에는 처리를 안한다</li>
<li>이것은 하드웨어적 관점에서 봤을 때 한뱡향으로만 움직이는게 더 좋을수도 있기 때문에 이런 알고리즘을 채택하는 것</li>
</ul>
</li>
</ul>
<p><img src="../../../../gardens/os/originals/os.spring.2021.cse.cnu.ac.kr/images/12/image6.png" alt="스크린샷 2021-06-13 오후 1.27.41.png"/></p>
<ul>
<li><em>N-Step SCAN</em> : 이전의 SCAN에서는 큐를 하나만 두고 이 큐 안에 있는 애들을 처리하는 방식이었는데
<ul>
<li>근데 SCAN방식은 요청순서와는 전혀 무관하게 작동하므로 약간 형평성의 문제가 있을 수 있다</li>
<li>따라서 이러한 요청순서를 어느정도 반영하여 SCAN을 돌리는 것이 <em>N-Step SCAN</em>이다</li>
<li>얘는 일단 크기가 N인 큐를 여러개 갖고 여기에 들어온 순서대로 넣는다 - 큐 하나가 다 차면 그다음 큐로 가서 채우는 방식으로</li>
<li>그리고 하나의 큐 안에서는 SCAN방식으로 작동하게 함으로 일찍 들어온놈이 재수없게 나중에 처리되는 일을 줄인다</li>
<li>따라서 N = 1이면 그냥 FIFO와 다를바가 없고 N이 엄청 크다면 SCAN과 다를바가 없는 방식이 된다</li>
</ul>
</li>
</ul>
<p><img src="../../../../gardens/os/originals/os.spring.2021.cse.cnu.ac.kr/images/12/image7.png" alt="스크린샷 2021-06-13 오후 1.32.42.png"/></p>
<ul>
<li><em>FSCAN</em>은 큐를 단 두개만 갖는 N-Step이라고 할 수 있다</li>
<li>즉, 큐를 두개 가지고 하나를 채운 뒤 SCAN으로 처리하고, 그동안 다른 하나를 채워 SCAN처리하고 앞선 큐가 다 처리되어 비워졌으므로 다시 여기에 채우는 식으로 작동한다</li>
</ul>
<h2 id="raid">RAID<a aria-hidden="true" tabindex="-1" href="#raid" class="internal"> §</a></h2>
<ul>
<li><em>RAID(Redundant Array of Independent Disk)</em> 라는 것은 별도의 디스크를 두어 디스크의 속도를 빠르게 함과 동시에 디스크가 손상되는 것을 막는(<em>Fault Tolerant</em>) 7가지 기법을 의미한다</li>
</ul>
<h3 id="level-0">Level 0<a aria-hidden="true" tabindex="-1" href="#level-0" class="internal"> §</a></h3>
<p><img src="../../../../gardens/os/originals/os.spring.2021.cse.cnu.ac.kr/images/12/image8.png" alt="스크린샷 2021-06-13 오후 1.45.00.png"/></p>
<ul>
<li>일단 <em>Strip</em>이라는 것은 <em>Session</em>이랑 같은말이다 - 일련의 블럭들</li>
<li>여러개의 블럭으로 구성된 파일을 하나의 디스크에 넣으면 하나의 IO에 의해 처리되므로 블럭들을 Serial하게 처리할 수 밖에 없다</li>
<li>따라서 파일의 여러 블락들을 여러 디스크에 나눠 담아 여러개의 IO에 의해 처리되게 함으로 Parallel하게 처리되게 한다</li>
<li><em>Level 0</em>에서는 그냥 이렇게 나눠담는 방법만 사용하여 속도에만 집중한 방법이다</li>
<li>Error에 대한 대비책은 고려하지 않으므로(<em>Non-redundant</em>) 진정한 의미의 RAID와는 좀 거리가 있다</li>
</ul>
<h3 id="level-1">Level 1<a aria-hidden="true" tabindex="-1" href="#level-1" class="internal"> §</a></h3>
<p><img src="../../../../gardens/os/originals/os.spring.2021.cse.cnu.ac.kr/images/12/image9.png" alt="스크린샷 2021-06-13 오후 1.49.14.png"/></p>
<ul>
<li>얘는 이제 Level 0과 동일하게 하되, 동일한 Level 0구성을 두개를 놓아 하나에서 문제가 생겼을 때 다른 하나로 바로 이동해 처리하는 구조이다</li>
<li>마치 like 백업을 두는 구조 - <em>이중화(Mirrored)</em></li>
<li>요즘은 이 방법을 많이 사용하지만 Disk가 많이 필요하다는 단점이 존재한다</li>
</ul>
<h3 id="level-2">Level 2<a aria-hidden="true" tabindex="-1" href="#level-2" class="internal"> §</a></h3>
<p><img src="../../../../gardens/os/originals/os.spring.2021.cse.cnu.ac.kr/images/12/image10.png" alt="스크린샷 2021-06-13 오후 1.52.16.png"/></p>
<ul>
<li>얘는 똑같은거 두개를 놓는게 아니라 <em>Hamming Code</em>라는 Error Correction Code를 별도의 디스크에 저장해 디스크의 갯수를 좀 줄이는 방법이다</li>
</ul>
<h3 id="level-3">Level 3<a aria-hidden="true" tabindex="-1" href="#level-3" class="internal"> §</a></h3>
<p><img src="../../../../gardens/os/originals/os.spring.2021.cse.cnu.ac.kr/images/12/image11.png" alt="스크린샷 2021-06-13 오후 1.55.36.png"/></p>
<ul>
<li>얘는 Hamming Code 가 아닌 비트 단위(<em>Bit-Interleaved</em>)의 Parity bit을 이용해 Error Correction에서는 한계가 있지만 디스크의 갯수를 더욱더 줄이는 방법</li>
<li>Parity Bit은 <em>Single Bit Error</em>에 대해서는 Correction이 가능하지만 <em>Double Bit Error</em>에 대해서는 Detection만 가능하다는 점에 있어서 한계가 있다</li>
</ul>
<h3 id="level-4">Level 4<a aria-hidden="true" tabindex="-1" href="#level-4" class="internal"> §</a></h3>
<p><img src="../../../../gardens/os/originals/os.spring.2021.cse.cnu.ac.kr/images/12/image12.png" alt="스크린샷 2021-06-13 오후 1.57.43.png"/></p>
<ul>
<li>얘는 비트 단위가 아닌 블럭 단위(<em>Block-Level</em>)로 Parity Bit을 구성해 Parity Bit를 더 줄이고 Error Detection연산도 줄이는 방법이다</li>
</ul>
<h3 id="level-5">Level 5<a aria-hidden="true" tabindex="-1" href="#level-5" class="internal"> §</a></h3>
<p><img src="../../../../gardens/os/originals/os.spring.2021.cse.cnu.ac.kr/images/12/image13.png" alt="스크린샷 2021-06-13 오후 2.00.08.png"/></p>
<ul>
<li>Level 3이나 4같은 경우에는 Parity Bit이 디스크 하나에 몰려있기 때문에 해당 디스크를 너무 많이 참조하고 Write가 발생할때마다 해당 디스크에 가서 Parity Bit를 다시 계산해줘야 하므로 <em>Bottleneck</em>현상(트래픽이 몰리는 것)이 일어날 수 있다 - 몰린다는 뜻</li>
<li>따라서 Parity Bit을 분산하여 배치해 이러한 문제를 막는 기법이 <em>Level 5</em> 이다 - <em>Distributed Parity</em></li>
</ul>
<h3 id="level-6">Level 6<a aria-hidden="true" tabindex="-1" href="#level-6" class="internal"> §</a></h3>
<p><img src="../../../../gardens/os/originals/os.spring.2021.cse.cnu.ac.kr/images/12/image14.png" alt="스크린샷 2021-06-13 오후 2.03.28.png"/></p>
<ul>
<li>얘는 Parity Bit을 두개를 계산하여 저장(<em>Dual Redundancy</em>)하여 더 Error Correction의 정확성을 높이는 방법이다</li>
</ul></article></div><div class="right sidebar"><div class="graph "><h3>Graph View</h3><div class="graph-outer"><div id="graph-container" data-cfg="{&quot;drag&quot;:true,&quot;zoom&quot;:true,&quot;depth&quot;:1,&quot;scale&quot;:1.1,&quot;repelForce&quot;:0.5,&quot;centerForce&quot;:0.3,&quot;linkDistance&quot;:30,&quot;fontSize&quot;:0.6,&quot;opacityScale&quot;:1,&quot;showTags&quot;:true,&quot;removeTags&quot;:[]}"></div><svg version="1.1" id="global-graph-icon" xmlns="http://www.w3.org/2000/svg" xmlnsXlink="http://www.w3.org/1999/xlink" x="0px" y="0px" viewBox="0 0 55 55" fill="currentColor" xmlSpace="preserve"><path d="M49,0c-3.309,0-6,2.691-6,6c0,1.035,0.263,2.009,0.726,2.86l-9.829,9.829C32.542,17.634,30.846,17,29,17
	s-3.542,0.634-4.898,1.688l-7.669-7.669C16.785,10.424,17,9.74,17,9c0-2.206-1.794-4-4-4S9,6.794,9,9s1.794,4,4,4
	c0.74,0,1.424-0.215,2.019-0.567l7.669,7.669C21.634,21.458,21,23.154,21,25s0.634,3.542,1.688,4.897L10.024,42.562
	C8.958,41.595,7.549,41,6,41c-3.309,0-6,2.691-6,6s2.691,6,6,6s6-2.691,6-6c0-1.035-0.263-2.009-0.726-2.86l12.829-12.829
	c1.106,0.86,2.44,1.436,3.898,1.619v10.16c-2.833,0.478-5,2.942-5,5.91c0,3.309,2.691,6,6,6s6-2.691,6-6c0-2.967-2.167-5.431-5-5.91
	v-10.16c1.458-0.183,2.792-0.759,3.898-1.619l7.669,7.669C41.215,39.576,41,40.26,41,41c0,2.206,1.794,4,4,4s4-1.794,4-4
	s-1.794-4-4-4c-0.74,0-1.424,0.215-2.019,0.567l-7.669-7.669C36.366,28.542,37,26.846,37,25s-0.634-3.542-1.688-4.897l9.665-9.665
	C46.042,11.405,47.451,12,49,12c3.309,0,6-2.691,6-6S52.309,0,49,0z M11,9c0-1.103,0.897-2,2-2s2,0.897,2,2s-0.897,2-2,2
	S11,10.103,11,9z M6,51c-2.206,0-4-1.794-4-4s1.794-4,4-4s4,1.794,4,4S8.206,51,6,51z M33,49c0,2.206-1.794,4-4,4s-4-1.794-4-4
	s1.794-4,4-4S33,46.794,33,49z M29,31c-3.309,0-6-2.691-6-6s2.691-6,6-6s6,2.691,6,6S32.309,31,29,31z M47,41c0,1.103-0.897,2-2,2
	s-2-0.897-2-2s0.897-2,2-2S47,39.897,47,41z M49,10c-2.206,0-4-1.794-4-4s1.794-4,4-4s4,1.794,4,4S51.206,10,49,10z"></path></svg></div><div id="global-graph-outer"><div id="global-graph-container" data-cfg="{&quot;drag&quot;:true,&quot;zoom&quot;:true,&quot;depth&quot;:-1,&quot;scale&quot;:0.9,&quot;repelForce&quot;:0.5,&quot;centerForce&quot;:0.3,&quot;linkDistance&quot;:30,&quot;fontSize&quot;:0.6,&quot;opacityScale&quot;:1,&quot;showTags&quot;:true,&quot;removeTags&quot;:[]}"></div></div></div><div class="toc desktop-only"><button type="button" id="toc"><h3>Table of Contents</h3><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="fold"><polyline points="6 9 12 15 18 9"></polyline></svg></button><div id="toc-content"><ul class="overflow"><li class="depth-0"><a href="#io-device" data-for="io-device">IO Device</a></li><li class="depth-0"><a href="#io-techniques" data-for="io-techniques">IO Techniques</a></li><li class="depth-1"><a href="#구분" data-for="구분">구분</a></li><li class="depth-1"><a href="#발전과정" data-for="발전과정">발전과정</a></li><li class="depth-0"><a href="#io-설계" data-for="io-설계">IO 설계</a></li><li class="depth-0"><a href="#buffering" data-for="buffering">Buffering</a></li><li class="depth-1"><a href="#data-io-size" data-for="data-io-size">Data IO size</a></li><li class="depth-1"><a href="#buffer" data-for="buffer">Buffer</a></li><li class="depth-0"><a href="#disk-performance" data-for="disk-performance">Disk Performance</a></li><li class="depth-0"><a href="#disk-scheduling" data-for="disk-scheduling">Disk Scheduling</a></li><li class="depth-0"><a href="#raid" data-for="raid">RAID</a></li><li class="depth-1"><a href="#level-0" data-for="level-0">Level 0</a></li><li class="depth-1"><a href="#level-1" data-for="level-1">Level 1</a></li><li class="depth-1"><a href="#level-2" data-for="level-2">Level 2</a></li><li class="depth-1"><a href="#level-3" data-for="level-3">Level 3</a></li><li class="depth-1"><a href="#level-4" data-for="level-4">Level 4</a></li><li class="depth-1"><a href="#level-5" data-for="level-5">Level 5</a></li><li class="depth-1"><a href="#level-6" data-for="level-6">Level 6</a></li></ul></div></div><div class="backlinks "><h3>Backlinks</h3><ul class="overflow"><li><a href="../../../../gardens/os/originals/os.spring.2021.cse.cnu.ac.kr/(충남대)-운영체제-강의록" class="internal">(충남대) 운영체제 강의록</a></li></ul></div></div></div><footer class><hr/><p>Created with <a href="https://quartz.jzhao.xyz/">Quartz v4.1.0</a>, © 2024</p><ul><li><a href="https://github.com/haeramkeem">GitHub</a></li><li><a href="www.linkedin.com/in/haeram-kim-277404220">LinkedIn</a></li><li><a href="mailto:haeram.kim1@gmail.com">Email</a></li></ul></footer></div></body><script type="application/javascript">// quartz/components/scripts/quartz/components/scripts/callout.inline.ts
function toggleCallout() {
  const outerBlock = this.parentElement;
  outerBlock.classList.toggle(`is-collapsed`);
  const collapsed = outerBlock.classList.contains(`is-collapsed`);
  const height = collapsed ? this.scrollHeight : outerBlock.scrollHeight;
  outerBlock.style.maxHeight = height + `px`;
  let current = outerBlock;
  let parent = outerBlock.parentElement;
  while (parent) {
    if (!parent.classList.contains(`callout`)) {
      return;
    }
    const collapsed2 = parent.classList.contains(`is-collapsed`);
    const height2 = collapsed2 ? parent.scrollHeight : parent.scrollHeight + current.scrollHeight;
    parent.style.maxHeight = height2 + `px`;
    current = parent;
    parent = parent.parentElement;
  }
}
function setupCallout() {
  const collapsible = document.getElementsByClassName(
    `callout is-collapsible`
  );
  for (const div of collapsible) {
    const title = div.firstElementChild;
    if (title) {
      title.removeEventListener(`click`, toggleCallout);
      title.addEventListener(`click`, toggleCallout);
      const collapsed = div.classList.contains(`is-collapsed`);
      const height = collapsed ? title.scrollHeight : div.scrollHeight;
      div.style.maxHeight = height + `px`;
    }
  }
}
document.addEventListener(`nav`, setupCallout);
window.addEventListener(`resize`, setupCallout);
</script><script type="module">
          import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.esm.min.mjs';
          const darkMode = document.documentElement.getAttribute('saved-theme') === 'dark'
          mermaid.initialize({
            startOnLoad: false,
            securityLevel: 'loose',
            theme: darkMode ? 'dark' : 'default'
          });
          document.addEventListener('nav', async () => {
            await mermaid.run({
              querySelector: '.mermaid'
            })
          });
          </script><script src="https://cdn.jsdelivr.net/npm/katex@0.16.7/dist/contrib/copy-tex.min.js" type="application/javascript"></script><script src="https://www.googletagmanager.com/gtag/js?id=G-N68CCP1QHG" type="application/javascript"></script><script src="../../../../postscript.js" type="module"></script></html>