<!DOCTYPE html>
<html><head><title>12. TELNET, Email, File Transfer</title><meta charSet="utf-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:title" content="12. TELNET, Email, File Transfer"/><meta property="og:description" content="충남대학교 컴퓨터공학과 김상하 교수님의 &amp;quot;컴퓨터 네트워크&amp;quot; 강의를 필기한 내용입니다. 다소 잘못된 내용과 구어적 표현 이 포함되어 있을 수 있습니다. TELNET § Remote Logging을 위한 프로토콜인데 요즘의 클라우드 컴퓨팅마냥 옛날에도 조금 다른 형태의 클라우드 비스무리한게 서비스되었다 강력한 CPU를 가진 중앙 컴퓨터가 있고, 거기에 간단한 CPU를 가진 컴퓨터들이 원격으로 접속해서 작업을 요청하고 그 결과를 받는 것 - Timesharing Environment라고 한다 Terminal을 이용해 서버와 클라이언트가 소통하는데 이게 실제로는 사용자가 자기컴퓨터갖고 노는게 아니기 때문에 Virtual Terminal Service라는 말을 사용함 서버에 여러 사용자가 각자의 공간과 접근권한, ID, PW등을 갖는 것을 Logging이라고 한다 이때 Local 환경과 Remote환경의 차이를 줄이기 위한 프로토콜이 TELNET인 것이다 ASCII, Encoding Issue § 일단 뭐 ASCII(American Standard Code for Information Interchange) 가 뭔지 이미 알고 있겠지만 화면에 표시될 수 있는 문자들 및 여러 컨트롤 명령들을 8비트로 매핑해놓은 것이다 그래서 구성이 어케되냐면 8비트(1바이트)이기 때문에 0~255까지의 숫자로 매핑이 되는데 1~31까지는 화면에 출력되지 않는(Non-Printable) 시스템 코드 이다 뭐 종종 보이는 CR(커서 이동), LF(개행)등이 여기에 드감 32~127까지는 화면에 출력되는(Printable) 코드 이다 알파벳 대소문자와 &amp;lt;, &amp;gt; @ 등등의 여러 기호들이 여기에 드감 그리고 128~255까지는 운영체제나 프로그램에서 자율적으로 매핑해서 사용할 수 있는 코드 이다 ctrl + D같은애들이 숫자로 변환되고 이게 각자의 운영체제나 프로그램에 맞게 해석되어 사용됨 근데 여기서 문제가 뭐냐면 0~127까지는 표준으로 정해져있지만 128부터는 자율적으로 프로그래밍될 수 있게 함으로써 환경이 달라지면 다르게 해석된다는 것이다 예를들어서 DOS에서는 EOF가 ctrl + Z이지만 UNIX에서는 ctrl + D로 매핑되어있는 것 그리고 ASCII말고 다른 인코딩 포맷을 사용하는 운영체제나 프로그램도 존재한다 DOS나 UNIX는 ASCII를 사용하지만 Windows NT나 IBM S/390같은애들은 Unicode나 EBCDIC같은 인코딩 방식을 사용하는 등 따라서 환경이 달라져도 원래 의도에 맞게 해석되도록 변환하는 놈이 필요함 Local Log in § TELNET의 작동원리를 정확하게 이해하기 위해서는 일단 Local환경에서 어떻게 Logging이 되는지 알아볼 필요가 있다 우리가 Terminal 창을 켜서 키보드를 하나 누르면 다음과 같은 일이 일어난다 키보드가 눌린 키보드에 대한 전기신호를 숫자의 형태로 Terminal Driver에게 보낸다 여기서 알아야할게 키보드가 보내는 숫자 전기 신호는 뭐 ASCII같은 인코딩을 사용하는게 아니라 해당 키보드에서 사용하는 독자적인 수치를 이용한다는 것이다 그럼 Terminal Driver는 그 전기 신호를 운영체제가 알아들을 수 있는(사용하고 있는) 인코딩 방식으로 변환해서 운영체제에게 전달한다 즉, 키보드가 만들어낸 전기 신호를 운영체제가 알아들을 수 있는 ASCII 등의 포맷으로 인코딩하는 것이 Terminal Driver가 하는 일이다 운영체제는 Terminal Driver가 준거를 보고 그에 맞는 Application Program에게 전달하게 된다 예를들면 이렇게 된다는거임 Terminal창을 열고 cd a를 칠라고 했는데 실수로 cd ab를 쳐서 백스페이스를 눌렀을때 키보드가 생성해내는 Stream을 예를들어서 1 2 3 4 5 6이라고 해보자 - 걍 예시임 1이 c에 대한 신호고 2가 d에 대한 신호고 스페이스바가 3이고 뭐 이런식임 그럼 Terminal Driver는 저거를 받아들고 (운영체제가 ASCII를 사용한다는 가정하에) 66 67 20 64 65 07로 번역해서 운영체제한테 전달한다 그럼 운영체제가 뭐 zsh같은 쉘한테 “cd ab를 출력한 다음에 b를 화면에서 지워라” 같은 메세지를 전달하게 되는 것이다 Remote Log in § 근데 위에서 말한거같은 Timesharing Environment에서는 Local과 Remote의 운영체제나 프로그램등이 다를 가능성이 농후하다 따라서 저런걸 이용하기 위해서는 Encoding 방식을 변환해야 될 필요가 있고 그걸 TELNET에서 지원하는거다 이놈의 핵심 원리는 운영체제 등의 환경에 종속적인 인코딩을 환경에 종속적이지 않은 인코딩인 NVT(Network Virtual Terminal) 으로 변환해서 상대방에게 보내고, 상대방이 그걸 받으면 그걸 자신의 환경에 맞게 변환해서 사용하게 된다는 것이다 NVT(Network Virtual Terminal) 에 대한 얘기를 좀 해보면 위에서 0~127까지는 표준화가 되어있지만 128이후로는 각기 다르다고 했잖여 따라서 NVT(Network Virtual Terminal) 에서도 127까지는 ASCII와 동일하지만 그 이후부터는 독자적인 포맷을 사용함 그리고 이런 포맷으로 TELNET끼리 통신한 다음 각자의 Local에 맞게 인코딩방식을 바꾸는거다 0~127까지는 최상위비트가 0이므로 0으로 시작할 경우에는 데이터 코드로 인식하고 이것에 대해서는 별도의 번역을 하지 않지만 128~255까지는 최상위비트가 1이므로 1로 시작할 경우에는 컨트롤 코드로 인식하고 운영체제에 맞는 번역을 진행하게 된다 이제 작동과정을 보면 Local에서 작동하는건 동일하게 이루어진다 - 키보드 신호가 Local의 운영체제에 맞는 포맷으로 인코딩되어 운영체제에 전달된다 그럼 그 다음에는 운영체제가 Application인 TELNET Client에게 Local Env Encoding Stream을 전달한다 키보드신호가 아니고 Local 운영체제가 사용하는 인코딩으로 도착한다는거 헷갈리지 말그라 TELNET Client는 해당 Stream을 NVT(Network Virtual Terminal) 로 변환한 다음 TCP / IP를 이용해 Server에게 보낸다 주목해야될거는 TELNET이 TCP / IP를 이용한다는 것과 만국공통어 정도로 비유될 수 있는 NVT(Network Virtual Terminal) 로 번역된다는 거다 그럼 그걸 Server에서는 TCP / IP를 통해 받아서 TELNET Server까지 올라가겠지 TELNET Server는 NVT를 받은 뒤에 자신의 운영체제가 이해할수있는(Understandable)인코딩으로 변환해서 Pseudo-Terminal Driver에게 보낸다 여기서 헷갈릴만한게 TELNET Server가 번역한 다음에 OS가 아닌 Pseudo-Terminal Driver에게 보낸다는 것 이다 이렇게 하는 이유는 OS는 무조건 Terminal Driver한테서만 받도록 설계되어 있기 때문에 TELNET Server가 직접적으로 OS한테 보내지 못하고 저런 가짜 Terminal Driver 를 통해 보내게 되는 것 Pseudo-Terminal Driver는 그걸 OS에게 전달하고 OS가 그에 맞는 Application Program에게 Stream을 전달한다 그래서 위의 그림처럼 표현할 수도 있더라 예시임 - 이런식으로 진행된다 Electronic Mail Service § Architecture § 여기서 System이라는 말이 종종 나오는데 이건 Mail Server 와 LAN으로 연결되어있는 범위정도로 이해하면 될거같다 Scenario 1 - Both Participant are Connected Direclty to the Same System § 회사 사내 망에 송수신자 모두가 연결되어있는 경우 정도로 이해하면 된다 여기서 User Agent는 메일을 작성하거나 출력하거나 목록을 보여주는 등의 사용자와 소통하는 작업과 (서버랑 같은 시스템에 있을 경우) 메일 서버의 메일 박스에 넣어놓거나 가져오는 정도의 메일 송수신이 가능한 프로세스라고 생각하면 된다 따라서 모든 참여자가 같은 시스템에 연결되어있을때 에는 위 그림처럼 사용자 각각에 대한 메일박스들을 가지고 있는 메일서버와 UA(User Agent) 만 있으면 메일을 주고받을 수 있음 송신자가 UA를 통해 메일을 작성하고 전송하기를 하면 UA는 그걸 Mail Server의 수신자 메일박스에 넣고, 수신자는 메일박스에 있는 메일을 받아보게 되는 과정으로 전송된다 Scenario 2 - Both Participants are Connected to Separate System § 이건 내가 사내망에 접속되어있고 다른 사내망에 접속되어있는 사람한테 보내는 경우 정도로 생각하면 된다 시스템에서 시스템으로 메일을 보내기 위해서는 MTA(Main Transfer Agent) 가 필요하다 MTA에 대해 기억할것은 얘는 Client-Server모델을 이용하기 때문에 Client의 적극적인 송신에 Server는 수동적으로 수신할 수 밖에 없다는 것이다 즉, Client가 메일을 보내고 Server가 받기 때문에 하나의 Client-Server Pair에 한해서, 그리고 실제 메시지에 한해서는 단방향 통신이라고 말할 수 있는거다 이말을 오해하면 안되는게 그렇다고 Server가 Client에게 통신을 안한다는게 아니고 실제 메일이 전달되는거에 한해서만 단방향이라는 것 - 뭐 뒤에서도 배우겠지만 Connection과 Terminate등의 절차를 거치며 Control Message는 양방향으로 주고받게 된다 어쨋든 모든 참여자가 시스템에 연결되어있지만 시스템이 다를 경우 에는 위 그림처럼 UA를 통해 시스템에게 메일을 보내면 그걸 MTA Cilent가 다른 시스템으로 보내고, 다른 시스템에 있는 MTA Server가 그걸 받아서 메일함에 넣어서 수신자가 가져가게 되는 과정이 이루어진다 따라서 UA 두개와 한쌍의 MTA Client-Server가 필요함 Scenario 3 - Some Participant are not Connected to System § 이건 내가 집에서 다른 사내망에 연결되어있는 사람에게 메일을 보내는 경우 정도로 생각하면 되는데 송신자가 자신의 메일 서버 시스템에 연결되어있지 않기 때문에 송신자는 자신의 디바이스에 있는 MTA Client로 자신의 메일 서버 시스템의 MTA Server로 우선 메일을 보내는 작업을 한다 그럼 그 다음부터는 Scenario 2와 동일함 - 수신자의 메일 서버 시스템의 MTA Server로 메일을 보내게 되고 그럼 MTA Server가 메일박스에 넣어놓음으로써 수신자가 받아가는 것 따라서 이 경우에는 두개의 UA와 두개의 MTA Client-Server 쌍이 필요하게 됨 Scenario 4 - Both Participant are not Connected to System § 이게 제일 일반적인 경우임 - 내가 집에서 다른 집에 있는 사람한테 메일을 보내는 경우 여기서는 수신자가 메일을 가져가는 과정 외에는 전부 동일하다 - MTA Client로 자신의 Mail Server의 MTA Server 에게 보내고, 거기서는 또 Mail Server의 MTA Client로 상대방의 Mail Server의 MTA Server에게 보내면 메일함에 담기게 됨 근데 이경우에는 그냥 수신자에게 메일함에 있는것을 줄 수 있는게 아니다 - Mail Server가 수신자에게 주려고 해도 저놈이 출무중이면(뭐 컴터가 꺼져있다거나) 메일을 받지 못하기 때문 그리고 저넘이 언제 접속할지도 모름 - 따라서 Mail Server는 저놈이 달라고 할때까지 암것도 안하는 아몰랑 전략을 취한다 즉, 수신자가 Mail Server에게 나에게 온 메일을 자기한테 달라고 요청 하게 되는 것 이런걸 대행해주는 프로세스를 MAA(Mail Access Agent) 라고 하는데 수신자측이 메일을 받으니까 MAA Server일거라고 생각하면 경기도 오산시 오산낙지다 메일을 달라고 요청 해야되니까 통신을 먼저 시작하게 되고, 따라서 수신자 측이 MAA Client 이고 Mail Server쪽이 MAA Server 가 되는 것 그래서 전체적인 과정을 정리해보면 수신자의 MTA Client가 자신의 Mail Server’s MTA Server로 보내고, 그 Mail Server’s MTA Client가 상대방의 Mail Server’s MTA Server로 보내면 메일함에 넣어놓고 존버하다가 상대방 컴터의 MAA Client가 Mail Server’s MAA Server로 메일함에 있는거 싹다 주세요 하면 그때 메일함에 있는거 보내주는 것 따라서 위 그림에서 보이는것처럼 두개의 UA, 두개의 MTA Client-Server 쌍, 한개의 MAA Client-Server쌍이 필요하다 UA, MTA, MAA § 뭐 위에서 다 말하긴 했지만 총정리하면 UA(User Agent) 는 참여자와 소통하며 메일 작성하거나 도착한 메일을 출력하거나 하는 식의 UI에 해당하는 작업 및 같은 시스템에 있는 Mail Server의 메일함에 메일을 넣거나 가져오는 작업만 가능한 프로세스이고 뭐 옛날 고조선사람들은 Terminal Command형태의 UA를 사용했다네 MTA(Mail Transfer Agent) 는 다른 시스템에 있는 Mail Server한테 메일을 보내려고 할때 사용되는 프로세스로 메일을 보내는쪽이 Client, 받는쪽이 Server가 되는 것이다 Client가 메일을 보내는 쪽이기 때문에 Push Functionality를 제공한다고들 함 MAA(Mail Access Agent) 는 다른 시스템에 있는 Mail Server한테서 메일을 받아오려고 할 때 사용되는 프로세스로 메일을 받는쪽이 Client, 보내는쪽이 Server가 된다 얘는 Client가 메일을 받아오는 쪽이기 때문에 Pull Functionality를 제공한다고 표현하드라 MIME § 얘는 UA와 MTA사이에서 메시지의 인코딩을 담당하는 놈인데 MTA는 7-bit NVT ASCII만 보낼 수 있다 - 즉, Printable Character만 보낼 수 있고 최상위 비트는 무조건 0이어야 된다는 것 근데 옛날에야 뭐 텍스트만 보내도 흡족했지만 지금은 파일도 보내고 동야도 보내고 해야되는데 7-bit NVT ASCII로는 저런 bit stream을 보낼 수가 없음 그래서 bit stream을 7-bit NVT ASCII로 변환하고 그걸 다시 bit stream으로 변환하는 역할을 하는놈이 MIME(Multipurpose Internet Mail Extensions) 이다 인코딩방식은 여러개 있는데 대표적으로 니가 아는 그 Base64로 인코딩한담에 나머지 2비트는 00으로 채워서 보내고 받을때도 00빼고 합치는 식으로 한다 SMTP § SMTP(Simple Mail Transfer Protocol) MTA 프로토콜로 제일 유명하고 현재 거의 유일하게 사용되고 있는 프로토콜이다 통신은 Connection Establishment, Mail Transfer, Connection Termination순서로 진행된다 위 그림처럼 MTA Client는 COMMAND ARGUMENTS …의 포맷으로 Commands를 보내며 그에 대한 응답으로 MTA Server는 STATUS_CODE STATUS_MSG의 형태로 Response를 보낸다 예시 § 예시를 보면서 통신 과정 알아보자구 위처럼 telnet $MAIL_SERVER_DOMAIN 25 명령어로 시작하게 된다 당연히 $MAIL_SERVER_DOMAIN은 메일 서버의 도메인이고 25는 포트 번호이다 - SMTP는 25의 포트 번호를 사용하더라 그럼 이래됨 - 예제에서 분홍색은 Response이고 검은색이 Command이다 일단 220은 Service Ready → 메일 서버가 준비되었다는 뜻임 그럼 그상태에서 HELO $MAIL_SERVER_DOMAIN을 보내면 Connection을 시도하게 됨 - HELO가 주어진 도메인이랑 Connection을 하겠다는 Command임 Connection이 이루어졌으면 250 메시지가 오게 됨 - 요청이 완료되었다는 것으로 Connection이 정상적으로 됐다는 소리임 솔직히 걍 읽어봐도 뭔말알이긴함 MAIL FROM $SRC로 보내는 사람 메일 주소 명시 가 가능하고 RCPT TO $DST로 받는 사람 메일 주소 명시 가 가능하며 DATA 로 이제 메일을 보내겠다고 알려주게 되며 354가 오면 메일 내용을 적으면 됨 그리고 Response Message의 &amp;lt;CRLF&amp;gt;."/><meta property="og:image" content="https://mdg.haeramk.im/static/og-image.png"/><meta property="og:width" content="1200"/><meta property="og:height" content="675"/><link rel="icon" href="../../../../static/icon.png"/><meta name="description" content="충남대학교 컴퓨터공학과 김상하 교수님의 &amp;quot;컴퓨터 네트워크&amp;quot; 강의를 필기한 내용입니다. 다소 잘못된 내용과 구어적 표현 이 포함되어 있을 수 있습니다. TELNET § Remote Logging을 위한 프로토콜인데 요즘의 클라우드 컴퓨팅마냥 옛날에도 조금 다른 형태의 클라우드 비스무리한게 서비스되었다 강력한 CPU를 가진 중앙 컴퓨터가 있고, 거기에 간단한 CPU를 가진 컴퓨터들이 원격으로 접속해서 작업을 요청하고 그 결과를 받는 것 - Timesharing Environment라고 한다 Terminal을 이용해 서버와 클라이언트가 소통하는데 이게 실제로는 사용자가 자기컴퓨터갖고 노는게 아니기 때문에 Virtual Terminal Service라는 말을 사용함 서버에 여러 사용자가 각자의 공간과 접근권한, ID, PW등을 갖는 것을 Logging이라고 한다 이때 Local 환경과 Remote환경의 차이를 줄이기 위한 프로토콜이 TELNET인 것이다 ASCII, Encoding Issue § 일단 뭐 ASCII(American Standard Code for Information Interchange) 가 뭔지 이미 알고 있겠지만 화면에 표시될 수 있는 문자들 및 여러 컨트롤 명령들을 8비트로 매핑해놓은 것이다 그래서 구성이 어케되냐면 8비트(1바이트)이기 때문에 0~255까지의 숫자로 매핑이 되는데 1~31까지는 화면에 출력되지 않는(Non-Printable) 시스템 코드 이다 뭐 종종 보이는 CR(커서 이동), LF(개행)등이 여기에 드감 32~127까지는 화면에 출력되는(Printable) 코드 이다 알파벳 대소문자와 &amp;lt;, &amp;gt; @ 등등의 여러 기호들이 여기에 드감 그리고 128~255까지는 운영체제나 프로그램에서 자율적으로 매핑해서 사용할 수 있는 코드 이다 ctrl + D같은애들이 숫자로 변환되고 이게 각자의 운영체제나 프로그램에 맞게 해석되어 사용됨 근데 여기서 문제가 뭐냐면 0~127까지는 표준으로 정해져있지만 128부터는 자율적으로 프로그래밍될 수 있게 함으로써 환경이 달라지면 다르게 해석된다는 것이다 예를들어서 DOS에서는 EOF가 ctrl + Z이지만 UNIX에서는 ctrl + D로 매핑되어있는 것 그리고 ASCII말고 다른 인코딩 포맷을 사용하는 운영체제나 프로그램도 존재한다 DOS나 UNIX는 ASCII를 사용하지만 Windows NT나 IBM S/390같은애들은 Unicode나 EBCDIC같은 인코딩 방식을 사용하는 등 따라서 환경이 달라져도 원래 의도에 맞게 해석되도록 변환하는 놈이 필요함 Local Log in § TELNET의 작동원리를 정확하게 이해하기 위해서는 일단 Local환경에서 어떻게 Logging이 되는지 알아볼 필요가 있다 우리가 Terminal 창을 켜서 키보드를 하나 누르면 다음과 같은 일이 일어난다 키보드가 눌린 키보드에 대한 전기신호를 숫자의 형태로 Terminal Driver에게 보낸다 여기서 알아야할게 키보드가 보내는 숫자 전기 신호는 뭐 ASCII같은 인코딩을 사용하는게 아니라 해당 키보드에서 사용하는 독자적인 수치를 이용한다는 것이다 그럼 Terminal Driver는 그 전기 신호를 운영체제가 알아들을 수 있는(사용하고 있는) 인코딩 방식으로 변환해서 운영체제에게 전달한다 즉, 키보드가 만들어낸 전기 신호를 운영체제가 알아들을 수 있는 ASCII 등의 포맷으로 인코딩하는 것이 Terminal Driver가 하는 일이다 운영체제는 Terminal Driver가 준거를 보고 그에 맞는 Application Program에게 전달하게 된다 예를들면 이렇게 된다는거임 Terminal창을 열고 cd a를 칠라고 했는데 실수로 cd ab를 쳐서 백스페이스를 눌렀을때 키보드가 생성해내는 Stream을 예를들어서 1 2 3 4 5 6이라고 해보자 - 걍 예시임 1이 c에 대한 신호고 2가 d에 대한 신호고 스페이스바가 3이고 뭐 이런식임 그럼 Terminal Driver는 저거를 받아들고 (운영체제가 ASCII를 사용한다는 가정하에) 66 67 20 64 65 07로 번역해서 운영체제한테 전달한다 그럼 운영체제가 뭐 zsh같은 쉘한테 “cd ab를 출력한 다음에 b를 화면에서 지워라” 같은 메세지를 전달하게 되는 것이다 Remote Log in § 근데 위에서 말한거같은 Timesharing Environment에서는 Local과 Remote의 운영체제나 프로그램등이 다를 가능성이 농후하다 따라서 저런걸 이용하기 위해서는 Encoding 방식을 변환해야 될 필요가 있고 그걸 TELNET에서 지원하는거다 이놈의 핵심 원리는 운영체제 등의 환경에 종속적인 인코딩을 환경에 종속적이지 않은 인코딩인 NVT(Network Virtual Terminal) 으로 변환해서 상대방에게 보내고, 상대방이 그걸 받으면 그걸 자신의 환경에 맞게 변환해서 사용하게 된다는 것이다 NVT(Network Virtual Terminal) 에 대한 얘기를 좀 해보면 위에서 0~127까지는 표준화가 되어있지만 128이후로는 각기 다르다고 했잖여 따라서 NVT(Network Virtual Terminal) 에서도 127까지는 ASCII와 동일하지만 그 이후부터는 독자적인 포맷을 사용함 그리고 이런 포맷으로 TELNET끼리 통신한 다음 각자의 Local에 맞게 인코딩방식을 바꾸는거다 0~127까지는 최상위비트가 0이므로 0으로 시작할 경우에는 데이터 코드로 인식하고 이것에 대해서는 별도의 번역을 하지 않지만 128~255까지는 최상위비트가 1이므로 1로 시작할 경우에는 컨트롤 코드로 인식하고 운영체제에 맞는 번역을 진행하게 된다 이제 작동과정을 보면 Local에서 작동하는건 동일하게 이루어진다 - 키보드 신호가 Local의 운영체제에 맞는 포맷으로 인코딩되어 운영체제에 전달된다 그럼 그 다음에는 운영체제가 Application인 TELNET Client에게 Local Env Encoding Stream을 전달한다 키보드신호가 아니고 Local 운영체제가 사용하는 인코딩으로 도착한다는거 헷갈리지 말그라 TELNET Client는 해당 Stream을 NVT(Network Virtual Terminal) 로 변환한 다음 TCP / IP를 이용해 Server에게 보낸다 주목해야될거는 TELNET이 TCP / IP를 이용한다는 것과 만국공통어 정도로 비유될 수 있는 NVT(Network Virtual Terminal) 로 번역된다는 거다 그럼 그걸 Server에서는 TCP / IP를 통해 받아서 TELNET Server까지 올라가겠지 TELNET Server는 NVT를 받은 뒤에 자신의 운영체제가 이해할수있는(Understandable)인코딩으로 변환해서 Pseudo-Terminal Driver에게 보낸다 여기서 헷갈릴만한게 TELNET Server가 번역한 다음에 OS가 아닌 Pseudo-Terminal Driver에게 보낸다는 것 이다 이렇게 하는 이유는 OS는 무조건 Terminal Driver한테서만 받도록 설계되어 있기 때문에 TELNET Server가 직접적으로 OS한테 보내지 못하고 저런 가짜 Terminal Driver 를 통해 보내게 되는 것 Pseudo-Terminal Driver는 그걸 OS에게 전달하고 OS가 그에 맞는 Application Program에게 Stream을 전달한다 그래서 위의 그림처럼 표현할 수도 있더라 예시임 - 이런식으로 진행된다 Electronic Mail Service § Architecture § 여기서 System이라는 말이 종종 나오는데 이건 Mail Server 와 LAN으로 연결되어있는 범위정도로 이해하면 될거같다 Scenario 1 - Both Participant are Connected Direclty to the Same System § 회사 사내 망에 송수신자 모두가 연결되어있는 경우 정도로 이해하면 된다 여기서 User Agent는 메일을 작성하거나 출력하거나 목록을 보여주는 등의 사용자와 소통하는 작업과 (서버랑 같은 시스템에 있을 경우) 메일 서버의 메일 박스에 넣어놓거나 가져오는 정도의 메일 송수신이 가능한 프로세스라고 생각하면 된다 따라서 모든 참여자가 같은 시스템에 연결되어있을때 에는 위 그림처럼 사용자 각각에 대한 메일박스들을 가지고 있는 메일서버와 UA(User Agent) 만 있으면 메일을 주고받을 수 있음 송신자가 UA를 통해 메일을 작성하고 전송하기를 하면 UA는 그걸 Mail Server의 수신자 메일박스에 넣고, 수신자는 메일박스에 있는 메일을 받아보게 되는 과정으로 전송된다 Scenario 2 - Both Participants are Connected to Separate System § 이건 내가 사내망에 접속되어있고 다른 사내망에 접속되어있는 사람한테 보내는 경우 정도로 생각하면 된다 시스템에서 시스템으로 메일을 보내기 위해서는 MTA(Main Transfer Agent) 가 필요하다 MTA에 대해 기억할것은 얘는 Client-Server모델을 이용하기 때문에 Client의 적극적인 송신에 Server는 수동적으로 수신할 수 밖에 없다는 것이다 즉, Client가 메일을 보내고 Server가 받기 때문에 하나의 Client-Server Pair에 한해서, 그리고 실제 메시지에 한해서는 단방향 통신이라고 말할 수 있는거다 이말을 오해하면 안되는게 그렇다고 Server가 Client에게 통신을 안한다는게 아니고 실제 메일이 전달되는거에 한해서만 단방향이라는 것 - 뭐 뒤에서도 배우겠지만 Connection과 Terminate등의 절차를 거치며 Control Message는 양방향으로 주고받게 된다 어쨋든 모든 참여자가 시스템에 연결되어있지만 시스템이 다를 경우 에는 위 그림처럼 UA를 통해 시스템에게 메일을 보내면 그걸 MTA Cilent가 다른 시스템으로 보내고, 다른 시스템에 있는 MTA Server가 그걸 받아서 메일함에 넣어서 수신자가 가져가게 되는 과정이 이루어진다 따라서 UA 두개와 한쌍의 MTA Client-Server가 필요함 Scenario 3 - Some Participant are not Connected to System § 이건 내가 집에서 다른 사내망에 연결되어있는 사람에게 메일을 보내는 경우 정도로 생각하면 되는데 송신자가 자신의 메일 서버 시스템에 연결되어있지 않기 때문에 송신자는 자신의 디바이스에 있는 MTA Client로 자신의 메일 서버 시스템의 MTA Server로 우선 메일을 보내는 작업을 한다 그럼 그 다음부터는 Scenario 2와 동일함 - 수신자의 메일 서버 시스템의 MTA Server로 메일을 보내게 되고 그럼 MTA Server가 메일박스에 넣어놓음으로써 수신자가 받아가는 것 따라서 이 경우에는 두개의 UA와 두개의 MTA Client-Server 쌍이 필요하게 됨 Scenario 4 - Both Participant are not Connected to System § 이게 제일 일반적인 경우임 - 내가 집에서 다른 집에 있는 사람한테 메일을 보내는 경우 여기서는 수신자가 메일을 가져가는 과정 외에는 전부 동일하다 - MTA Client로 자신의 Mail Server의 MTA Server 에게 보내고, 거기서는 또 Mail Server의 MTA Client로 상대방의 Mail Server의 MTA Server에게 보내면 메일함에 담기게 됨 근데 이경우에는 그냥 수신자에게 메일함에 있는것을 줄 수 있는게 아니다 - Mail Server가 수신자에게 주려고 해도 저놈이 출무중이면(뭐 컴터가 꺼져있다거나) 메일을 받지 못하기 때문 그리고 저넘이 언제 접속할지도 모름 - 따라서 Mail Server는 저놈이 달라고 할때까지 암것도 안하는 아몰랑 전략을 취한다 즉, 수신자가 Mail Server에게 나에게 온 메일을 자기한테 달라고 요청 하게 되는 것 이런걸 대행해주는 프로세스를 MAA(Mail Access Agent) 라고 하는데 수신자측이 메일을 받으니까 MAA Server일거라고 생각하면 경기도 오산시 오산낙지다 메일을 달라고 요청 해야되니까 통신을 먼저 시작하게 되고, 따라서 수신자 측이 MAA Client 이고 Mail Server쪽이 MAA Server 가 되는 것 그래서 전체적인 과정을 정리해보면 수신자의 MTA Client가 자신의 Mail Server’s MTA Server로 보내고, 그 Mail Server’s MTA Client가 상대방의 Mail Server’s MTA Server로 보내면 메일함에 넣어놓고 존버하다가 상대방 컴터의 MAA Client가 Mail Server’s MAA Server로 메일함에 있는거 싹다 주세요 하면 그때 메일함에 있는거 보내주는 것 따라서 위 그림에서 보이는것처럼 두개의 UA, 두개의 MTA Client-Server 쌍, 한개의 MAA Client-Server쌍이 필요하다 UA, MTA, MAA § 뭐 위에서 다 말하긴 했지만 총정리하면 UA(User Agent) 는 참여자와 소통하며 메일 작성하거나 도착한 메일을 출력하거나 하는 식의 UI에 해당하는 작업 및 같은 시스템에 있는 Mail Server의 메일함에 메일을 넣거나 가져오는 작업만 가능한 프로세스이고 뭐 옛날 고조선사람들은 Terminal Command형태의 UA를 사용했다네 MTA(Mail Transfer Agent) 는 다른 시스템에 있는 Mail Server한테 메일을 보내려고 할때 사용되는 프로세스로 메일을 보내는쪽이 Client, 받는쪽이 Server가 되는 것이다 Client가 메일을 보내는 쪽이기 때문에 Push Functionality를 제공한다고들 함 MAA(Mail Access Agent) 는 다른 시스템에 있는 Mail Server한테서 메일을 받아오려고 할 때 사용되는 프로세스로 메일을 받는쪽이 Client, 보내는쪽이 Server가 된다 얘는 Client가 메일을 받아오는 쪽이기 때문에 Pull Functionality를 제공한다고 표현하드라 MIME § 얘는 UA와 MTA사이에서 메시지의 인코딩을 담당하는 놈인데 MTA는 7-bit NVT ASCII만 보낼 수 있다 - 즉, Printable Character만 보낼 수 있고 최상위 비트는 무조건 0이어야 된다는 것 근데 옛날에야 뭐 텍스트만 보내도 흡족했지만 지금은 파일도 보내고 동야도 보내고 해야되는데 7-bit NVT ASCII로는 저런 bit stream을 보낼 수가 없음 그래서 bit stream을 7-bit NVT ASCII로 변환하고 그걸 다시 bit stream으로 변환하는 역할을 하는놈이 MIME(Multipurpose Internet Mail Extensions) 이다 인코딩방식은 여러개 있는데 대표적으로 니가 아는 그 Base64로 인코딩한담에 나머지 2비트는 00으로 채워서 보내고 받을때도 00빼고 합치는 식으로 한다 SMTP § SMTP(Simple Mail Transfer Protocol) MTA 프로토콜로 제일 유명하고 현재 거의 유일하게 사용되고 있는 프로토콜이다 통신은 Connection Establishment, Mail Transfer, Connection Termination순서로 진행된다 위 그림처럼 MTA Client는 COMMAND ARGUMENTS …의 포맷으로 Commands를 보내며 그에 대한 응답으로 MTA Server는 STATUS_CODE STATUS_MSG의 형태로 Response를 보낸다 예시 § 예시를 보면서 통신 과정 알아보자구 위처럼 telnet $MAIL_SERVER_DOMAIN 25 명령어로 시작하게 된다 당연히 $MAIL_SERVER_DOMAIN은 메일 서버의 도메인이고 25는 포트 번호이다 - SMTP는 25의 포트 번호를 사용하더라 그럼 이래됨 - 예제에서 분홍색은 Response이고 검은색이 Command이다 일단 220은 Service Ready → 메일 서버가 준비되었다는 뜻임 그럼 그상태에서 HELO $MAIL_SERVER_DOMAIN을 보내면 Connection을 시도하게 됨 - HELO가 주어진 도메인이랑 Connection을 하겠다는 Command임 Connection이 이루어졌으면 250 메시지가 오게 됨 - 요청이 완료되었다는 것으로 Connection이 정상적으로 됐다는 소리임 솔직히 걍 읽어봐도 뭔말알이긴함 MAIL FROM $SRC로 보내는 사람 메일 주소 명시 가 가능하고 RCPT TO $DST로 받는 사람 메일 주소 명시 가 가능하며 DATA 로 이제 메일을 보내겠다고 알려주게 되며 354가 오면 메일 내용을 적으면 됨 그리고 Response Message의 &amp;lt;CRLF&amp;gt;."/><meta name="generator" content="Quartz"/><link rel="preconnect" href="https://fonts.googleapis.com"/><link rel="preconnect" href="https://fonts.gstatic.com"/><link href="../../../../index.css" rel="stylesheet" type="text/css" spa-preserve/><link href="https://cdn.jsdelivr.net/npm/katex@0.16.0/dist/katex.min.css" rel="stylesheet" type="text/css" spa-preserve/><link href="https://fonts.googleapis.com/css2?family=IBM Plex Mono&amp;family=Gowun Batang:wght@400;700&amp;family=Gowun Dodum:ital,wght@0,400;0,600;1,400;1,600&amp;display=swap" rel="stylesheet" type="text/css" spa-preserve/><script src="../../../../prescript.js" type="application/javascript" spa-preserve></script><script type="application/javascript" spa-preserve>const fetchData = fetch(`../../../../static/contentIndex.json`).then(data => data.json())</script></head><body data-slug="gardens/network/originals/comnet.fall.2021.cse.cnu.ac.kr/12.-TELNET,-Email,-File-Transfer"><div id="quartz-root" class="page"><div id="quartz-body"><div class="left sidebar"><h1 class="page-title "><a href="../../../..">Madison Digital Garden</a></h1><div class="spacer mobile-only"></div><div class="search "><div id="search-icon"><p>Search</p><div></div><svg tabIndex="0" aria-labelledby="title desc" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 19.9 19.7"><title id="title">Search</title><desc id="desc">Search</desc><g class="search-path" fill="none"><path stroke-linecap="square" d="M18.5 18.3l-5.4-5.4"></path><circle cx="8" cy="8" r="7"></circle></g></svg></div><div id="search-container"><div id="search-space"><input autocomplete="off" id="search-bar" name="search" type="text" aria-label="Search for something" placeholder="Search for something"/><div id="results-container"></div></div></div></div><div class="darkmode "><input class="toggle" id="darkmode-toggle" type="checkbox" tabIndex="-1"/><label id="toggle-label-light" for="darkmode-toggle" tabIndex="-1"><svg xmlns="http://www.w3.org/2000/svg" xmlnsXlink="http://www.w3.org/1999/xlink" version="1.1" id="dayIcon" x="0px" y="0px" viewBox="0 0 35 35" style="enable-background:new 0 0 35 35;" xmlSpace="preserve"><title>Light mode</title><path d="M6,17.5C6,16.672,5.328,16,4.5,16h-3C0.672,16,0,16.672,0,17.5    S0.672,19,1.5,19h3C5.328,19,6,18.328,6,17.5z M7.5,26c-0.414,0-0.789,0.168-1.061,0.439l-2,2C4.168,28.711,4,29.086,4,29.5    C4,30.328,4.671,31,5.5,31c0.414,0,0.789-0.168,1.06-0.44l2-2C8.832,28.289,9,27.914,9,27.5C9,26.672,8.329,26,7.5,26z M17.5,6    C18.329,6,19,5.328,19,4.5v-3C19,0.672,18.329,0,17.5,0S16,0.672,16,1.5v3C16,5.328,16.671,6,17.5,6z M27.5,9    c0.414,0,0.789-0.168,1.06-0.439l2-2C30.832,6.289,31,5.914,31,5.5C31,4.672,30.329,4,29.5,4c-0.414,0-0.789,0.168-1.061,0.44    l-2,2C26.168,6.711,26,7.086,26,7.5C26,8.328,26.671,9,27.5,9z M6.439,8.561C6.711,8.832,7.086,9,7.5,9C8.328,9,9,8.328,9,7.5    c0-0.414-0.168-0.789-0.439-1.061l-2-2C6.289,4.168,5.914,4,5.5,4C4.672,4,4,4.672,4,5.5c0,0.414,0.168,0.789,0.439,1.06    L6.439,8.561z M33.5,16h-3c-0.828,0-1.5,0.672-1.5,1.5s0.672,1.5,1.5,1.5h3c0.828,0,1.5-0.672,1.5-1.5S34.328,16,33.5,16z     M28.561,26.439C28.289,26.168,27.914,26,27.5,26c-0.828,0-1.5,0.672-1.5,1.5c0,0.414,0.168,0.789,0.439,1.06l2,2    C28.711,30.832,29.086,31,29.5,31c0.828,0,1.5-0.672,1.5-1.5c0-0.414-0.168-0.789-0.439-1.061L28.561,26.439z M17.5,29    c-0.829,0-1.5,0.672-1.5,1.5v3c0,0.828,0.671,1.5,1.5,1.5s1.5-0.672,1.5-1.5v-3C19,29.672,18.329,29,17.5,29z M17.5,7    C11.71,7,7,11.71,7,17.5S11.71,28,17.5,28S28,23.29,28,17.5S23.29,7,17.5,7z M17.5,25c-4.136,0-7.5-3.364-7.5-7.5    c0-4.136,3.364-7.5,7.5-7.5c4.136,0,7.5,3.364,7.5,7.5C25,21.636,21.636,25,17.5,25z"></path></svg></label><label id="toggle-label-dark" for="darkmode-toggle" tabIndex="-1"><svg xmlns="http://www.w3.org/2000/svg" xmlnsXlink="http://www.w3.org/1999/xlink" version="1.1" id="nightIcon" x="0px" y="0px" viewBox="0 0 100 100" style="enable-background='new 0 0 100 100'" xmlSpace="preserve"><title>Dark mode</title><path d="M96.76,66.458c-0.853-0.852-2.15-1.064-3.23-0.534c-6.063,2.991-12.858,4.571-19.655,4.571  C62.022,70.495,50.88,65.88,42.5,57.5C29.043,44.043,25.658,23.536,34.076,6.47c0.532-1.08,0.318-2.379-0.534-3.23  c-0.851-0.852-2.15-1.064-3.23-0.534c-4.918,2.427-9.375,5.619-13.246,9.491c-9.447,9.447-14.65,22.008-14.65,35.369  c0,13.36,5.203,25.921,14.65,35.368s22.008,14.65,35.368,14.65c13.361,0,25.921-5.203,35.369-14.65  c3.872-3.871,7.064-8.328,9.491-13.246C97.826,68.608,97.611,67.309,96.76,66.458z"></path></svg></label></div></div><div class="center"><div class="page-header"><div class="popover-hint"><h1 class="article-title ">12. TELNET, Email, File Transfer</h1><p class="content-meta ">Aug 05, 2024, 27 min read</p></div></div><article class="popover-hint"><blockquote class="callout" data-callout="info">
<div class="callout-title">
                  <div class="callout-icon"><svg xmlns="http://www.w3.org/2000/svg" width="100%" height="100%" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="10"></circle><line x1="12" y1="16" x2="12" y2="12"></line><line x1="12" y1="8" x2="12.01" y2="8"></line></svg></div>
                  <div class="callout-title-inner"><p>충남대학교 컴퓨터공학과 김상하 교수님의 &quot;컴퓨터 네트워크&quot; 강의를 필기한 내용입니다. </p></div>
                  
                </div>
</blockquote>
<blockquote class="callout" data-callout="warning">
<div class="callout-title">
                  <div class="callout-icon"><svg xmlns="http://www.w3.org/2000/svg" width="100%" height="100%" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="m21.73 18-8-14a2 2 0 0 0-3.48 0l-8 14A2 2 0 0 0 4 21h16a2 2 0 0 0 1.73-3Z"></path><line x1="12" y1="9" x2="12" y2="13"></line><line x1="12" y1="17" x2="12.01" y2="17"></line></svg></div>
                  <div class="callout-title-inner"><p>다소 잘못된 내용과 구어적 표현 이 포함되어 있을 수 있습니다. </p></div>
                  
                </div>
</blockquote>
<h2 id="telnet">TELNET<a aria-hidden="true" tabindex="-1" href="#telnet" class="internal"> §</a></h2>
<ul>
<li><strong>Remote Logging</strong>을 위한 프로토콜인데</li>
<li>요즘의 클라우드 컴퓨팅마냥 옛날에도 조금 다른 형태의 클라우드 비스무리한게 서비스되었다
<ul>
<li>강력한 CPU를 가진 중앙 컴퓨터가 있고, 거기에 간단한 CPU를 가진 컴퓨터들이 원격으로 접속해서 작업을 요청하고 그 결과를 받는 것 - <strong>Timesharing Environment</strong>라고 한다</li>
<li><strong>Terminal</strong>을 이용해 서버와 클라이언트가 소통하는데 이게 실제로는 사용자가 자기컴퓨터갖고 노는게 아니기 때문에 <strong>Virtual Terminal Service</strong>라는 말을 사용함</li>
<li>서버에 여러 사용자가 각자의 공간과 접근권한, ID, PW등을 갖는 것을 <strong>Logging</strong>이라고 한다</li>
</ul>
</li>
<li>이때 Local 환경과 Remote환경의 차이를 줄이기 위한 프로토콜이 <strong>TELNET</strong>인 것이다</li>
</ul>
<h3 id="ascii-encoding-issue">ASCII, Encoding Issue<a aria-hidden="true" tabindex="-1" href="#ascii-encoding-issue" class="internal"> §</a></h3>
<ul>
<li>일단 뭐 <strong>ASCII(American Standard Code for Information Interchange)</strong> 가 뭔지 이미 알고 있겠지만 화면에 표시될 수 있는 문자들 및 여러 컨트롤 명령들을 8비트로 매핑해놓은 것이다
<ul>
<li>그래서 구성이 어케되냐면 8비트(1바이트)이기 때문에 0~255까지의 숫자로 매핑이 되는데</li>
<li>1~31까지는 화면에 출력되지 않는(<strong>Non-Printable</strong>) 시스템 코드 이다
<ul>
<li>뭐 종종 보이는 CR(커서 이동), LF(개행)등이 여기에 드감</li>
</ul>
</li>
<li>32~127까지는 화면에 출력되는(<strong>Printable)</strong> 코드 이다
<ul>
<li>알파벳 대소문자와 &lt;, > @ 등등의 여러 기호들이 여기에 드감</li>
</ul>
</li>
<li>그리고 128~255까지는 운영체제나 프로그램에서 자율적으로 매핑해서 사용할 수 있는 코드 이다
<ul>
<li>ctrl + D같은애들이 숫자로 변환되고 이게 각자의 운영체제나 프로그램에 맞게 해석되어 사용됨</li>
</ul>
</li>
</ul>
</li>
<li>근데 여기서 문제가 뭐냐면 0~127까지는 표준으로 정해져있지만 128부터는 자율적으로 프로그래밍될 수 있게 함으로써 환경이 달라지면 다르게 해석된다는 것이다
<ul>
<li>예를들어서 DOS에서는 EOF가 ctrl + Z이지만 UNIX에서는 ctrl + D로 매핑되어있는 것</li>
</ul>
</li>
<li>그리고 ASCII말고 다른 인코딩 포맷을 사용하는 운영체제나 프로그램도 존재한다
<ul>
<li>DOS나 UNIX는 ASCII를 사용하지만</li>
<li>Windows NT나 IBM S/390같은애들은 Unicode나 EBCDIC같은 인코딩 방식을 사용하는 등</li>
</ul>
</li>
<li>따라서 환경이 달라져도 원래 의도에 맞게 해석되도록 변환하는 놈이 필요함</li>
</ul>
<h3 id="local-log-in">Local Log in<a aria-hidden="true" tabindex="-1" href="#local-log-in" class="internal"> §</a></h3>
<p><img src="../../../../gardens/network/originals/comnet.fall.2021.cse.cnu.ac.kr/images/12_50f46370c92949f9b8ec57f6b99b1e3d/image1.png" alt="%E1%84%8B%E1%85%B5%E1%84%85%E1%85%A9%E1%86%AB12%20-%20TELNET,%20Email,%20File%20Transfer%2050f46370c92949f9b8ec57f6b99b1e3d/image1.png"/></p>
<ul>
<li>TELNET의 작동원리를 정확하게 이해하기 위해서는 일단 Local환경에서 어떻게 Logging이 되는지 알아볼 필요가 있다</li>
<li>우리가 Terminal 창을 켜서 키보드를 하나 누르면 다음과 같은 일이 일어난다
<ol>
<li>키보드가 눌린 키보드에 대한 전기신호를 숫자의 형태로 <strong>Terminal Driver</strong>에게 보낸다
<ul>
<li>여기서 알아야할게 키보드가 보내는 숫자 전기 신호는 뭐 ASCII같은 인코딩을 사용하는게 아니라 해당 키보드에서 사용하는 독자적인 수치를 이용한다는 것이다</li>
</ul>
</li>
<li>그럼 <strong>Terminal Driver</strong>는 그 전기 신호를 운영체제가 알아들을 수 있는(사용하고 있는) 인코딩 방식으로 변환해서 운영체제에게 전달한다
<ul>
<li>즉, 키보드가 만들어낸 전기 신호를 운영체제가 알아들을 수 있는 ASCII 등의 포맷으로 인코딩하는 것이 <strong>Terminal Driver</strong>가 하는 일이다</li>
</ul>
</li>
<li>운영체제는 <strong>Terminal Driver</strong>가 준거를 보고 그에 맞는 Application Program에게 전달하게 된다</li>
</ol>
</li>
<li>예를들면 이렇게 된다는거임
<ul>
<li>Terminal창을 열고 cd a를 칠라고 했는데 실수로 cd ab를 쳐서 백스페이스를 눌렀을때</li>
<li>키보드가 생성해내는 Stream을 예를들어서 1 2 3 4 5 6이라고 해보자 - 걍 예시임 1이 c에 대한 신호고 2가 d에 대한 신호고 스페이스바가 3이고 뭐 이런식임</li>
<li>그럼 Terminal Driver는 저거를 받아들고 (운영체제가 ASCII를 사용한다는 가정하에) 66 67 20 64 65 07로 번역해서 운영체제한테 전달한다</li>
<li>그럼 운영체제가 뭐 zsh같은 쉘한테 “cd ab를 출력한 다음에 b를 화면에서 지워라” 같은 메세지를 전달하게 되는 것이다</li>
</ul>
</li>
</ul>
<h3 id="remote-log-in">Remote Log in<a aria-hidden="true" tabindex="-1" href="#remote-log-in" class="internal"> §</a></h3>
<p><img src="../../../../gardens/network/originals/comnet.fall.2021.cse.cnu.ac.kr/images/12_50f46370c92949f9b8ec57f6b99b1e3d/image2.png" alt="%E1%84%8B%E1%85%B5%E1%84%85%E1%85%A9%E1%86%AB12%20-%20TELNET,%20Email,%20File%20Transfer%2050f46370c92949f9b8ec57f6b99b1e3d/image2.png"/></p>
<ul>
<li>근데 위에서 말한거같은 Timesharing Environment에서는 Local과 Remote의 운영체제나 프로그램등이 다를 가능성이 농후하다</li>
<li>따라서 저런걸 이용하기 위해서는 Encoding 방식을 변환해야 될 필요가 있고 그걸 <strong>TELNET</strong>에서 지원하는거다</li>
<li>이놈의 핵심 원리는 운영체제 등의 환경에 종속적인 인코딩을 환경에 종속적이지 않은 인코딩인 <strong>NVT(Network Virtual Terminal)</strong> 으로 변환해서 상대방에게 보내고, 상대방이 그걸 받으면 그걸 자신의 환경에 맞게 변환해서 사용하게 된다는 것이다
<ul>
<li><strong>NVT(Network Virtual Terminal)</strong> 에 대한 얘기를 좀 해보면</li>
<li>위에서 0~127까지는 표준화가 되어있지만 128이후로는 각기 다르다고 했잖여</li>
<li>따라서 <strong>NVT(Network Virtual Terminal)</strong> 에서도 127까지는 ASCII와 동일하지만 그 이후부터는 독자적인 포맷을 사용함</li>
<li>그리고 이런 포맷으로 TELNET끼리 통신한 다음 각자의 Local에 맞게 인코딩방식을 바꾸는거다</li>
</ul>
</li>
</ul>
<p><img src="../../../../gardens/network/originals/comnet.fall.2021.cse.cnu.ac.kr/images/12_50f46370c92949f9b8ec57f6b99b1e3d/image3.png" alt="%E1%84%8B%E1%85%B5%E1%84%85%E1%85%A9%E1%86%AB12%20-%20TELNET,%20Email,%20File%20Transfer%2050f46370c92949f9b8ec57f6b99b1e3d/image3.png"/></p>
<ul>
<li>0~127까지는 최상위비트가 0이므로 0으로 시작할 경우에는 데이터 코드로 인식하고 이것에 대해서는 별도의 번역을 하지 않지만</li>
<li>128~255까지는 최상위비트가 1이므로 1로 시작할 경우에는 컨트롤 코드로 인식하고 운영체제에 맞는 번역을 진행하게 된다</li>
<li>이제 작동과정을 보면
<ol>
<li>Local에서 작동하는건 동일하게 이루어진다 - 키보드 신호가 Local의 운영체제에 맞는 포맷으로 인코딩되어 운영체제에 전달된다</li>
<li>그럼 그 다음에는 운영체제가 Application인 <strong>TELNET Client</strong>에게 Local Env Encoding Stream을 전달한다
<ul>
<li>키보드신호가 아니고 Local 운영체제가 사용하는 인코딩으로 도착한다는거 헷갈리지 말그라</li>
</ul>
</li>
<li><strong>TELNET Client</strong>는 해당 Stream을 <strong>NVT(Network Virtual Terminal)</strong> 로 변환한 다음 TCP / IP를 이용해 Server에게 보낸다
<ul>
<li>주목해야될거는 <strong>TELNET</strong>이 <strong>TCP / IP</strong>를 이용한다는 것과</li>
<li>만국공통어 정도로 비유될 수 있는 <strong>NVT(Network Virtual Terminal)</strong> 로 번역된다는 거다</li>
</ul>
</li>
<li>그럼 그걸 Server에서는 TCP / IP를 통해 받아서 <strong>TELNET Server</strong>까지 올라가겠지</li>
<li><strong>TELNET Server</strong>는 NVT를 받은 뒤에 자신의 운영체제가 이해할수있는(<strong>Understandable</strong>)인코딩으로 변환해서 <strong>Pseudo-Terminal Driver</strong>에게 보낸다
<ul>
<li>여기서 헷갈릴만한게 <strong>TELNET Server</strong>가 번역한 다음에 OS가 아닌 <strong>Pseudo-Terminal Driver</strong>에게 보낸다는 것 이다</li>
<li>이렇게 하는 이유는 OS는 무조건 <strong>Terminal Driver</strong>한테서만 받도록 설계되어 있기 때문에 <strong>TELNET Server</strong>가 직접적으로 OS한테 보내지 못하고 저런 가짜 Terminal Driver 를 통해 보내게 되는 것</li>
</ul>
</li>
<li><strong>Pseudo-Terminal Driver</strong>는 그걸 OS에게 전달하고 OS가 그에 맞는 Application Program에게 Stream을 전달한다</li>
</ol>
</li>
</ul>
<p><img src="../../../../gardens/network/originals/comnet.fall.2021.cse.cnu.ac.kr/images/12_50f46370c92949f9b8ec57f6b99b1e3d/image4.png" alt="%E1%84%8B%E1%85%B5%E1%84%85%E1%85%A9%E1%86%AB12%20-%20TELNET,%20Email,%20File%20Transfer%2050f46370c92949f9b8ec57f6b99b1e3d/image4.png"/></p>
<ul>
<li>그래서 위의 그림처럼 표현할 수도 있더라</li>
</ul>
<p><img src="../../../../gardens/network/originals/comnet.fall.2021.cse.cnu.ac.kr/images/12_50f46370c92949f9b8ec57f6b99b1e3d/image5.png" alt="%E1%84%8B%E1%85%B5%E1%84%85%E1%85%A9%E1%86%AB12%20-%20TELNET,%20Email,%20File%20Transfer%2050f46370c92949f9b8ec57f6b99b1e3d/image5.png"/></p>
<ul>
<li>예시임 - 이런식으로 진행된다</li>
</ul>
<h2 id="electronic-mail-service">Electronic Mail Service<a aria-hidden="true" tabindex="-1" href="#electronic-mail-service" class="internal"> §</a></h2>
<h3 id="architecture">Architecture<a aria-hidden="true" tabindex="-1" href="#architecture" class="internal"> §</a></h3>
<ul>
<li>여기서 <strong>System</strong>이라는 말이 종종 나오는데 이건 Mail Server 와 LAN으로 연결되어있는 범위정도로 이해하면 될거같다</li>
</ul>
<h3 id="scenario-1---both-participant-are-connected-direclty-to-the-same-system">Scenario 1 - Both Participant are Connected Direclty to the Same System<a aria-hidden="true" tabindex="-1" href="#scenario-1---both-participant-are-connected-direclty-to-the-same-system" class="internal"> §</a></h3>
<p><img src="../../../../gardens/network/originals/comnet.fall.2021.cse.cnu.ac.kr/images/12_50f46370c92949f9b8ec57f6b99b1e3d/image6.png" alt="%E1%84%8B%E1%85%B5%E1%84%85%E1%85%A9%E1%86%AB12%20-%20TELNET,%20Email,%20File%20Transfer%2050f46370c92949f9b8ec57f6b99b1e3d/image6.png"/></p>
<ul>
<li>회사 사내 망에 송수신자 모두가 연결되어있는 경우 정도로 이해하면 된다</li>
<li>여기서 <strong>User Agent</strong>는 메일을 작성하거나 출력하거나 목록을 보여주는 등의 사용자와 소통하는 작업과 (서버랑 같은 시스템에 있을 경우) 메일 서버의 메일 박스에 넣어놓거나 가져오는 정도의 메일 송수신이 가능한 프로세스라고 생각하면 된다</li>
<li>따라서 모든 참여자가 같은 시스템에 연결되어있을때 에는 위 그림처럼 사용자 각각에 대한 메일박스들을 가지고 있는 메일서버와 <strong>UA(User Agent)</strong> 만 있으면 메일을 주고받을 수 있음</li>
<li>송신자가 UA를 통해 메일을 작성하고 전송하기를 하면 UA는 그걸 Mail Server의 수신자 메일박스에 넣고, 수신자는 메일박스에 있는 메일을 받아보게 되는 과정으로 전송된다</li>
</ul>
<h3 id="scenario-2---both-participants-are-connected-to-separate-system">Scenario 2 - Both Participants are Connected to Separate System<a aria-hidden="true" tabindex="-1" href="#scenario-2---both-participants-are-connected-to-separate-system" class="internal"> §</a></h3>
<p><img src="../../../../gardens/network/originals/comnet.fall.2021.cse.cnu.ac.kr/images/12_50f46370c92949f9b8ec57f6b99b1e3d/image7.png" alt="%E1%84%8B%E1%85%B5%E1%84%85%E1%85%A9%E1%86%AB12%20-%20TELNET,%20Email,%20File%20Transfer%2050f46370c92949f9b8ec57f6b99b1e3d/image7.png"/></p>
<ul>
<li>이건 내가 사내망에 접속되어있고 다른 사내망에 접속되어있는 사람한테 보내는 경우 정도로 생각하면 된다</li>
<li>시스템에서 시스템으로 메일을 보내기 위해서는 <strong>MTA(Main Transfer Agent)</strong> 가 필요하다
<ul>
<li><strong>MTA</strong>에 대해 기억할것은 얘는 Client-Server모델을 이용하기 때문에 Client의 적극적인 송신에 Server는 수동적으로 수신할 수 밖에 없다는 것이다</li>
<li>즉, Client가 메일을 보내고 Server가 받기 때문에 하나의 Client-Server Pair에 한해서, 그리고 실제 메시지에 한해서는 단방향 통신이라고 말할 수 있는거다</li>
<li>이말을 오해하면 안되는게 그렇다고 Server가 Client에게 통신을 안한다는게 아니고 실제 메일이 전달되는거에 한해서만 단방향이라는 것 - 뭐 뒤에서도 배우겠지만 Connection과 Terminate등의 절차를 거치며 Control Message는 양방향으로 주고받게 된다</li>
</ul>
</li>
<li>어쨋든 모든 참여자가 시스템에 연결되어있지만 시스템이 다를 경우 에는 위 그림처럼 UA를 통해 시스템에게 메일을 보내면 그걸 <strong>MTA Cilent</strong>가 다른 시스템으로 보내고, 다른 시스템에 있는 <strong>MTA Server</strong>가 그걸 받아서 메일함에 넣어서 수신자가 가져가게 되는 과정이 이루어진다</li>
<li>따라서 UA 두개와 한쌍의 MTA Client-Server가 필요함</li>
</ul>
<h3 id="scenario-3---some-participant-are-not-connected-to-system">Scenario 3 - Some Participant are not Connected to System<a aria-hidden="true" tabindex="-1" href="#scenario-3---some-participant-are-not-connected-to-system" class="internal"> §</a></h3>
<p><img src="../../../../gardens/network/originals/comnet.fall.2021.cse.cnu.ac.kr/images/12_50f46370c92949f9b8ec57f6b99b1e3d/image8.png" alt="%E1%84%8B%E1%85%B5%E1%84%85%E1%85%A9%E1%86%AB12%20-%20TELNET,%20Email,%20File%20Transfer%2050f46370c92949f9b8ec57f6b99b1e3d/image8.png"/></p>
<ul>
<li>이건 내가 집에서 다른 사내망에 연결되어있는 사람에게 메일을 보내는 경우 정도로 생각하면 되는데</li>
</ul>
<ol>
<li>송신자가 자신의 메일 서버 시스템에 연결되어있지 않기 때문에 송신자는 자신의 디바이스에 있는 MTA Client로 자신의 메일 서버 시스템의 MTA Server로 우선 메일을 보내는 작업을 한다</li>
<li>그럼 그 다음부터는 Scenario 2와 동일함 - 수신자의 메일 서버 시스템의 MTA Server로 메일을 보내게 되고 그럼 MTA Server가 메일박스에 넣어놓음으로써 수신자가 받아가는 것</li>
</ol>
<ul>
<li>따라서 이 경우에는 두개의 UA와 두개의 MTA Client-Server 쌍이 필요하게 됨</li>
</ul>
<h3 id="scenario-4---both-participant-are-not-connected-to-system">Scenario 4 - Both Participant are not Connected to System<a aria-hidden="true" tabindex="-1" href="#scenario-4---both-participant-are-not-connected-to-system" class="internal"> §</a></h3>
<ul>
<li>이게 제일 일반적인 경우임 - 내가 집에서 다른 집에 있는 사람한테 메일을 보내는 경우</li>
</ul>
<p><img src="../../../../gardens/network/originals/comnet.fall.2021.cse.cnu.ac.kr/images/12_50f46370c92949f9b8ec57f6b99b1e3d/image9.png" alt="%E1%84%8B%E1%85%B5%E1%84%85%E1%85%A9%E1%86%AB12%20-%20TELNET,%20Email,%20File%20Transfer%2050f46370c92949f9b8ec57f6b99b1e3d/image9.png"/></p>
<ul>
<li>여기서는 수신자가 메일을 가져가는 과정 외에는 전부 동일하다 - MTA Client로 자신의 Mail Server의 MTA Server 에게 보내고, 거기서는 또 Mail Server의 MTA Client로 상대방의 Mail Server의 MTA Server에게 보내면 메일함에 담기게 됨</li>
<li>근데 이경우에는 그냥 수신자에게 메일함에 있는것을 줄 수 있는게 아니다 - Mail Server가 수신자에게 주려고 해도 저놈이 출무중이면(뭐 컴터가 꺼져있다거나) 메일을 받지 못하기 때문</li>
<li>그리고 저넘이 언제 접속할지도 모름 - 따라서 Mail Server는 저놈이 달라고 할때까지 암것도 안하는 아몰랑 전략을 취한다
<ul>
<li>즉, 수신자가 Mail Server에게 나에게 온 메일을 자기한테 달라고 요청 하게 되는 것</li>
<li>이런걸 대행해주는 프로세스를 <strong>MAA(Mail Access Agent)</strong> 라고 하는데 수신자측이 메일을 받으니까 MAA Server일거라고 생각하면 경기도 오산시 오산낙지다</li>
<li>메일을 달라고 요청 해야되니까 통신을 먼저 시작하게 되고, 따라서 수신자 측이 MAA Client 이고 Mail Server쪽이 MAA Server 가 되는 것</li>
</ul>
</li>
<li>그래서 전체적인 과정을 정리해보면 수신자의 MTA Client가 자신의 Mail Server’s MTA Server로 보내고, 그 Mail Server’s MTA Client가 상대방의 Mail Server’s MTA Server로 보내면 메일함에 넣어놓고 존버하다가 상대방 컴터의 MAA Client가 Mail Server’s MAA Server로 메일함에 있는거 싹다 주세요 하면 그때 메일함에 있는거 보내주는 것</li>
<li>따라서 위 그림에서 보이는것처럼 두개의 UA, 두개의 MTA Client-Server 쌍, 한개의 MAA Client-Server쌍이 필요하다</li>
</ul>
<h3 id="ua-mta-maa">UA, MTA, MAA<a aria-hidden="true" tabindex="-1" href="#ua-mta-maa" class="internal"> §</a></h3>
<ul>
<li>뭐 위에서 다 말하긴 했지만 총정리하면</li>
<li><strong>UA(User Agent)</strong> 는 참여자와 소통하며 메일 작성하거나 도착한 메일을 출력하거나 하는 식의 UI에 해당하는 작업 및 같은 시스템에 있는 Mail Server의 메일함에 메일을 넣거나 가져오는 작업만 가능한 프로세스이고
<ul>
<li>뭐 옛날 고조선사람들은 Terminal Command형태의 UA를 사용했다네</li>
</ul>
</li>
<li><strong>MTA(Mail Transfer Agent)</strong> 는 다른 시스템에 있는 Mail Server한테 메일을 보내려고 할때 사용되는 프로세스로 메일을 보내는쪽이 Client, 받는쪽이 Server가 되는 것이다
<ul>
<li>Client가 메일을 보내는 쪽이기 때문에 <strong>Push Functionality</strong>를 제공한다고들 함</li>
</ul>
</li>
<li><strong>MAA(Mail Access Agent)</strong> 는 다른 시스템에 있는 Mail Server한테서 메일을 받아오려고 할 때 사용되는 프로세스로 메일을 받는쪽이 Client, 보내는쪽이 Server가 된다
<ul>
<li>얘는 Client가 메일을 받아오는 쪽이기 때문에 <strong>Pull Functionality</strong>를 제공한다고 표현하드라</li>
</ul>
</li>
</ul>
<h3 id="mime">MIME<a aria-hidden="true" tabindex="-1" href="#mime" class="internal"> §</a></h3>
<p><img src="../../../../gardens/network/originals/comnet.fall.2021.cse.cnu.ac.kr/images/12_50f46370c92949f9b8ec57f6b99b1e3d/image10.png" alt="%E1%84%8B%E1%85%B5%E1%84%85%E1%85%A9%E1%86%AB12%20-%20TELNET,%20Email,%20File%20Transfer%2050f46370c92949f9b8ec57f6b99b1e3d/image10.png"/></p>
<ul>
<li>얘는 UA와 MTA사이에서 메시지의 인코딩을 담당하는 놈인데</li>
<li>MTA는 7-bit NVT ASCII만 보낼 수 있다 - 즉, Printable Character만 보낼 수 있고 최상위 비트는 무조건 0이어야 된다는 것</li>
<li>근데 옛날에야 뭐 텍스트만 보내도 흡족했지만 지금은 파일도 보내고 동야도 보내고 해야되는데 7-bit NVT ASCII로는 저런 bit stream을 보낼 수가 없음</li>
<li>그래서 bit stream을 7-bit NVT ASCII로 변환하고 그걸 다시 bit stream으로 변환하는 역할을 하는놈이 <strong>MIME(Multipurpose Internet Mail Extensions)</strong> 이다</li>
<li>인코딩방식은 여러개 있는데 대표적으로 니가 아는 그 Base64로 인코딩한담에 나머지 2비트는 00으로 채워서 보내고 받을때도 00빼고 합치는 식으로 한다</li>
</ul>
<h3 id="smtp">SMTP<a aria-hidden="true" tabindex="-1" href="#smtp" class="internal"> §</a></h3>
<p><img src="../../../../gardens/network/originals/comnet.fall.2021.cse.cnu.ac.kr/images/12_50f46370c92949f9b8ec57f6b99b1e3d/image11.png" alt="%E1%84%8B%E1%85%B5%E1%84%85%E1%85%A9%E1%86%AB12%20-%20TELNET,%20Email,%20File%20Transfer%2050f46370c92949f9b8ec57f6b99b1e3d/image11.png"/></p>
<ul>
<li><strong>SMTP(Simple Mail Transfer Protocol)</strong> MTA 프로토콜로 제일 유명하고 현재 거의 유일하게 사용되고 있는 프로토콜이다</li>
<li>통신은 <strong>Connection Establishment</strong>, <strong>Mail Transfer</strong>, <strong>Connection Termination</strong>순서로 진행된다</li>
</ul>
<p><img src="../../../../gardens/network/originals/comnet.fall.2021.cse.cnu.ac.kr/images/12_50f46370c92949f9b8ec57f6b99b1e3d/image12.png" alt="%E1%84%8B%E1%85%B5%E1%84%85%E1%85%A9%E1%86%AB12%20-%20TELNET,%20Email,%20File%20Transfer%2050f46370c92949f9b8ec57f6b99b1e3d/image12.png"/></p>
<ul>
<li>위 그림처럼 MTA Client는 COMMAND ARGUMENTS …의 포맷으로 <strong>Commands</strong>를 보내며</li>
<li>그에 대한 응답으로 MTA Server는 STATUS_CODE STATUS_MSG의 형태로 <strong>Response</strong>를 보낸다</li>
</ul>
<h3 id="예시">예시<a aria-hidden="true" tabindex="-1" href="#예시" class="internal"> §</a></h3>
<ul>
<li>예시를 보면서 통신 과정 알아보자구</li>
</ul>
<p><img src="../../../../gardens/network/originals/comnet.fall.2021.cse.cnu.ac.kr/images/12_50f46370c92949f9b8ec57f6b99b1e3d/image13.png" alt="%E1%84%8B%E1%85%B5%E1%84%85%E1%85%A9%E1%86%AB12%20-%20TELNET,%20Email,%20File%20Transfer%2050f46370c92949f9b8ec57f6b99b1e3d/image13.png"/></p>
<ul>
<li>위처럼 telnet $MAIL_SERVER_DOMAIN 25 명령어로 시작하게 된다</li>
<li>당연히 $MAIL_SERVER_DOMAIN은 메일 서버의 도메인이고</li>
<li>25는 포트 번호이다 - SMTP는 25의 포트 번호를 사용하더라</li>
</ul>
<p><img src="../../../../gardens/network/originals/comnet.fall.2021.cse.cnu.ac.kr/images/12_50f46370c92949f9b8ec57f6b99b1e3d/image14.png" alt="%E1%84%8B%E1%85%B5%E1%84%85%E1%85%A9%E1%86%AB12%20-%20TELNET,%20Email,%20File%20Transfer%2050f46370c92949f9b8ec57f6b99b1e3d/image14.png"/></p>
<ul>
<li>그럼 이래됨 - 예제에서 분홍색은 Response이고 검은색이 Command이다</li>
<li>일단 <strong>220</strong>은 Service Ready → 메일 서버가 준비되었다는 뜻임</li>
<li>그럼 그상태에서 HELO $MAIL_SERVER_DOMAIN을 보내면 Connection을 시도하게 됨 - <strong>HELO</strong>가 주어진 도메인이랑 Connection을 하겠다는 Command임</li>
<li>Connection이 이루어졌으면 <strong>250</strong> 메시지가 오게 됨 - 요청이 완료되었다는 것으로 Connection이 정상적으로 됐다는 소리임</li>
</ul>
<p><img src="../../../../gardens/network/originals/comnet.fall.2021.cse.cnu.ac.kr/images/12_50f46370c92949f9b8ec57f6b99b1e3d/image15.png" alt="%E1%84%8B%E1%85%B5%E1%84%85%E1%85%A9%E1%86%AB12%20-%20TELNET,%20Email,%20File%20Transfer%2050f46370c92949f9b8ec57f6b99b1e3d/image15.png"/></p>
<ul>
<li>솔직히 걍 읽어봐도 뭔말알이긴함</li>
<li>MAIL FROM $SRC로 보내는 사람 메일 주소 명시 가 가능하고</li>
<li>RCPT TO $DST로 받는 사람 메일 주소 명시 가 가능하며</li>
<li>DATA 로 이제 메일을 보내겠다고 알려주게 되며</li>
<li><strong>354</strong>가 오면 메일 내용을 적으면 됨</li>
<li>그리고 Response Message의 <code>&lt;CRLF>.&lt;CRLF></code> 에서 알 수 있듯이 개행 + . + 개행으로 메일 본문이 끝났다는 것을 명시하게 된다</li>
</ul>
<p><img src="../../../../gardens/network/originals/comnet.fall.2021.cse.cnu.ac.kr/images/12_50f46370c92949f9b8ec57f6b99b1e3d/image16.png" alt="%E1%84%8B%E1%85%B5%E1%84%85%E1%85%A9%E1%86%AB12%20-%20TELNET,%20Email,%20File%20Transfer%2050f46370c92949f9b8ec57f6b99b1e3d/image16.png"/></p>
<ul>
<li>그리고 <strong>QUIT</strong>으로 Termination을 하게 된다</li>
</ul>
<h3 id="pop3-imap4">POP3, IMAP4<a aria-hidden="true" tabindex="-1" href="#pop3-imap4" class="internal"> §</a></h3>
<p><img src="../../../../gardens/network/originals/comnet.fall.2021.cse.cnu.ac.kr/images/12_50f46370c92949f9b8ec57f6b99b1e3d/image17.png" alt="%E1%84%8B%E1%85%B5%E1%84%85%E1%85%A9%E1%86%AB12%20-%20TELNET,%20Email,%20File%20Transfer%2050f46370c92949f9b8ec57f6b99b1e3d/image17.png"/></p>
<ul>
<li><strong>POP3(Post Office Protocol v3)</strong> 이랑 <strong>IMAP4(Internet Mail Access Protocol)</strong> 은 MAA프로토콜이다</li>
<li>여기서 알아둬야 할것은</li>
<li>POP3와 IMAP4모두 user-name과 password를 서버에게 보내 인증하는 과정을 거친 다음에 Pull을 진행한다는 절차적인 거하고</li>
<li>POP3는 오래됐고 IMAP4는 비교적 최신에 나온 보안성이 강화된 프로토콜이랜다</li>
</ul>
<h3 id="web-based-mail">Web Based Mail<a aria-hidden="true" tabindex="-1" href="#web-based-mail" class="internal"> §</a></h3>
<ul>
<li>이건 간단한건데</li>
<li>간단하게 생각하면 Outlook같은걸로 메일 송수신할 수도 있고 아니면 브라우저 드가서 메일 송수신할 수도 있자네</li>
<li>이런식으로 End user가 메일링 프로그램을 이용해서 SMTP로 메일을 보내는 것도 가능하지만 브라우저를 이용해 HTTP로 Mail Server에게 push를 하는것도 가능하다</li>
<li>하지만 Mail Server간에는 여전히 SMTP로 통신함</li>
</ul>
<h3 id="mail-server">Mail Server<a aria-hidden="true" tabindex="-1" href="#mail-server" class="internal"> §</a></h3>
<ul>
<li>일단 이메일을 받을때는 무조건 내 메일함이 있는 Mail Server의 MAA Server에게 보내는게 맞는데</li>
<li>이메일을 보낼때는 내 메일함이 있는 Mail Server의 MTA Server로 보낼 필요는 없다 - 가까이 있는 Mail Server로 보내도 됨</li>
<li>이건 왜냐하면 나의 메일함이 있는 Mail Server가 아주 멀리 있는 상황에서 나랑 가까운 놈한테 메일을 보낼때 저짝으로 보내게 되면 멀리 돌아서 메일이 도착하게 되는데 이건 매우 비효율적이기 때문</li>
<li>따라서 예전에는 주변에 있는 아무 Mail Server의 MTA Server로 보내는게 가능했다 - 근데 요즘은 내 메일이 정체를 알 수 없는 Mail Server에 도착한다는 것이 보안상 좋지 않기 때문에 대부분의 Mail Server들은 사용자 인증과정을 거쳐 신뢰할만한 놈인지 확인한 다음에야 Mail의 수신을 받아준다</li>
</ul>
<h2 id="ftp">FTP<a aria-hidden="true" tabindex="-1" href="#ftp" class="internal"> §</a></h2>
<ul>
<li><strong>FTP(File Transfer Protocol)</strong> 은 말그대로 파일을 전송할때 사용하는 프로토콜이고</li>
</ul>
<p><img src="../../../../gardens/network/originals/comnet.fall.2021.cse.cnu.ac.kr/images/12_50f46370c92949f9b8ec57f6b99b1e3d/image18.png" alt="%E1%84%8B%E1%85%B5%E1%84%85%E1%85%A9%E1%86%AB12%20-%20TELNET,%20Email,%20File%20Transfer%2050f46370c92949f9b8ec57f6b99b1e3d/image18.png"/></p>
<ul>
<li>FTP에서 핵심적인 내용은 FTP는 TCP를 사용하며 Connection을 두개 맺는다는 것이다
<ul>
<li>하나는 전송과정에서 Command를 주고 받기 위한 Connection이고 이것은 File Transfer Session이 지속되는 동안 계속 연결되게 된다</li>
<li>그리고 나머지 하나는 실제로 파일이 전송되는 Connection이고 얘는 파일 하나가 보내질때마다 연결을 하게 된다 - 파일 하나를 보내고 나서 또 다른 파일을 보낼때는 연결을 끊었다가 다시 연결하여 전송하게 됨</li>
</ul>
</li>
</ul>
<h3 id="control-connection">Control Connection<a aria-hidden="true" tabindex="-1" href="#control-connection" class="internal"> §</a></h3>
<p><img src="../../../../gardens/network/originals/comnet.fall.2021.cse.cnu.ac.kr/images/12_50f46370c92949f9b8ec57f6b99b1e3d/image19.png" alt="%E1%84%8B%E1%85%B5%E1%84%85%E1%85%A9%E1%86%AB12%20-%20TELNET,%20Email,%20File%20Transfer%2050f46370c92949f9b8ec57f6b99b1e3d/image19.png"/></p>
<ul>
<li><strong>Control Connnection</strong>은 위에서 말한것처럼 File Transfer Session이 지속되는 내내 연결되어 있고 파일전송간 Command를 주고받기 위해 사용하는데</li>
<li><strong>Port 21</strong>을 사용하고</li>
<li><strong>7-bit NVT ASCII</strong>를 사용한다 - 당연히 Command만을 주고받기 때문에 Printable한 bitstream만 주고받게 됨</li>
</ul>
<p><img src="../../../../gardens/network/originals/comnet.fall.2021.cse.cnu.ac.kr/images/12_50f46370c92949f9b8ec57f6b99b1e3d/image20.png" alt="%E1%84%8B%E1%85%B5%E1%84%85%E1%85%A9%E1%86%AB12%20-%20TELNET,%20Email,%20File%20Transfer%2050f46370c92949f9b8ec57f6b99b1e3d/image20.png"/></p>
<ul>
<li>그리고 SMTP와 유사하게 Client가 Command 와 Argument로 이루어진 요청을 보내고 Server가 그에 대한 응답을 3-digit code로 보내는 식으로 진행된다</li>
<li>위의 예시는 그냥 읽어보는 걸로도 충분함</li>
</ul>
<h3 id="data-connection">Data Connection<a aria-hidden="true" tabindex="-1" href="#data-connection" class="internal"> §</a></h3>
<p><img src="../../../../gardens/network/originals/comnet.fall.2021.cse.cnu.ac.kr/images/12_50f46370c92949f9b8ec57f6b99b1e3d/image21.png" alt="%E1%84%8B%E1%85%B5%E1%84%85%E1%85%A9%E1%86%AB12%20-%20TELNET,%20Email,%20File%20Transfer%2050f46370c92949f9b8ec57f6b99b1e3d/image21.png"/></p>
<ul>
<li>File Transfer에서 Data를 보낼때의 어려운 점은 Command를 보낼때와는 다르게 파일 타입, 인코딩 방식, 파일 디렉토리의 구조들, 파일 이름 등등이 표준화시킬 수 없기 때문에 이러한 다양성을 극복해야 했다는 것이다</li>
<li>뭐 이런 어려운 점만 있었고 이걸 어떻게 극복했는지는 몰라도 된댄다</li>
</ul></article></div><div class="right sidebar"><div class="graph "><h3>Graph View</h3><div class="graph-outer"><div id="graph-container" data-cfg="{&quot;drag&quot;:true,&quot;zoom&quot;:true,&quot;depth&quot;:1,&quot;scale&quot;:1.1,&quot;repelForce&quot;:0.5,&quot;centerForce&quot;:0.3,&quot;linkDistance&quot;:30,&quot;fontSize&quot;:0.6,&quot;opacityScale&quot;:1,&quot;showTags&quot;:true,&quot;removeTags&quot;:[]}"></div><svg version="1.1" id="global-graph-icon" xmlns="http://www.w3.org/2000/svg" xmlnsXlink="http://www.w3.org/1999/xlink" x="0px" y="0px" viewBox="0 0 55 55" fill="currentColor" xmlSpace="preserve"><path d="M49,0c-3.309,0-6,2.691-6,6c0,1.035,0.263,2.009,0.726,2.86l-9.829,9.829C32.542,17.634,30.846,17,29,17
	s-3.542,0.634-4.898,1.688l-7.669-7.669C16.785,10.424,17,9.74,17,9c0-2.206-1.794-4-4-4S9,6.794,9,9s1.794,4,4,4
	c0.74,0,1.424-0.215,2.019-0.567l7.669,7.669C21.634,21.458,21,23.154,21,25s0.634,3.542,1.688,4.897L10.024,42.562
	C8.958,41.595,7.549,41,6,41c-3.309,0-6,2.691-6,6s2.691,6,6,6s6-2.691,6-6c0-1.035-0.263-2.009-0.726-2.86l12.829-12.829
	c1.106,0.86,2.44,1.436,3.898,1.619v10.16c-2.833,0.478-5,2.942-5,5.91c0,3.309,2.691,6,6,6s6-2.691,6-6c0-2.967-2.167-5.431-5-5.91
	v-10.16c1.458-0.183,2.792-0.759,3.898-1.619l7.669,7.669C41.215,39.576,41,40.26,41,41c0,2.206,1.794,4,4,4s4-1.794,4-4
	s-1.794-4-4-4c-0.74,0-1.424,0.215-2.019,0.567l-7.669-7.669C36.366,28.542,37,26.846,37,25s-0.634-3.542-1.688-4.897l9.665-9.665
	C46.042,11.405,47.451,12,49,12c3.309,0,6-2.691,6-6S52.309,0,49,0z M11,9c0-1.103,0.897-2,2-2s2,0.897,2,2s-0.897,2-2,2
	S11,10.103,11,9z M6,51c-2.206,0-4-1.794-4-4s1.794-4,4-4s4,1.794,4,4S8.206,51,6,51z M33,49c0,2.206-1.794,4-4,4s-4-1.794-4-4
	s1.794-4,4-4S33,46.794,33,49z M29,31c-3.309,0-6-2.691-6-6s2.691-6,6-6s6,2.691,6,6S32.309,31,29,31z M47,41c0,1.103-0.897,2-2,2
	s-2-0.897-2-2s0.897-2,2-2S47,39.897,47,41z M49,10c-2.206,0-4-1.794-4-4s1.794-4,4-4s4,1.794,4,4S51.206,10,49,10z"></path></svg></div><div id="global-graph-outer"><div id="global-graph-container" data-cfg="{&quot;drag&quot;:true,&quot;zoom&quot;:true,&quot;depth&quot;:-1,&quot;scale&quot;:0.9,&quot;repelForce&quot;:0.5,&quot;centerForce&quot;:0.3,&quot;linkDistance&quot;:30,&quot;fontSize&quot;:0.6,&quot;opacityScale&quot;:1,&quot;showTags&quot;:true,&quot;removeTags&quot;:[]}"></div></div></div><div class="toc desktop-only"><button type="button" id="toc"><h3>Table of Contents</h3><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="fold"><polyline points="6 9 12 15 18 9"></polyline></svg></button><div id="toc-content"><ul class="overflow"><li class="depth-0"><a href="#telnet" data-for="telnet">TELNET</a></li><li class="depth-1"><a href="#ascii-encoding-issue" data-for="ascii-encoding-issue">ASCII, Encoding Issue</a></li><li class="depth-1"><a href="#local-log-in" data-for="local-log-in">Local Log in</a></li><li class="depth-1"><a href="#remote-log-in" data-for="remote-log-in">Remote Log in</a></li><li class="depth-0"><a href="#electronic-mail-service" data-for="electronic-mail-service">Electronic Mail Service</a></li><li class="depth-1"><a href="#architecture" data-for="architecture">Architecture</a></li><li class="depth-1"><a href="#scenario-1---both-participant-are-connected-direclty-to-the-same-system" data-for="scenario-1---both-participant-are-connected-direclty-to-the-same-system">Scenario 1 - Both Participant are Connected Direclty to the Same System</a></li><li class="depth-1"><a href="#scenario-2---both-participants-are-connected-to-separate-system" data-for="scenario-2---both-participants-are-connected-to-separate-system">Scenario 2 - Both Participants are Connected to Separate System</a></li><li class="depth-1"><a href="#scenario-3---some-participant-are-not-connected-to-system" data-for="scenario-3---some-participant-are-not-connected-to-system">Scenario 3 - Some Participant are not Connected to System</a></li><li class="depth-1"><a href="#scenario-4---both-participant-are-not-connected-to-system" data-for="scenario-4---both-participant-are-not-connected-to-system">Scenario 4 - Both Participant are not Connected to System</a></li><li class="depth-1"><a href="#ua-mta-maa" data-for="ua-mta-maa">UA, MTA, MAA</a></li><li class="depth-1"><a href="#mime" data-for="mime">MIME</a></li><li class="depth-1"><a href="#smtp" data-for="smtp">SMTP</a></li><li class="depth-1"><a href="#예시" data-for="예시">예시</a></li><li class="depth-1"><a href="#pop3-imap4" data-for="pop3-imap4">POP3, IMAP4</a></li><li class="depth-1"><a href="#web-based-mail" data-for="web-based-mail">Web Based Mail</a></li><li class="depth-1"><a href="#mail-server" data-for="mail-server">Mail Server</a></li><li class="depth-0"><a href="#ftp" data-for="ftp">FTP</a></li><li class="depth-1"><a href="#control-connection" data-for="control-connection">Control Connection</a></li><li class="depth-1"><a href="#data-connection" data-for="data-connection">Data Connection</a></li></ul></div></div><div class="backlinks "><h3>Backlinks</h3><ul class="overflow"><li><a href="../../../../gardens/network/originals/comnet.fall.2021.cse.cnu.ac.kr/(충남대)-컴퓨터-네트워크-강의록" class="internal">(충남대) 컴퓨터 네트워크 강의록</a></li></ul></div></div></div><footer class><hr/><p>Created with <a href="https://quartz.jzhao.xyz/">Quartz v4.1.0</a>, © 2024</p><ul><li><a href="https://github.com/haeramkeem">GitHub</a></li><li><a href="www.linkedin.com/in/haeram-kim-277404220">LinkedIn</a></li><li><a href="mailto:haeram.kim1@gmail.com">Email</a></li></ul></footer></div></body><script type="application/javascript">// quartz/components/scripts/quartz/components/scripts/callout.inline.ts
function toggleCallout() {
  const outerBlock = this.parentElement;
  outerBlock.classList.toggle(`is-collapsed`);
  const collapsed = outerBlock.classList.contains(`is-collapsed`);
  const height = collapsed ? this.scrollHeight : outerBlock.scrollHeight;
  outerBlock.style.maxHeight = height + `px`;
  let current = outerBlock;
  let parent = outerBlock.parentElement;
  while (parent) {
    if (!parent.classList.contains(`callout`)) {
      return;
    }
    const collapsed2 = parent.classList.contains(`is-collapsed`);
    const height2 = collapsed2 ? parent.scrollHeight : parent.scrollHeight + current.scrollHeight;
    parent.style.maxHeight = height2 + `px`;
    current = parent;
    parent = parent.parentElement;
  }
}
function setupCallout() {
  const collapsible = document.getElementsByClassName(
    `callout is-collapsible`
  );
  for (const div of collapsible) {
    const title = div.firstElementChild;
    if (title) {
      title.removeEventListener(`click`, toggleCallout);
      title.addEventListener(`click`, toggleCallout);
      const collapsed = div.classList.contains(`is-collapsed`);
      const height = collapsed ? title.scrollHeight : div.scrollHeight;
      div.style.maxHeight = height + `px`;
    }
  }
}
document.addEventListener(`nav`, setupCallout);
window.addEventListener(`resize`, setupCallout);
</script><script type="module">
          import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.esm.min.mjs';
          const darkMode = document.documentElement.getAttribute('saved-theme') === 'dark'
          mermaid.initialize({
            startOnLoad: false,
            securityLevel: 'loose',
            theme: darkMode ? 'dark' : 'default'
          });
          document.addEventListener('nav', async () => {
            await mermaid.run({
              querySelector: '.mermaid'
            })
          });
          </script><script src="https://cdn.jsdelivr.net/npm/katex@0.16.7/dist/contrib/copy-tex.min.js" type="application/javascript"></script><script src="https://www.googletagmanager.com/gtag/js?id=G-N68CCP1QHG" type="application/javascript"></script><script src="../../../../postscript.js" type="module"></script></html>