<!DOCTYPE html>
<html><head><title>08. Transport Layer &amp; UDP</title><meta charSet="utf-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:title" content="08. Transport Layer &amp; UDP"/><meta property="og:description" content="충남대학교 컴퓨터공학과 김상하 교수님의 &amp;quot;컴퓨터 네트워크&amp;quot; 강의를 필기한 내용입니다. 다소 잘못된 내용과 구어적 표현 이 포함되어 있을 수 있습니다. Transport Layer § 위 그림에서처럼 호스트한테 도착한 이후, 호스트 내의 특정 프로세스로 데이터를 전달하기 위한 계층이 Transport layer이다 이것을 위해선 Port address가 있어 특정 port address로 데이터를 전송해 올바른 프로세스로 찾아가게 한다 즉, Process-to-Process Delivery를 위한 계층이 Transport layer인 셈 종류로는 UDP, TCP, SCTP가 있고 이중에 TCP가 제일 유명하지만 UDP나 SCTP를 사용할 수도 있댄다 Process-to-Process Delivery § 일단 용어정리를 좀 하면 IP주소가 A인 Host의 port a가 IP주소가 P인 Host의 port j로 보내면 Local host는 A이고 Remote host는 P이다 - Local host와 Remote host에서 host는 IP를 뜻하는 말임 Local process는 a이고 Remote process는 j이다 - Local process와 Remote process에서 process는 port를 뜻하는 거더라 Client-server model § 데이터를 받는 상대방의 port는 어떻게 알아내냐는 궁금증에 생기게 되는데 상대방의 port를 알아내는 방법으로 Client-server model을 사용하게 된다 일단 Client는 통신을 시작하는 쪽, 먼저 요청하는 놈 - Initiator이라고 생각하면 된다 일반적으로는 서비스를 요청하는놈이라고 생각해도 되지만 특별한 경우에는 서비스를 제공해주는 놈이 통신을 시작하기도 하더라 그리고 Server는 Client의 통신 / 요청에 대해 응답하는놈 - Responser이 된다 이때 Client-server model에서는 Server의 port를 이미 잘 알려진 값인 well-known port를 사용한다 뭐 알다시피 http의 경우에는 80을 사용하쥬 즉, Server가 well known port를 사용하기 때문에 통신을 시작하는 쪽인 Client는 Server의 port번호를 알 수 밖에 없다 따라서 Client가 well known port로 보내게 되면 Server는 그것을 받고 Client의 port번호를 알아낼 수 있기 때문에 정상적인 응답을 보내줄 수 있는 것 위에가 예신데 보다시피 Daytime 이라는 프로토콜에서는 Server가 13이라는 Well-known port를 이용하고 클라이언트는 이걸 알기 때문에 자신의 임시 port인 52000을 실어 보내면 Server가 알게 되는 것 클라이언트의 port는 임시적인거고 프로세스가 죽으면 다른 프로세스에게로 할당될 수 있다 - Ephemeral local port number라고 하더라 그리고 MAC, IP주소와 마찬가지로 port번호도 다른 계층에서 알 수 없는 것은 아니다 - port번호가 패킷에 담기는 자료구조를 모르는 것 일례로 IP주소가 Transport계층을 넘어 Application까지 넘어가는 경우가 있고 port라는 것도 Transport의 상위계층에서 넘겨주는 값이다 Address System § Port Number § IANA라는 기관에서 port번호를 정하는 규칙을 만들어놨댄다 보면 0~1024까지는 well-known 1024~49151까지는 Registered라고 해서 나중에 쓸 목적으로 비워둔 곳 49152~65535는 프로세스가 임시로 할당받게 되는 값이다 Socket Address § IP와 Port를 합친 주소를 Socket Address라고 한다 얘는 Application Layer에서 사용하는 주소 중 하나로 다른 계층의 주소를 사용할 수 있다는 것을 보여주는 또 다른 사례인 것 Multiplexer, Demultiplexer § Process들에게서 전달받은 데이터를 취합하여 IP로 보내는 Multiplexer와 받은 데이터를 다시 나눠 각각의 Process들에게 뿌려주는 Demultiplexer가 있댄다 Connection, Reliable § Connectionless vs Connection-oriented § 일단 앞에서 배운것처럼 Connection이라는 것은 데이터가 보내진 순서대로 도착하느냐 아니냐에 따라 나눠진다 Connectionless는 순서가 바뀌든 중간에 유실되든 상관 없이 전송되는 것을 의미 - UDP가 여기에 해당한다 그리고 Connection-Oriented는 순서가 바뀌면 안되고 보낸 순서대로 도착해야되는 것 - TCP과 SCTP가 여기에 해당한다 Connection-Oriented는 다음과 같이 작동함 일단 한놈이 Connection-Oriented하게 통신하자고 메세지를 보냄 그럼 그걸 받은놈은 버퍼를 준비하고 준비됐다고 답장을 보냄 통신시작하는쪽은 버퍼를 준비하며 알았다고 메세지를 보낸 뒤 데이터들을 보낼 순서대로 Numbering을 한다 - 순번을 다 적어놓는 셈 그리고 이걸 보내게 되면 받는쪽은 그걸 받아서 바로 Application Layer로 올리는게 아니고 일단 버퍼에 저장해둔다 그리고 데이터가 다 도착하면 그제서야 버퍼에 있는 데이터들의 순번을 보고 순서대로 Application Layer로 올려보내게 됨 그렇다고 Connectionless라고 해서 순서를 아예 무시하는건 아닐 수도 있다 - Transport계층에게 그걸 맡기지 않는다는 거지 Application Layer에서 자체적으로 하는 경우도 있다더라 Reliable vs Unreliable § 일단 Reliable은 다음과 같은 에러가 없을때를 지칭하는 말이다 Flow Control Error : 수신속도보다 송신속도가 더 빨라 Overwrite되는 경우 Physical Error : 노이즈가 끼는 경우 TCP, SCTP가 여기 해당함 당연히 Unreliable은 이러한 에러가 있을 수도 있을 때를 말하는 거겠지 UDP가 여기 해당함 이것도 마찬가지로 Unreliable하다고 에러를 무시할 수도 있지만 그렇지 않을 수도 있다 - Application Layer에서 자체적으로 하는 경우도 있다 이거야 근데 Data link layer에서 이런 것들을 해주는데 왜 Transport 계층에서도 하는지 의문이 들 수 있는데 그건 아래 예시 보면 알 수 있음 보면 일단 분홍색 선으로 표시된 부분에는 Data link layer의 활약으로 에러가 없음 근데 위 그림에서 검은색 선으로 표시된 부분에서 에러가 날 수 있다 이건 왜냐하면 Router에서는 Incoming queue에서 Outgoing queue로 패킷을 옮겨야 하는데 이 queue의 크기가 무한한게 아니기 때문에 패킷이 많이 쌓여 공간이 부족하게 되어 에러가 남 이런걸 Queue overflow by congestion, False Flow Control이라고 하더라 UDP § User Datagram Protocol(UDP) 는 IP에 Port를 추가해 Process-to-Process 기능만 덧붙이고 나머지는 아무것도 하지 않는 프로토콜이다 당연히 Process로 연결해주는것 외에는 아무것도 하지 않기 때문에 Connectionless, Unreliable하다 UDP에서 사용하는 Well-known port 들임 - 참고만 혀 헤더의 구조는 위와 같다 - 단순 근데 Total length는 굳이 필요 없다 - IP헤더의 total length부분에서 hlen을 빼면 구할 수 있기 때문에 하지만 Transport 계층의 정보를 얻기 위해 IP계층에 물어보는 것은 약간 자존심상해서 만들어놨댄다 구조 § 위 그림처럼 port 하나가 열리면 UDP에서는 Application과 데이터를 주고받을 Incoming queue와 Outgoing queue가 열린다 근데 이때 서버에서는 여러 Client로부터 데이터를 받기 때문에 Incoming queue를 하나만 사용하면 데이터가 어디에서 온 건지 알수 없게 되는데 왜 알수 없냐면 Application layer로 올라갈때는 Header가 제거되기 때문 그래서 UDP에서 Application으로 올릴때 Header를 뗀 Data뿐 아니라 Socket Address도 같이 주어 이놈이 어디에서 와서 어디로 가야되는지 Application layer로 보내준다 ."/><meta property="og:image" content="https://mdg.haeramk.im/static/og-image.png"/><meta property="og:width" content="1200"/><meta property="og:height" content="675"/><link rel="icon" href="../../../../static/icon.png"/><meta name="description" content="충남대학교 컴퓨터공학과 김상하 교수님의 &amp;quot;컴퓨터 네트워크&amp;quot; 강의를 필기한 내용입니다. 다소 잘못된 내용과 구어적 표현 이 포함되어 있을 수 있습니다. Transport Layer § 위 그림에서처럼 호스트한테 도착한 이후, 호스트 내의 특정 프로세스로 데이터를 전달하기 위한 계층이 Transport layer이다 이것을 위해선 Port address가 있어 특정 port address로 데이터를 전송해 올바른 프로세스로 찾아가게 한다 즉, Process-to-Process Delivery를 위한 계층이 Transport layer인 셈 종류로는 UDP, TCP, SCTP가 있고 이중에 TCP가 제일 유명하지만 UDP나 SCTP를 사용할 수도 있댄다 Process-to-Process Delivery § 일단 용어정리를 좀 하면 IP주소가 A인 Host의 port a가 IP주소가 P인 Host의 port j로 보내면 Local host는 A이고 Remote host는 P이다 - Local host와 Remote host에서 host는 IP를 뜻하는 말임 Local process는 a이고 Remote process는 j이다 - Local process와 Remote process에서 process는 port를 뜻하는 거더라 Client-server model § 데이터를 받는 상대방의 port는 어떻게 알아내냐는 궁금증에 생기게 되는데 상대방의 port를 알아내는 방법으로 Client-server model을 사용하게 된다 일단 Client는 통신을 시작하는 쪽, 먼저 요청하는 놈 - Initiator이라고 생각하면 된다 일반적으로는 서비스를 요청하는놈이라고 생각해도 되지만 특별한 경우에는 서비스를 제공해주는 놈이 통신을 시작하기도 하더라 그리고 Server는 Client의 통신 / 요청에 대해 응답하는놈 - Responser이 된다 이때 Client-server model에서는 Server의 port를 이미 잘 알려진 값인 well-known port를 사용한다 뭐 알다시피 http의 경우에는 80을 사용하쥬 즉, Server가 well known port를 사용하기 때문에 통신을 시작하는 쪽인 Client는 Server의 port번호를 알 수 밖에 없다 따라서 Client가 well known port로 보내게 되면 Server는 그것을 받고 Client의 port번호를 알아낼 수 있기 때문에 정상적인 응답을 보내줄 수 있는 것 위에가 예신데 보다시피 Daytime 이라는 프로토콜에서는 Server가 13이라는 Well-known port를 이용하고 클라이언트는 이걸 알기 때문에 자신의 임시 port인 52000을 실어 보내면 Server가 알게 되는 것 클라이언트의 port는 임시적인거고 프로세스가 죽으면 다른 프로세스에게로 할당될 수 있다 - Ephemeral local port number라고 하더라 그리고 MAC, IP주소와 마찬가지로 port번호도 다른 계층에서 알 수 없는 것은 아니다 - port번호가 패킷에 담기는 자료구조를 모르는 것 일례로 IP주소가 Transport계층을 넘어 Application까지 넘어가는 경우가 있고 port라는 것도 Transport의 상위계층에서 넘겨주는 값이다 Address System § Port Number § IANA라는 기관에서 port번호를 정하는 규칙을 만들어놨댄다 보면 0~1024까지는 well-known 1024~49151까지는 Registered라고 해서 나중에 쓸 목적으로 비워둔 곳 49152~65535는 프로세스가 임시로 할당받게 되는 값이다 Socket Address § IP와 Port를 합친 주소를 Socket Address라고 한다 얘는 Application Layer에서 사용하는 주소 중 하나로 다른 계층의 주소를 사용할 수 있다는 것을 보여주는 또 다른 사례인 것 Multiplexer, Demultiplexer § Process들에게서 전달받은 데이터를 취합하여 IP로 보내는 Multiplexer와 받은 데이터를 다시 나눠 각각의 Process들에게 뿌려주는 Demultiplexer가 있댄다 Connection, Reliable § Connectionless vs Connection-oriented § 일단 앞에서 배운것처럼 Connection이라는 것은 데이터가 보내진 순서대로 도착하느냐 아니냐에 따라 나눠진다 Connectionless는 순서가 바뀌든 중간에 유실되든 상관 없이 전송되는 것을 의미 - UDP가 여기에 해당한다 그리고 Connection-Oriented는 순서가 바뀌면 안되고 보낸 순서대로 도착해야되는 것 - TCP과 SCTP가 여기에 해당한다 Connection-Oriented는 다음과 같이 작동함 일단 한놈이 Connection-Oriented하게 통신하자고 메세지를 보냄 그럼 그걸 받은놈은 버퍼를 준비하고 준비됐다고 답장을 보냄 통신시작하는쪽은 버퍼를 준비하며 알았다고 메세지를 보낸 뒤 데이터들을 보낼 순서대로 Numbering을 한다 - 순번을 다 적어놓는 셈 그리고 이걸 보내게 되면 받는쪽은 그걸 받아서 바로 Application Layer로 올리는게 아니고 일단 버퍼에 저장해둔다 그리고 데이터가 다 도착하면 그제서야 버퍼에 있는 데이터들의 순번을 보고 순서대로 Application Layer로 올려보내게 됨 그렇다고 Connectionless라고 해서 순서를 아예 무시하는건 아닐 수도 있다 - Transport계층에게 그걸 맡기지 않는다는 거지 Application Layer에서 자체적으로 하는 경우도 있다더라 Reliable vs Unreliable § 일단 Reliable은 다음과 같은 에러가 없을때를 지칭하는 말이다 Flow Control Error : 수신속도보다 송신속도가 더 빨라 Overwrite되는 경우 Physical Error : 노이즈가 끼는 경우 TCP, SCTP가 여기 해당함 당연히 Unreliable은 이러한 에러가 있을 수도 있을 때를 말하는 거겠지 UDP가 여기 해당함 이것도 마찬가지로 Unreliable하다고 에러를 무시할 수도 있지만 그렇지 않을 수도 있다 - Application Layer에서 자체적으로 하는 경우도 있다 이거야 근데 Data link layer에서 이런 것들을 해주는데 왜 Transport 계층에서도 하는지 의문이 들 수 있는데 그건 아래 예시 보면 알 수 있음 보면 일단 분홍색 선으로 표시된 부분에는 Data link layer의 활약으로 에러가 없음 근데 위 그림에서 검은색 선으로 표시된 부분에서 에러가 날 수 있다 이건 왜냐하면 Router에서는 Incoming queue에서 Outgoing queue로 패킷을 옮겨야 하는데 이 queue의 크기가 무한한게 아니기 때문에 패킷이 많이 쌓여 공간이 부족하게 되어 에러가 남 이런걸 Queue overflow by congestion, False Flow Control이라고 하더라 UDP § User Datagram Protocol(UDP) 는 IP에 Port를 추가해 Process-to-Process 기능만 덧붙이고 나머지는 아무것도 하지 않는 프로토콜이다 당연히 Process로 연결해주는것 외에는 아무것도 하지 않기 때문에 Connectionless, Unreliable하다 UDP에서 사용하는 Well-known port 들임 - 참고만 혀 헤더의 구조는 위와 같다 - 단순 근데 Total length는 굳이 필요 없다 - IP헤더의 total length부분에서 hlen을 빼면 구할 수 있기 때문에 하지만 Transport 계층의 정보를 얻기 위해 IP계층에 물어보는 것은 약간 자존심상해서 만들어놨댄다 구조 § 위 그림처럼 port 하나가 열리면 UDP에서는 Application과 데이터를 주고받을 Incoming queue와 Outgoing queue가 열린다 근데 이때 서버에서는 여러 Client로부터 데이터를 받기 때문에 Incoming queue를 하나만 사용하면 데이터가 어디에서 온 건지 알수 없게 되는데 왜 알수 없냐면 Application layer로 올라갈때는 Header가 제거되기 때문 그래서 UDP에서 Application으로 올릴때 Header를 뗀 Data뿐 아니라 Socket Address도 같이 주어 이놈이 어디에서 와서 어디로 가야되는지 Application layer로 보내준다 ."/><meta name="generator" content="Quartz"/><link rel="preconnect" href="https://fonts.googleapis.com"/><link rel="preconnect" href="https://fonts.gstatic.com"/><link href="../../../../index.css" rel="stylesheet" type="text/css" spa-preserve/><link href="https://cdn.jsdelivr.net/npm/katex@0.16.0/dist/katex.min.css" rel="stylesheet" type="text/css" spa-preserve/><link href="https://fonts.googleapis.com/css2?family=IBM Plex Mono&amp;family=Gowun Batang:wght@400;700&amp;family=Gowun Dodum:ital,wght@0,400;0,600;1,400;1,600&amp;display=swap" rel="stylesheet" type="text/css" spa-preserve/><script src="../../../../prescript.js" type="application/javascript" spa-preserve></script><script type="application/javascript" spa-preserve>const fetchData = fetch(`../../../../static/contentIndex.json`).then(data => data.json())</script></head><body data-slug="gardens/network/originals/comnet.fall.2021.cse.cnu.ac.kr/08.-Transport-Layer-&amp;-UDP"><div id="quartz-root" class="page"><div id="quartz-body"><div class="left sidebar"><h1 class="page-title "><a href="../../../..">Madison Digital Garden</a></h1><div class="spacer mobile-only"></div><div class="search "><div id="search-icon"><p>Search</p><div></div><svg tabIndex="0" aria-labelledby="title desc" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 19.9 19.7"><title id="title">Search</title><desc id="desc">Search</desc><g class="search-path" fill="none"><path stroke-linecap="square" d="M18.5 18.3l-5.4-5.4"></path><circle cx="8" cy="8" r="7"></circle></g></svg></div><div id="search-container"><div id="search-space"><input autocomplete="off" id="search-bar" name="search" type="text" aria-label="Search for something" placeholder="Search for something"/><div id="results-container"></div></div></div></div><div class="darkmode "><input class="toggle" id="darkmode-toggle" type="checkbox" tabIndex="-1"/><label id="toggle-label-light" for="darkmode-toggle" tabIndex="-1"><svg xmlns="http://www.w3.org/2000/svg" xmlnsXlink="http://www.w3.org/1999/xlink" version="1.1" id="dayIcon" x="0px" y="0px" viewBox="0 0 35 35" style="enable-background:new 0 0 35 35;" xmlSpace="preserve"><title>Light mode</title><path d="M6,17.5C6,16.672,5.328,16,4.5,16h-3C0.672,16,0,16.672,0,17.5    S0.672,19,1.5,19h3C5.328,19,6,18.328,6,17.5z M7.5,26c-0.414,0-0.789,0.168-1.061,0.439l-2,2C4.168,28.711,4,29.086,4,29.5    C4,30.328,4.671,31,5.5,31c0.414,0,0.789-0.168,1.06-0.44l2-2C8.832,28.289,9,27.914,9,27.5C9,26.672,8.329,26,7.5,26z M17.5,6    C18.329,6,19,5.328,19,4.5v-3C19,0.672,18.329,0,17.5,0S16,0.672,16,1.5v3C16,5.328,16.671,6,17.5,6z M27.5,9    c0.414,0,0.789-0.168,1.06-0.439l2-2C30.832,6.289,31,5.914,31,5.5C31,4.672,30.329,4,29.5,4c-0.414,0-0.789,0.168-1.061,0.44    l-2,2C26.168,6.711,26,7.086,26,7.5C26,8.328,26.671,9,27.5,9z M6.439,8.561C6.711,8.832,7.086,9,7.5,9C8.328,9,9,8.328,9,7.5    c0-0.414-0.168-0.789-0.439-1.061l-2-2C6.289,4.168,5.914,4,5.5,4C4.672,4,4,4.672,4,5.5c0,0.414,0.168,0.789,0.439,1.06    L6.439,8.561z M33.5,16h-3c-0.828,0-1.5,0.672-1.5,1.5s0.672,1.5,1.5,1.5h3c0.828,0,1.5-0.672,1.5-1.5S34.328,16,33.5,16z     M28.561,26.439C28.289,26.168,27.914,26,27.5,26c-0.828,0-1.5,0.672-1.5,1.5c0,0.414,0.168,0.789,0.439,1.06l2,2    C28.711,30.832,29.086,31,29.5,31c0.828,0,1.5-0.672,1.5-1.5c0-0.414-0.168-0.789-0.439-1.061L28.561,26.439z M17.5,29    c-0.829,0-1.5,0.672-1.5,1.5v3c0,0.828,0.671,1.5,1.5,1.5s1.5-0.672,1.5-1.5v-3C19,29.672,18.329,29,17.5,29z M17.5,7    C11.71,7,7,11.71,7,17.5S11.71,28,17.5,28S28,23.29,28,17.5S23.29,7,17.5,7z M17.5,25c-4.136,0-7.5-3.364-7.5-7.5    c0-4.136,3.364-7.5,7.5-7.5c4.136,0,7.5,3.364,7.5,7.5C25,21.636,21.636,25,17.5,25z"></path></svg></label><label id="toggle-label-dark" for="darkmode-toggle" tabIndex="-1"><svg xmlns="http://www.w3.org/2000/svg" xmlnsXlink="http://www.w3.org/1999/xlink" version="1.1" id="nightIcon" x="0px" y="0px" viewBox="0 0 100 100" style="enable-background='new 0 0 100 100'" xmlSpace="preserve"><title>Dark mode</title><path d="M96.76,66.458c-0.853-0.852-2.15-1.064-3.23-0.534c-6.063,2.991-12.858,4.571-19.655,4.571  C62.022,70.495,50.88,65.88,42.5,57.5C29.043,44.043,25.658,23.536,34.076,6.47c0.532-1.08,0.318-2.379-0.534-3.23  c-0.851-0.852-2.15-1.064-3.23-0.534c-4.918,2.427-9.375,5.619-13.246,9.491c-9.447,9.447-14.65,22.008-14.65,35.369  c0,13.36,5.203,25.921,14.65,35.368s22.008,14.65,35.368,14.65c13.361,0,25.921-5.203,35.369-14.65  c3.872-3.871,7.064-8.328,9.491-13.246C97.826,68.608,97.611,67.309,96.76,66.458z"></path></svg></label></div></div><div class="center"><div class="page-header"><div class="popover-hint"><h1 class="article-title ">08. Transport Layer &amp; UDP</h1><p class="content-meta ">Jul 29, 2024, 11 min read</p></div></div><article class="popover-hint"><blockquote class="callout" data-callout="info">
<div class="callout-title">
                  <div class="callout-icon"><svg xmlns="http://www.w3.org/2000/svg" width="100%" height="100%" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="10"></circle><line x1="12" y1="16" x2="12" y2="12"></line><line x1="12" y1="8" x2="12.01" y2="8"></line></svg></div>
                  <div class="callout-title-inner"><p>충남대학교 컴퓨터공학과 김상하 교수님의 &quot;컴퓨터 네트워크&quot; 강의를 필기한 내용입니다. </p></div>
                  
                </div>
</blockquote>
<blockquote class="callout" data-callout="warning">
<div class="callout-title">
                  <div class="callout-icon"><svg xmlns="http://www.w3.org/2000/svg" width="100%" height="100%" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="m21.73 18-8-14a2 2 0 0 0-3.48 0l-8 14A2 2 0 0 0 4 21h16a2 2 0 0 0 1.73-3Z"></path><line x1="12" y1="9" x2="12" y2="13"></line><line x1="12" y1="17" x2="12.01" y2="17"></line></svg></div>
                  <div class="callout-title-inner"><p>다소 잘못된 내용과 구어적 표현 이 포함되어 있을 수 있습니다. </p></div>
                  
                </div>
</blockquote>
<h2 id="transport-layer">Transport Layer<a aria-hidden="true" tabindex="-1" href="#transport-layer" class="internal"> §</a></h2>
<p><img src="../../../../gardens/network/originals/comnet.fall.2021.cse.cnu.ac.kr/images/08_330231c4fe894416a9f1b47b0f6a039d/image1.png" alt="%E1%84%8B%E1%85%B5%E1%84%85%E1%85%A9%E1%86%AB08%20-%20Transport%20Layer%20&amp;%20UDP%20330231c4fe894416a9f1b47b0f6a039d/image1.png"/></p>
<ul>
<li>위 그림에서처럼</li>
<li>호스트한테 도착한 이후, 호스트 내의 특정 프로세스로 데이터를 전달하기 위한 계층이 <strong>Transport layer</strong>이다</li>
</ul>
<p><img src="../../../../gardens/network/originals/comnet.fall.2021.cse.cnu.ac.kr/images/08_330231c4fe894416a9f1b47b0f6a039d/image2.png" alt="%E1%84%8B%E1%85%B5%E1%84%85%E1%85%A9%E1%86%AB08%20-%20Transport%20Layer%20&amp;%20UDP%20330231c4fe894416a9f1b47b0f6a039d/image2.png"/></p>
<ul>
<li>이것을 위해선 <strong>Port address</strong>가 있어 특정 port address로 데이터를 전송해 올바른 프로세스로 찾아가게 한다</li>
<li>즉, <strong>Process-to-Process Delivery</strong>를 위한 계층이 <strong>Transport layer</strong>인 셈</li>
<li>종류로는 <strong>UDP</strong>, <strong>TCP</strong>, <strong>SCTP</strong>가 있고 이중에 <strong>TCP</strong>가 제일 유명하지만 <strong>UDP</strong>나 <strong>SCTP</strong>를 사용할 수도 있댄다</li>
</ul>
<h2 id="process-to-process-delivery">Process-to-Process Delivery<a aria-hidden="true" tabindex="-1" href="#process-to-process-delivery" class="internal"> §</a></h2>
<ul>
<li>일단 용어정리를 좀 하면</li>
<li>IP주소가 A인 Host의 port a가 IP주소가 P인 Host의 port j로 보내면</li>
<li><strong>Local host</strong>는 A이고 <strong>Remote host</strong>는 P이다 - <strong>Local host</strong>와 <strong>Remote host</strong>에서 host는 IP를 뜻하는 말임</li>
<li><strong>Local process</strong>는 a이고 <strong>Remote process</strong>는 j이다 - <strong>Local process</strong>와 <strong>Remote process</strong>에서 process는 port를 뜻하는 거더라</li>
</ul>
<h3 id="client-server-model">Client-server model<a aria-hidden="true" tabindex="-1" href="#client-server-model" class="internal"> §</a></h3>
<ul>
<li>데이터를 받는 상대방의 port는 어떻게 알아내냐는 궁금증에 생기게 되는데</li>
<li>상대방의 port를 알아내는 방법으로 <strong>Client-server model</strong>을 사용하게 된다</li>
<li>일단 <strong>Client</strong>는 통신을 시작하는 쪽, 먼저 요청하는 놈 - Initiator이라고 생각하면 된다
<ul>
<li>일반적으로는 서비스를 요청하는놈이라고 생각해도 되지만 특별한 경우에는 서비스를 제공해주는 놈이 통신을 시작하기도 하더라</li>
</ul>
</li>
<li>그리고 <strong>Server</strong>는 Client의 통신 / 요청에 대해 응답하는놈 - Responser이 된다</li>
<li>이때 <strong>Client-server model</strong>에서는 Server의 port를 이미 잘 알려진 값인 <strong>well-known port</strong>를 사용한다
<ul>
<li>뭐 알다시피 http의 경우에는 80을 사용하쥬</li>
</ul>
</li>
<li>즉, Server가 well known port를 사용하기 때문에 통신을 시작하는 쪽인 Client는 Server의 port번호를 알 수 밖에 없다</li>
<li>따라서 Client가 well known port로 보내게 되면 Server는 그것을 받고 Client의 port번호를 알아낼 수 있기 때문에 정상적인 응답을 보내줄 수 있는 것</li>
</ul>
<p><img src="../../../../gardens/network/originals/comnet.fall.2021.cse.cnu.ac.kr/images/08_330231c4fe894416a9f1b47b0f6a039d/image3.png" alt="%E1%84%8B%E1%85%B5%E1%84%85%E1%85%A9%E1%86%AB08%20-%20Transport%20Layer%20&amp;%20UDP%20330231c4fe894416a9f1b47b0f6a039d/image3.png"/></p>
<ul>
<li>위에가 예신데</li>
<li>보다시피 Daytime 이라는 프로토콜에서는 Server가 13이라는 Well-known port를 이용하고</li>
<li>클라이언트는 이걸 알기 때문에 자신의 임시 port인 52000을 실어 보내면 Server가 알게 되는 것</li>
<li>클라이언트의 port는 임시적인거고 프로세스가 죽으면 다른 프로세스에게로 할당될 수 있다 - <strong>Ephemeral local port number</strong>라고 하더라</li>
<li>그리고 MAC, IP주소와 마찬가지로 port번호도 다른 계층에서 알 수 없는 것은 아니다 - port번호가 패킷에 담기는 자료구조를 모르는 것
<ul>
<li>일례로 IP주소가 Transport계층을 넘어 Application까지 넘어가는 경우가 있고 port라는 것도 Transport의 상위계층에서 넘겨주는 값이다</li>
</ul>
</li>
</ul>
<h2 id="address-system">Address System<a aria-hidden="true" tabindex="-1" href="#address-system" class="internal"> §</a></h2>
<h3 id="port-number">Port Number<a aria-hidden="true" tabindex="-1" href="#port-number" class="internal"> §</a></h3>
<p><img src="../../../../gardens/network/originals/comnet.fall.2021.cse.cnu.ac.kr/images/08_330231c4fe894416a9f1b47b0f6a039d/image4.png" alt="%E1%84%8B%E1%85%B5%E1%84%85%E1%85%A9%E1%86%AB08%20-%20Transport%20Layer%20&amp;%20UDP%20330231c4fe894416a9f1b47b0f6a039d/image4.png"/></p>
<ul>
<li><strong>IANA</strong>라는 기관에서 port번호를 정하는 규칙을 만들어놨댄다</li>
<li>보면 <strong>0~1024</strong>까지는 well-known</li>
<li><strong>1024~49151</strong>까지는 <strong>Registered</strong>라고 해서 나중에 쓸 목적으로 비워둔 곳</li>
<li><strong>49152~65535</strong>는 프로세스가 임시로 할당받게 되는 값이다</li>
</ul>
<h3 id="socket-address">Socket Address<a aria-hidden="true" tabindex="-1" href="#socket-address" class="internal"> §</a></h3>
<p><img src="../../../../gardens/network/originals/comnet.fall.2021.cse.cnu.ac.kr/images/08_330231c4fe894416a9f1b47b0f6a039d/image5.png" alt="%E1%84%8B%E1%85%B5%E1%84%85%E1%85%A9%E1%86%AB08%20-%20Transport%20Layer%20&amp;%20UDP%20330231c4fe894416a9f1b47b0f6a039d/image5.png"/></p>
<ul>
<li><strong>IP</strong>와 <strong>Port</strong>를 합친 주소를 <strong>Socket Address</strong>라고 한다</li>
<li>얘는 Application Layer에서 사용하는 주소 중 하나로 다른 계층의 주소를 사용할 수 있다는 것을 보여주는 또 다른 사례인 것</li>
</ul>
<h3 id="multiplexer-demultiplexer">Multiplexer, Demultiplexer<a aria-hidden="true" tabindex="-1" href="#multiplexer-demultiplexer" class="internal"> §</a></h3>
<p><img src="../../../../gardens/network/originals/comnet.fall.2021.cse.cnu.ac.kr/images/08_330231c4fe894416a9f1b47b0f6a039d/image6.png" alt="%E1%84%8B%E1%85%B5%E1%84%85%E1%85%A9%E1%86%AB08%20-%20Transport%20Layer%20&amp;%20UDP%20330231c4fe894416a9f1b47b0f6a039d/image6.png"/></p>
<ul>
<li>Process들에게서 전달받은 데이터를 취합하여 IP로 보내는 <strong>Multiplexer</strong>와</li>
<li>받은 데이터를 다시 나눠 각각의 Process들에게 뿌려주는 <strong>Demultiplexer</strong>가 있댄다</li>
</ul>
<h2 id="connection-reliable">Connection, Reliable<a aria-hidden="true" tabindex="-1" href="#connection-reliable" class="internal"> §</a></h2>
<h3 id="connectionless-vs-connection-oriented">Connectionless vs Connection-oriented<a aria-hidden="true" tabindex="-1" href="#connectionless-vs-connection-oriented" class="internal"> §</a></h3>
<ul>
<li>일단 앞에서 배운것처럼 <strong>Connection</strong>이라는 것은 데이터가 보내진 순서대로 도착하느냐 아니냐에 따라 나눠진다</li>
<li><strong>Connectionless</strong>는 순서가 바뀌든 중간에 유실되든 상관 없이 전송되는 것을 의미 - <strong>UDP</strong>가 여기에 해당한다</li>
<li>그리고 <strong>Connection-Oriented</strong>는 순서가 바뀌면 안되고 보낸 순서대로 도착해야되는 것 - <strong>TCP</strong>과 <strong>SCTP</strong>가 여기에 해당한다</li>
<li><strong>Connection-Oriented</strong>는 다음과 같이 작동함
<ol>
<li>일단 한놈이 Connection-Oriented하게 통신하자고 메세지를 보냄</li>
<li>그럼 그걸 받은놈은 버퍼를 준비하고 준비됐다고 답장을 보냄</li>
<li>통신시작하는쪽은 버퍼를 준비하며 알았다고 메세지를 보낸 뒤 데이터들을 보낼 순서대로 <strong>Numbering</strong>을 한다 - 순번을 다 적어놓는 셈</li>
<li>그리고 이걸 보내게 되면</li>
<li>받는쪽은 그걸 받아서 바로 Application Layer로 올리는게 아니고 일단 버퍼에 저장해둔다</li>
<li>그리고 데이터가 다 도착하면 그제서야 버퍼에 있는 데이터들의 순번을 보고 순서대로 Application Layer로 올려보내게 됨</li>
</ol>
</li>
<li>그렇다고 Connectionless라고 해서 순서를 아예 무시하는건 아닐 수도 있다 - Transport계층에게 그걸 맡기지 않는다는 거지 Application Layer에서 자체적으로 하는 경우도 있다더라</li>
</ul>
<h3 id="reliable-vs-unreliable">Reliable vs Unreliable<a aria-hidden="true" tabindex="-1" href="#reliable-vs-unreliable" class="internal"> §</a></h3>
<ul>
<li>일단 <strong>Reliable</strong>은 다음과 같은 에러가 없을때를 지칭하는 말이다
<ul>
<li><strong>Flow Control Error</strong> : 수신속도보다 송신속도가 더 빨라 Overwrite되는 경우</li>
<li><strong>Physical Error</strong> : 노이즈가 끼는 경우</li>
<li><strong>TCP</strong>, <strong>SCTP</strong>가 여기 해당함</li>
</ul>
</li>
<li>당연히 <strong>Unreliable</strong>은 이러한 에러가 있을 수도 있을 때를 말하는 거겠지
<ul>
<li><strong>UDP</strong>가 여기 해당함</li>
</ul>
</li>
<li>이것도 마찬가지로 Unreliable하다고 에러를 무시할 수도 있지만 그렇지 않을 수도 있다 - Application Layer에서 자체적으로 하는 경우도 있다 이거야</li>
<li>근데 Data link layer에서 이런 것들을 해주는데 왜 Transport 계층에서도 하는지 의문이 들 수 있는데</li>
<li>그건 아래 예시 보면 알 수 있음</li>
</ul>
<p><img src="../../../../gardens/network/originals/comnet.fall.2021.cse.cnu.ac.kr/images/08_330231c4fe894416a9f1b47b0f6a039d/image7.png" alt="%E1%84%8B%E1%85%B5%E1%84%85%E1%85%A9%E1%86%AB08%20-%20Transport%20Layer%20&amp;%20UDP%20330231c4fe894416a9f1b47b0f6a039d/image7.png"/></p>
<ul>
<li>보면 일단 분홍색 선으로 표시된 부분에는 Data link layer의 활약으로 에러가 없음</li>
<li>근데 위 그림에서 검은색 선으로 표시된 부분에서 에러가 날 수 있다</li>
<li>이건 왜냐하면 Router에서는 Incoming queue에서 Outgoing queue로 패킷을 옮겨야 하는데 이 queue의 크기가 무한한게 아니기 때문에 패킷이 많이 쌓여 공간이 부족하게 되어 에러가 남</li>
<li>이런걸 <strong>Queue overflow by congestion</strong>, <strong>False Flow Control</strong>이라고 하더라</li>
</ul>
<h2 id="udp">UDP<a aria-hidden="true" tabindex="-1" href="#udp" class="internal"> §</a></h2>
<ul>
<li><strong>User Datagram Protocol(UDP)</strong> 는</li>
<li>IP에 Port를 추가해 Process-to-Process 기능만 덧붙이고 나머지는 아무것도 하지 않는 프로토콜이다</li>
<li>당연히 Process로 연결해주는것 외에는 아무것도 하지 않기 때문에 Connectionless, Unreliable하다</li>
</ul>
<p><img src="../../../../gardens/network/originals/comnet.fall.2021.cse.cnu.ac.kr/images/08_330231c4fe894416a9f1b47b0f6a039d/image8.png" alt="%E1%84%8B%E1%85%B5%E1%84%85%E1%85%A9%E1%86%AB08%20-%20Transport%20Layer%20&amp;%20UDP%20330231c4fe894416a9f1b47b0f6a039d/image8.png"/></p>
<ul>
<li>UDP에서 사용하는 Well-known port 들임 - 참고만 혀</li>
</ul>
<p><img src="../../../../gardens/network/originals/comnet.fall.2021.cse.cnu.ac.kr/images/08_330231c4fe894416a9f1b47b0f6a039d/image9.png" alt="%E1%84%8B%E1%85%B5%E1%84%85%E1%85%A9%E1%86%AB08%20-%20Transport%20Layer%20&amp;%20UDP%20330231c4fe894416a9f1b47b0f6a039d/image9.png"/></p>
<ul>
<li>헤더의 구조는 위와 같다 - 단순</li>
<li>근데 <strong>Total length</strong>는 굳이 필요 없다 - IP헤더의 total length부분에서 hlen을 빼면 구할 수 있기 때문에</li>
<li>하지만 Transport 계층의 정보를 얻기 위해 IP계층에 물어보는 것은 약간 자존심상해서 만들어놨댄다</li>
</ul>
<h3 id="구조">구조<a aria-hidden="true" tabindex="-1" href="#구조" class="internal"> §</a></h3>
<p><img src="../../../../gardens/network/originals/comnet.fall.2021.cse.cnu.ac.kr/images/08_330231c4fe894416a9f1b47b0f6a039d/image10.png" alt="%E1%84%8B%E1%85%B5%E1%84%85%E1%85%A9%E1%86%AB08%20-%20Transport%20Layer%20&amp;%20UDP%20330231c4fe894416a9f1b47b0f6a039d/image10.png"/></p>
<ul>
<li>위 그림처럼 port 하나가 열리면 UDP에서는 Application과 데이터를 주고받을 <strong>Incoming queue</strong>와 <strong>Outgoing queue</strong>가 열린다</li>
<li>근데 이때 서버에서는 여러 Client로부터 데이터를 받기 때문에 Incoming queue를 하나만 사용하면 데이터가 어디에서 온 건지 알수 없게 되는데
<ul>
<li>왜 알수 없냐면 Application layer로 올라갈때는 Header가 제거되기 때문</li>
</ul>
</li>
<li>그래서 UDP에서 Application으로 올릴때 Header를 뗀 Data뿐 아니라 <strong>Socket Address</strong>도 같이 주어 이놈이 어디에서 와서 어디로 가야되는지 Application layer로 보내준다</li>
</ul></article></div><div class="right sidebar"><div class="graph "><h3>Graph View</h3><div class="graph-outer"><div id="graph-container" data-cfg="{&quot;drag&quot;:true,&quot;zoom&quot;:true,&quot;depth&quot;:1,&quot;scale&quot;:1.1,&quot;repelForce&quot;:0.5,&quot;centerForce&quot;:0.3,&quot;linkDistance&quot;:30,&quot;fontSize&quot;:0.6,&quot;opacityScale&quot;:1,&quot;showTags&quot;:true,&quot;removeTags&quot;:[]}"></div><svg version="1.1" id="global-graph-icon" xmlns="http://www.w3.org/2000/svg" xmlnsXlink="http://www.w3.org/1999/xlink" x="0px" y="0px" viewBox="0 0 55 55" fill="currentColor" xmlSpace="preserve"><path d="M49,0c-3.309,0-6,2.691-6,6c0,1.035,0.263,2.009,0.726,2.86l-9.829,9.829C32.542,17.634,30.846,17,29,17
	s-3.542,0.634-4.898,1.688l-7.669-7.669C16.785,10.424,17,9.74,17,9c0-2.206-1.794-4-4-4S9,6.794,9,9s1.794,4,4,4
	c0.74,0,1.424-0.215,2.019-0.567l7.669,7.669C21.634,21.458,21,23.154,21,25s0.634,3.542,1.688,4.897L10.024,42.562
	C8.958,41.595,7.549,41,6,41c-3.309,0-6,2.691-6,6s2.691,6,6,6s6-2.691,6-6c0-1.035-0.263-2.009-0.726-2.86l12.829-12.829
	c1.106,0.86,2.44,1.436,3.898,1.619v10.16c-2.833,0.478-5,2.942-5,5.91c0,3.309,2.691,6,6,6s6-2.691,6-6c0-2.967-2.167-5.431-5-5.91
	v-10.16c1.458-0.183,2.792-0.759,3.898-1.619l7.669,7.669C41.215,39.576,41,40.26,41,41c0,2.206,1.794,4,4,4s4-1.794,4-4
	s-1.794-4-4-4c-0.74,0-1.424,0.215-2.019,0.567l-7.669-7.669C36.366,28.542,37,26.846,37,25s-0.634-3.542-1.688-4.897l9.665-9.665
	C46.042,11.405,47.451,12,49,12c3.309,0,6-2.691,6-6S52.309,0,49,0z M11,9c0-1.103,0.897-2,2-2s2,0.897,2,2s-0.897,2-2,2
	S11,10.103,11,9z M6,51c-2.206,0-4-1.794-4-4s1.794-4,4-4s4,1.794,4,4S8.206,51,6,51z M33,49c0,2.206-1.794,4-4,4s-4-1.794-4-4
	s1.794-4,4-4S33,46.794,33,49z M29,31c-3.309,0-6-2.691-6-6s2.691-6,6-6s6,2.691,6,6S32.309,31,29,31z M47,41c0,1.103-0.897,2-2,2
	s-2-0.897-2-2s0.897-2,2-2S47,39.897,47,41z M49,10c-2.206,0-4-1.794-4-4s1.794-4,4-4s4,1.794,4,4S51.206,10,49,10z"></path></svg></div><div id="global-graph-outer"><div id="global-graph-container" data-cfg="{&quot;drag&quot;:true,&quot;zoom&quot;:true,&quot;depth&quot;:-1,&quot;scale&quot;:0.9,&quot;repelForce&quot;:0.5,&quot;centerForce&quot;:0.3,&quot;linkDistance&quot;:30,&quot;fontSize&quot;:0.6,&quot;opacityScale&quot;:1,&quot;showTags&quot;:true,&quot;removeTags&quot;:[]}"></div></div></div><div class="toc desktop-only"><button type="button" id="toc"><h3>Table of Contents</h3><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="fold"><polyline points="6 9 12 15 18 9"></polyline></svg></button><div id="toc-content"><ul class="overflow"><li class="depth-0"><a href="#transport-layer" data-for="transport-layer">Transport Layer</a></li><li class="depth-0"><a href="#process-to-process-delivery" data-for="process-to-process-delivery">Process-to-Process Delivery</a></li><li class="depth-1"><a href="#client-server-model" data-for="client-server-model">Client-server model</a></li><li class="depth-0"><a href="#address-system" data-for="address-system">Address System</a></li><li class="depth-1"><a href="#port-number" data-for="port-number">Port Number</a></li><li class="depth-1"><a href="#socket-address" data-for="socket-address">Socket Address</a></li><li class="depth-1"><a href="#multiplexer-demultiplexer" data-for="multiplexer-demultiplexer">Multiplexer, Demultiplexer</a></li><li class="depth-0"><a href="#connection-reliable" data-for="connection-reliable">Connection, Reliable</a></li><li class="depth-1"><a href="#connectionless-vs-connection-oriented" data-for="connectionless-vs-connection-oriented">Connectionless vs Connection-oriented</a></li><li class="depth-1"><a href="#reliable-vs-unreliable" data-for="reliable-vs-unreliable">Reliable vs Unreliable</a></li><li class="depth-0"><a href="#udp" data-for="udp">UDP</a></li><li class="depth-1"><a href="#구조" data-for="구조">구조</a></li></ul></div></div><div class="backlinks "><h3>Backlinks</h3><ul class="overflow"><li><a href="../../../../gardens/network/originals/comnet.fall.2021.cse.cnu.ac.kr/(충남대)-컴퓨터-네트워크-강의록" class="internal">(충남대) 컴퓨터 네트워크 강의록</a></li></ul></div></div></div><footer class><hr/><p>Created with <a href="https://quartz.jzhao.xyz/">Quartz v4.1.0</a>, © 2024</p><ul><li><a href="https://github.com/haeramkeem">GitHub</a></li><li><a href="www.linkedin.com/in/haeram-kim-277404220">LinkedIn</a></li><li><a href="mailto:haeram.kim1@gmail.com">Email</a></li></ul></footer></div></body><script type="application/javascript">// quartz/components/scripts/quartz/components/scripts/callout.inline.ts
function toggleCallout() {
  const outerBlock = this.parentElement;
  outerBlock.classList.toggle(`is-collapsed`);
  const collapsed = outerBlock.classList.contains(`is-collapsed`);
  const height = collapsed ? this.scrollHeight : outerBlock.scrollHeight;
  outerBlock.style.maxHeight = height + `px`;
  let current = outerBlock;
  let parent = outerBlock.parentElement;
  while (parent) {
    if (!parent.classList.contains(`callout`)) {
      return;
    }
    const collapsed2 = parent.classList.contains(`is-collapsed`);
    const height2 = collapsed2 ? parent.scrollHeight : parent.scrollHeight + current.scrollHeight;
    parent.style.maxHeight = height2 + `px`;
    current = parent;
    parent = parent.parentElement;
  }
}
function setupCallout() {
  const collapsible = document.getElementsByClassName(
    `callout is-collapsible`
  );
  for (const div of collapsible) {
    const title = div.firstElementChild;
    if (title) {
      title.removeEventListener(`click`, toggleCallout);
      title.addEventListener(`click`, toggleCallout);
      const collapsed = div.classList.contains(`is-collapsed`);
      const height = collapsed ? title.scrollHeight : div.scrollHeight;
      div.style.maxHeight = height + `px`;
    }
  }
}
document.addEventListener(`nav`, setupCallout);
window.addEventListener(`resize`, setupCallout);
</script><script type="module">
          import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.esm.min.mjs';
          const darkMode = document.documentElement.getAttribute('saved-theme') === 'dark'
          mermaid.initialize({
            startOnLoad: false,
            securityLevel: 'loose',
            theme: darkMode ? 'dark' : 'default'
          });
          document.addEventListener('nav', async () => {
            await mermaid.run({
              querySelector: '.mermaid'
            })
          });
          </script><script src="https://cdn.jsdelivr.net/npm/katex@0.16.7/dist/contrib/copy-tex.min.js" type="application/javascript"></script><script src="https://www.googletagmanager.com/gtag/js?id=G-N68CCP1QHG" type="application/javascript"></script><script src="../../../../postscript.js" type="module"></script></html>