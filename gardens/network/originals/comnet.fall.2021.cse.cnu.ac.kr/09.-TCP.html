<!DOCTYPE html>
<html><head><title>09. TCP</title><meta charSet="utf-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:title" content="09. TCP"/><meta property="og:description" content="충남대학교 컴퓨터공학과 김상하 교수님의 &amp;quot;컴퓨터 네트워크&amp;quot; 강의를 필기한 내용입니다. 다소 잘못된 내용과 구어적 표현 이 포함되어 있을 수 있습니다. TCP Services § Process-to-Process Communication § 일단 뭐 Process-to-Process Deilivery를 지원하기 위한 port number를 사용하니까 Client-Server Model을 사용한다 TCP에서 사용하는 well know port는 80은 http, 53은 DNS라는것 정도는 알고 있어라 Stream Delivery Service § 그리고 TCP에서는 Stream Delivery Service라는 것을 사용하는데 이게 뭐냐면 UDP같은 경우에는 Application Layer로부터 내려온 데이터를 하나의 데이터그램으로 만들어서 보낸다 이걸 내용적으로 의미있는 단위로 데이터그램을 전송한다하고 표현함 하지만 TCP는 이렇게 하지 않고 Application Layer로부터 내려온 데이터들을 버퍼에 모았다가 버퍼가 일정 수준 쌓이면 그때 보내게 된다 즉, UDP처럼 내용으로 구분해서 전송하는게 아니고 버퍼에 쌓인 데이터의 크기로 구분해서 보내게 되는 것 따라서 여러개의 데이터가 하나의 단위로 묶여서 보내질 수도 있고 Application Layer에서 내려온 데이터가 많은 경우에는 얘네들을 잘라서 보내기도 하고 이런식이더라 뭐 예를들어서 Application Layer에서 두 프로세스가 각각 5byte, 1500byte의 데이터를 줬다면 UCP의 경우에는 5byte, 1500byte로 전송을 하겠지만 TCP의 경우에는 1000byte, 505byte로 전송을 한다 이말임 이렇게 하는 것의 장점은 항상 비슷한 크기의 많은 데이터를 송수신하게 된다는 것이다 이게 왜 장점이 되냐면 데이터를 보낼때는 그것만 보내는게 아니고 여러 계층의 헤더를 붙여서 보내기 때문에 한번 보낼때 최대한 많은 데이터를 보내는게 효율적이기 때문 만일 Header를 다 합쳤을때 100바이트라면 UDP같은 경우에는 메시지가 5byte와 800byte두개가 들어오면 105byte, 900 byte 두번이 전송되지만 TCP같은 경우에는 얘네들을 합쳐서 보내기 때문에 905byte 한번만 전송하게 된다 그리고 알아두어야할 게 Port별로 버퍼가 생성된다 - 어차피 Port들을 Multiplexing과 Demultiplexing을 다 하기 때문에 Port가 합쳐지는 것에 대한 생각은 하지 말고 Process-to-Process의 관점에서만 생각하면 된다 그리고 TCP는 Reliable한 전송을 보장하기 때문에 송수신 속도 차이에 따른 Flow error를 방지하고자 송수신측 모두 버퍼를 둔다 그래서 위 그림처럼 송수신측 모두 넉넉하게 버퍼를 준비해놓고 Sending process가 송신 버퍼에 쓰면 그걸 순차적으로 보내게 되고 받는쪽에서도 데이터를 받아 수신 버퍼에 쓰면 그걸 Receiving process가 가져가게 되는 구조 버퍼가 없다면 아직 보내지도 않았는데 Sending process가 데이터를 줘 Overwrite된다거나 수신측에서도 Receiving Process가 가져가지도 않았는데 데이터가 수신되어 Overwrite되는 일이 벌어지게 되는 것 위 내용을 종합해보면 위와 같은 그림으로 표현할 수 있다 송수신 속도 차이에 따른 Flow error를 막기 위해 송수신 버퍼가 존재하고 Message별로 데이터를 보내는게 아닌 일정 수준 크기로 데이터들을 뭉쳐 Segment라는 단위로 보내게 된다 Full-duplex Communication § Full-duplex communication은 TCP가 양방향 통신을 지원한다는 의미이다 Connection Oriented Service § 이전에 배운거처럼 TCP는 orderly delivery를 지원한다 그래서 일단 Connect Phase를 거치고 - 전송을 이제 시작할 것이니 송수신측 모두 버퍼를 준비해라 + 송신할 데이터에 numbering을 하여 순서대로 도착하지 않아도 수신측에서 number를 보고 정렬하여 상위계층으로 보낼 수 있도록 그리고 데이터를 송수신한 후 Disconnect Phase를 거쳐 준비한 버퍼를 삭제해 다른 통신에서도 사용할 수 있도록 함 Reliable Service § TCP는 Reliable Communication을 지원한다 - Flow &amp;amp; Error Control을 하여 이러한 문제가 생기지 않도록 함 Numbering System of TCP § 일단 TCP에서 Numbering 하는 데에 중요한 것은 번호가 Segment별로 붙는게 아니라는 점이다 이게 무슨말이냐면 위에서 TCP에서의 전송 단위가 Segment라고 했는데 첫번째 보내는 Segment는 0번, 두번째 보내는 Segment는 1번 이런식으로 숫자를 붙이지 않는다는 것 이다 그럼 뭐 어떻게 하느냐 Byte 별로 번호를 붙이는 시스템을 이용한다 이걸 위해 두개의 필드가 헤더에 들어감 - Sequence Number하고 Acknowledge Number 얘네들은 Data link layer에서의 SEQ랑 ACK 번호랑 동일한 기능을 하는데 대신 번호를 매기는 단위가 Frame(Segment)가 아닌 바이트인 차이점이 있다 따라서 Sequence Number는 데이터의 첫번째 바이트에 붙는 번호이다 여기서 주의할 점은 Sequence Number는 0번부터 시작하지 않을 수도 있다는 점 - 0 ~ 2^31 - 1의 숫자 중 하나를 랜덤으로 골라 번호를 붙이게 된다 그리고 첫번째를 이렇게 붙이고 그 다음 바이트부터 1씩 증가하다가 2^31 - 1을 넘어가면 다시 0번으로 돌아와서 번호가 붙는 셈 당연히 Numbering이 이런식으로 된다는 거지 실제 Segment에는 첫번째 바이트의 Number인 Sequence number밖에 저장되지 않는다 그리고 Acknowledge Number는 Data link layer에서와 동일하게 이전까지는 잘 받았고 이제 이거를 보내달라는 의미가 된다 뒤에서 실제 예시를 보면 으케되는지 더 잘 알 수 있을거임 이런식으로 Byte-oriented Numbering System을 이용하기 때문에 Flow control과 Error control도 byte-oriented하게 이루어진다 뒤에 가서 어떻게 하는지 알려준댄다 Segment § 이게 Segment의 Header구조이다 위에서 언급 안한것만 살펴보면 HLEN은 헤더의 크기이다 - 근데 이것도 IP헤더랑 비슷하게 4-byte단위로 표시함 - 즉, HLEN이 1이면 헤더가 4바이트라는 거고 HLEN의 최대 크기가 15이기 때문에 최대 헤더의 크기는 60byte인데 Option and Padding을 제외한 필수적인 부분이 20byte이기 때문에 Option and Padding부분은 40byte 이내로 상황에 맞게 들어가게 된다 Reserved는 나중을 위해 비워둔 부분이고 주황색으로 표시된 Control이라고 불리는 Flag들은 Connection을 위해 있는 부분 Window Size는 Flow Control을 위해 존재하는 부분 Urgent Pointer는 뒤에서 배운댄다 Checksum은 Error control을 위해 존재하는 부분이랜다 A TCP Connection § Traffic이 막힌다던지 아니면 에러가 있어서 재전송을 하게 되는 등 전송의 순서가 바뀌게 되는 경우는 많다 그럼에도 불구하고 순서대로 데이터를 합치기 위해 Connection이 반드시 필요하게 됨 Connect → Data Transfer → Disconnect 순서로 수행된다 Connection Establishment Phase - Three way handshake § 일단 Connection단계에서는 Three way handshake라는 방식으로 Connection Establish를 하게 된다 이게뭐냐면 일단 Client가 통신하자고 Server에게 보내면 Server는 ㅇㅋ라고 하고 마지막으로 Client가 한번 더 확인차 ㅇㅋ라고 보내는 것 저렇게 세번 통신을 하여 Connection이 이루어지므로 Three way handshake인 것 위 그림 두개를 같이 봐야 한다 State Diagram을 볼 때는 점선 화살표가 Server, 실선 화살표가 Client인 것을 기억혀 그리고 edge에 붙어있는 라벨을 읽을 때 A/B이면 내가 지금 A를 했거나 A를 받은거고 그 다음에 B를 했다는 식으로 이해하면 됨 보면 Client가 Active open을 하고 Server한테 첫번째 악수를 날린다 Active open인 이유는 Client는 통신을 시작하는 주체이기 때문 - 적극적이다! 첫번째 악수를 날릴 때는 Control Flag의 SYN부분을 1로 만들어서 보낸다 그래서 저기 State Diagram에서 보면 Client는 Active open/SYN을 한 후에SYN-SENT상태에 진입하게 된다 그러면 Server는 Passive open을 하고 기다리다가 SYN을 받으면 Client에게 두번째 악수를 날린다 Passive open인 이유는 당연히 Server는 Client가 통신을 시작해야만 시작할 수 있으므로 수동적으로 통신을 열게 되는 것임 그리고 두번째 악수를 날릴 때는 Control Flag의 SYN부분과 ACK부분을 1로 만들어서 보낸다 그래서 State Diagram에서도 Server는 일단 **Passive open/-**이므로 수동적 통신 개시를 한 후에 LISTEN상태에서 기다리고 있다가 SYN/SYN + ACK을 한 후에 SYN-RCVD상태에 들어가게 된다 마지막으로 Client가 SYN + ACK를 받으면 세번째 악수를 날리며 Connection이 Establish된다 세번째 악수에서는 Client가 ACK하나만 올려서 보낸다 그럼 Server쪽에서는 ACK를 받았으므로 Connection establish를 하게 된다 그래서 Client쪽의 State Diagram을 보면 SYN + ACK/ACK을 하고 ESTABLISH상태로 가고 Server쪽의 State Diagram을 봐도 **ACK/-**를 하고 ESTABLISH상태로 가게 된다 그리고 여기서 Sequence Number하고 Acknowledge Number를 좀 유심히 봐야 하는데 첫번째 악수에서는 Client가 8000번이라는 난수를 보냄 - 처음으로 보낼때는 SEQ 에 그냥 난수를 하나 보내게 된다 두번째 악수에서는 Server가 SEQ 15000에 ACK로 8001번을 보내는 것을 알 수 있다 15000은 당연히 처음 보내는 것이기 때문에 난수이고 ACK가 8001이 되는 이유는 처음에 Client가 보낸 SEQ가 8000번이었으므로 이것을 잘 받았고 8001번을 나는 원한다는 뜻이 되는 거임 즉, ACK로 n을 받았으면 n - 1까지는 잘 받았고 이제 n을 보내주세요 라는 의미로 이해하면 된다 그리고 세번째 악수를 보면 Client가 여전히 8000을 보내고 ACK는 15001을 보낸다 뭐 ACK가 15001인 이유는 Server가 SEQ15000를 보냈기 때문이고 SEQ가 8000인 이유는 데이터를 보내기 위한 Segment가 아니기 때문이다 즉, 상대방의 ACK에 부응하여 그에 맞는 데이터를 보낼때는 상대방이 준 ACK를 SEQ에 넣어 데이터도 그에 맞는 것을 주지만 상대방에게 데이터를 보내는게 아닐때에는 SEQ로 ACK - 1을 주게 되는거 같음 그리고 ACK도 그냥 기계적으로 생각하면 편하다 - 상대방이 준 Segment를 잘 받았으면 그냥 그 다음거를 받기 원하는 거임 그리고 Control Flag에 대해서도 좀 정리를 해보면 SYN은 Connection을 하자는 의미인 거고 ACK는 방금 보낸 것을 잘 받았다는 의미인거다 따라서 첫번째 악수에는 Connection을 할건데 이전에 상대방이 보낸 것은 없으니까 SYN하나만 올라가있게 되는 것이고 두번째 악수는 Connection을 할거고 이전에 보낸 것을 잘 받았으니까 SYN과 ACK다 올라가 있는 것이다 그리고 세번째 악수는 Connection하자는 답변을 받았으므로 굳이 SYN을 올리지 않고 그냥 방금 니가 보낸거 잘 받았소 의 느낌으로 ACK하나만 올리게 되는 것 Data Transfer § 위의 예시에서 먼저 SEQ와 ACK를 보면 이제 데이터를 보낼꺼니까 상대방이 준 ACK를 반영해 SEQ에 8001을 넣어 데이터를 보내게 된다 그리고 방금 상대방이 준 것을 잘 받았고 이제 이걸 원한다는 의미로 ACK를 15001로 설정하는 것 여기서 데이터를 보내는데 ACK도 같이 보내는 이유는 TCP는 Full-duplex communication을 지원하므로 이런식으로 piggybacking을 할 수 있다는 것을 보여주기 위한 것 이다 즉, 데이터를 보냄과 동시에 ACK도 같이 보내 상대방도 ACK에 맞는 데이터를 보낼 수 있고 이런식으로 양방향 통신이 이루어지는 셈 - 이게 piggybacking인데 기억나시쥬? 위의 통신에서 두세번째를 보면 알 수 있다 - 두번째에서 방금 9000번까지 보냈으니까 이제 입벌려9001들어간다 느낌으로 SEQ 9001을 설정하고, 데이터와 함께 ACK 15001을 보내면 세번째에서 상대방은 그에 맞게 SEQ를 15001로 하여 자신도 데이터를 보내고 두번째에서 줬던 데이터를 잘 받았고 이제 10001을 원한다는 의미로 ACK를 같이 보내게 되는 것 마지막으로 네번째에서는 더 이상 보낼게 없으니까 SEQ는 그냥 마지막에 보낸 10000으로 하고 방금 보낸 데이터 잘 받았고 이제 17001을 원하고 있다는 것을 피력하기 위해 ACK를 17001로 설정해서 보내게 되는 것 그리고 Control Flag부분을 보면 상대방이 보낸 것에 대한 ACK가 Segment에 포함되어 있으므로 ACK FLAG를 올리게 된다 그리고 중요한게 저 PSH FLAG인데 이건 뭐냐면 TCP는 기본적으로 버퍼링을 해 버퍼에 일정수준의 바이트가 차기 전까지는 보내지 않고 받는쪽에서도 동일하게 어느정도 모이기 전까지는 Application layer로 올리지 않는다 받는쪽에서도 이렇게 기다리는 이유는 일단 Segment를 다 받고 정렬을 해서 올리기 위해서이기도 하고, 만일 데이터를 받을 Application이 바빠 지금 당장은 받지 못하는 경우에도 이렇게 기다렸다가 올리기 위해서이다 하지만 PSH FLAG가 올라가 있으면 기다리지 말고 바로 Application 으로 올리라는 의미를 가진다 보통 이것을 설정하는 것은 예를들어 채팅어플같은 실시간 통신이 중요할 때에는 기다리는 것이 곧 지연이기 때문에 이것을 막기 위해 바로 올려보내주세요 라고 하는 것이다 따라서 위의 예시에서는 첫 두 Segment에 PSH가 설정되어있으므로 쟤네들은 바로 Application으로 올라가게 된다 - 만약 이게 설정되어있지 않았더라면 첫번째는 버퍼에서 기다리고 두번째가 도착했을때 수신자의 판단 하에 Application으로 올릴 수 있는 것이다 위의 예시에서는 없지만 URG FLAG는 Urgent 즉, 긴급상황이 벌어진 것이다 이건 어떤 경우에 설정되냐면 예를들어서 큰 파일을 보내던 와중에 파일을 잘못보낸 것을 알고 이것을 취소하고자 할 때 사용한다 이런 상황이 생기면 TCP에서는 Special TCP Segment를 만들어 URG FLAG를 올리고 URG POINTER를 설정하여 데이터와 함께 보내게 된다 URG POINTER가 뭐냐면 위에 Segment Header구조 볼때 있던 필드인데 여기에 들어있는 값이 정상적인 데이터와 비정상적인 데이터를 구분하는 바이트 번호인 셈 즉, URG POINTER가 400이라고 되어 있으면 Segment의 데이터에서 400번째 바이트까지는 폐기해야되는 비정상적인 데이터이고, 그 이후에 나오는 바이트들은 정상적으로 수신해야 되는 데이터인 것 그래서 URG를 수신하게 되면 URG POINTER가 가르키는 곳까지 수신자는 폐기하게 된다 이렇게 하는 이유는 한번에 최대한 많은 데이터를 보내기 위함이다 - 문제가 생겼다고 문제가 있음을 알리는 Segment를 별도로 보내는게 아니고 문제가 있음을 알리면서 동시에 정상적인 데이터들도 보내고 싶으신거지 Connection Termination - Four-way Handshake(Half close) § Connection termination에서도 Establishment에서처럼 Three-way handshake로 할 수 있지만 요즘은 사용되지 않는댄다 그래서 요즘 사용하고 있는 방법은 Four-way Handshake(Half close) 라는 방법이다 그리고 위에서 언급한것처럼 Connection Termination단계에서 버퍼들을 반납하게 됨 위 그림이 통신 전반에 걸친 State Diagram인데 Established까지는 전부 배웠고 이제 그 아랫부분을 보면 된다 위와 같은 식으로 이루어짐 Client가 Active close를 하고 FIN FLAG을 올려서 Segment를 보냄 Establish때와 마찬가지로 항상 Client가 먼저 제안을 한다 뭐 FIN FLAG는 이름 그대로 이제 통신 그만하자 라는 뜻이다 State Diagram에서 봐도 Close를 하고 FIN을 보낸 뒤 FIN-WAIT-1상태로 들어간 것을 볼 수 있다 Server는 FIN을 받으면 알겠다고 ACK를 보내게 된다 State Diagram에서 보면 FIN을 받고 ACK를 날린 뒤 CLOSE-WAIT상태로 들어가게 된다 Client는 ACK를 받으면 아무것도 하지 않는다 State Diagram에서 보면 ACK를 받고 FIN-WAIT-2상태로 진입한걸 볼 수 있는데 이 단계가 뭐하는 거냐면 Client쪽은 데이터를 다 보냈어도 Server쪽은 Client가 요청한 데이터를 아직 덜 보냈을 수도 있기 때문에 Server가 마무리하는 단계가 되는 것이다 따라서 Client가 FIN-WAIT-2상태일때 Server는 못보낸 것들을 다 보내고 Client는 ACK를 날려 잘 받았다고 알려줌 Server는 마무리를 다 한 후에 FIN을 보낸다 State Diagram에서 보면 Close/FIN이라고 되어 있는데 이게 Close하는 동안 나머지 데이터를 전부 보내고 그 이후에 FIN을 보낸다는 것 FIN을 보내고 난 후에는 LAST-ACK상태로 들어가 ACK가 올때까지 기다린다 Client는 FIN을 받으면 ACK를 날리고 잠시 대기한다 State Diagram에서 보면 FIN/ACK후에 TIME-WAIT를 하는 것을 볼 수 있음 Server는 ACK를 받고 바로 Close로 들어간다 뭐 이제는 State diagram 설명안해도 되겠지 Client는 일정시간 기다린 후에 Close로 들어간다 Server는 바로 Close되는데 Client는 왜 일정시간 기다리는지 궁금하다면 대학원응안가 Flow Control § Window Size § 일단 TCP의 Flow Control에서 중요한 점은 Receiver의 요청에 의해 Sender의 버퍼 크기를 늘렸다 줄였다 한다는 것이다 이게 뭔소리냐면 만일 Receiver의 버퍼 용량이 5000이고 1000이 아직 Application으로 올라가지 못했다고 해보면 Receiver는 4000이상의 데이터를 받게 되면 버퍼가 터져나가게 된다 따라서 Receiver가 Sender한테 말하는 거임 - 4000이상 보내지 마라고 이때 Receiver가 사용할 수 있는 남은 버퍼의 크기를 rwnd라고 표현한다 또한 이러한 이유 말고도 다음 강의때 배울 cwnd라는 것도 있는데 이건 Congestion Window라고 네트워크의 혼잡도를 나타내는 것이다 - 네트워크가 혼잡하면 한번에 보내는 데이터의 양을 줄이라고 Sender에게 요청하는 것 이러한 일을 Segment Header에 있던 Window Size필드를 이용해 수행한다 Window Size필드의 값은 rwnd와 cwnd중 작은 값 으로 설정하여 Receiver가 Sender에게 요청하게 되는 것 - 두 값보다도 적은 사이즈로 보내야 정상적으로 수신할 수 있으므로 따라서 Sender의 버퍼를 보면 위와 같은 모양이 될 수 있다 일단 Window Size는 Receiver의 요청에 의해 9로 설정된 상태고 199까지는 전송했고 ACK까지 받은 애등 200~202까지는 전송했지만 ACK는 받지 못한 애들 그리고 203~208이 바로 전송할 수 있는 애들 209이후로는 Application한테 받았지만 Window size 제한때문에 보낼 수 없는 애들인 것이다 즉 위 그림에서 보이는것처럼 Window size가 정해져도 ACK를 받지 못한놈들 때문에 당장 보낼 수 있는 크기는 그것보다 작을 수도 있다는 것 ARQ § Flow Control이기 때문에 Data link layer에서의 Flow Control 방법을 사용하는데 Go-back-N ARQ가 아니라 Selective ARQ를 사용한댄다 기억안나면 06."/><meta property="og:image" content="https://mdg.haeramk.im/static/og-image.png"/><meta property="og:width" content="1200"/><meta property="og:height" content="675"/><link rel="icon" href="../../../../static/icon.png"/><meta name="description" content="충남대학교 컴퓨터공학과 김상하 교수님의 &amp;quot;컴퓨터 네트워크&amp;quot; 강의를 필기한 내용입니다. 다소 잘못된 내용과 구어적 표현 이 포함되어 있을 수 있습니다. TCP Services § Process-to-Process Communication § 일단 뭐 Process-to-Process Deilivery를 지원하기 위한 port number를 사용하니까 Client-Server Model을 사용한다 TCP에서 사용하는 well know port는 80은 http, 53은 DNS라는것 정도는 알고 있어라 Stream Delivery Service § 그리고 TCP에서는 Stream Delivery Service라는 것을 사용하는데 이게 뭐냐면 UDP같은 경우에는 Application Layer로부터 내려온 데이터를 하나의 데이터그램으로 만들어서 보낸다 이걸 내용적으로 의미있는 단위로 데이터그램을 전송한다하고 표현함 하지만 TCP는 이렇게 하지 않고 Application Layer로부터 내려온 데이터들을 버퍼에 모았다가 버퍼가 일정 수준 쌓이면 그때 보내게 된다 즉, UDP처럼 내용으로 구분해서 전송하는게 아니고 버퍼에 쌓인 데이터의 크기로 구분해서 보내게 되는 것 따라서 여러개의 데이터가 하나의 단위로 묶여서 보내질 수도 있고 Application Layer에서 내려온 데이터가 많은 경우에는 얘네들을 잘라서 보내기도 하고 이런식이더라 뭐 예를들어서 Application Layer에서 두 프로세스가 각각 5byte, 1500byte의 데이터를 줬다면 UCP의 경우에는 5byte, 1500byte로 전송을 하겠지만 TCP의 경우에는 1000byte, 505byte로 전송을 한다 이말임 이렇게 하는 것의 장점은 항상 비슷한 크기의 많은 데이터를 송수신하게 된다는 것이다 이게 왜 장점이 되냐면 데이터를 보낼때는 그것만 보내는게 아니고 여러 계층의 헤더를 붙여서 보내기 때문에 한번 보낼때 최대한 많은 데이터를 보내는게 효율적이기 때문 만일 Header를 다 합쳤을때 100바이트라면 UDP같은 경우에는 메시지가 5byte와 800byte두개가 들어오면 105byte, 900 byte 두번이 전송되지만 TCP같은 경우에는 얘네들을 합쳐서 보내기 때문에 905byte 한번만 전송하게 된다 그리고 알아두어야할 게 Port별로 버퍼가 생성된다 - 어차피 Port들을 Multiplexing과 Demultiplexing을 다 하기 때문에 Port가 합쳐지는 것에 대한 생각은 하지 말고 Process-to-Process의 관점에서만 생각하면 된다 그리고 TCP는 Reliable한 전송을 보장하기 때문에 송수신 속도 차이에 따른 Flow error를 방지하고자 송수신측 모두 버퍼를 둔다 그래서 위 그림처럼 송수신측 모두 넉넉하게 버퍼를 준비해놓고 Sending process가 송신 버퍼에 쓰면 그걸 순차적으로 보내게 되고 받는쪽에서도 데이터를 받아 수신 버퍼에 쓰면 그걸 Receiving process가 가져가게 되는 구조 버퍼가 없다면 아직 보내지도 않았는데 Sending process가 데이터를 줘 Overwrite된다거나 수신측에서도 Receiving Process가 가져가지도 않았는데 데이터가 수신되어 Overwrite되는 일이 벌어지게 되는 것 위 내용을 종합해보면 위와 같은 그림으로 표현할 수 있다 송수신 속도 차이에 따른 Flow error를 막기 위해 송수신 버퍼가 존재하고 Message별로 데이터를 보내는게 아닌 일정 수준 크기로 데이터들을 뭉쳐 Segment라는 단위로 보내게 된다 Full-duplex Communication § Full-duplex communication은 TCP가 양방향 통신을 지원한다는 의미이다 Connection Oriented Service § 이전에 배운거처럼 TCP는 orderly delivery를 지원한다 그래서 일단 Connect Phase를 거치고 - 전송을 이제 시작할 것이니 송수신측 모두 버퍼를 준비해라 + 송신할 데이터에 numbering을 하여 순서대로 도착하지 않아도 수신측에서 number를 보고 정렬하여 상위계층으로 보낼 수 있도록 그리고 데이터를 송수신한 후 Disconnect Phase를 거쳐 준비한 버퍼를 삭제해 다른 통신에서도 사용할 수 있도록 함 Reliable Service § TCP는 Reliable Communication을 지원한다 - Flow &amp;amp; Error Control을 하여 이러한 문제가 생기지 않도록 함 Numbering System of TCP § 일단 TCP에서 Numbering 하는 데에 중요한 것은 번호가 Segment별로 붙는게 아니라는 점이다 이게 무슨말이냐면 위에서 TCP에서의 전송 단위가 Segment라고 했는데 첫번째 보내는 Segment는 0번, 두번째 보내는 Segment는 1번 이런식으로 숫자를 붙이지 않는다는 것 이다 그럼 뭐 어떻게 하느냐 Byte 별로 번호를 붙이는 시스템을 이용한다 이걸 위해 두개의 필드가 헤더에 들어감 - Sequence Number하고 Acknowledge Number 얘네들은 Data link layer에서의 SEQ랑 ACK 번호랑 동일한 기능을 하는데 대신 번호를 매기는 단위가 Frame(Segment)가 아닌 바이트인 차이점이 있다 따라서 Sequence Number는 데이터의 첫번째 바이트에 붙는 번호이다 여기서 주의할 점은 Sequence Number는 0번부터 시작하지 않을 수도 있다는 점 - 0 ~ 2^31 - 1의 숫자 중 하나를 랜덤으로 골라 번호를 붙이게 된다 그리고 첫번째를 이렇게 붙이고 그 다음 바이트부터 1씩 증가하다가 2^31 - 1을 넘어가면 다시 0번으로 돌아와서 번호가 붙는 셈 당연히 Numbering이 이런식으로 된다는 거지 실제 Segment에는 첫번째 바이트의 Number인 Sequence number밖에 저장되지 않는다 그리고 Acknowledge Number는 Data link layer에서와 동일하게 이전까지는 잘 받았고 이제 이거를 보내달라는 의미가 된다 뒤에서 실제 예시를 보면 으케되는지 더 잘 알 수 있을거임 이런식으로 Byte-oriented Numbering System을 이용하기 때문에 Flow control과 Error control도 byte-oriented하게 이루어진다 뒤에 가서 어떻게 하는지 알려준댄다 Segment § 이게 Segment의 Header구조이다 위에서 언급 안한것만 살펴보면 HLEN은 헤더의 크기이다 - 근데 이것도 IP헤더랑 비슷하게 4-byte단위로 표시함 - 즉, HLEN이 1이면 헤더가 4바이트라는 거고 HLEN의 최대 크기가 15이기 때문에 최대 헤더의 크기는 60byte인데 Option and Padding을 제외한 필수적인 부분이 20byte이기 때문에 Option and Padding부분은 40byte 이내로 상황에 맞게 들어가게 된다 Reserved는 나중을 위해 비워둔 부분이고 주황색으로 표시된 Control이라고 불리는 Flag들은 Connection을 위해 있는 부분 Window Size는 Flow Control을 위해 존재하는 부분 Urgent Pointer는 뒤에서 배운댄다 Checksum은 Error control을 위해 존재하는 부분이랜다 A TCP Connection § Traffic이 막힌다던지 아니면 에러가 있어서 재전송을 하게 되는 등 전송의 순서가 바뀌게 되는 경우는 많다 그럼에도 불구하고 순서대로 데이터를 합치기 위해 Connection이 반드시 필요하게 됨 Connect → Data Transfer → Disconnect 순서로 수행된다 Connection Establishment Phase - Three way handshake § 일단 Connection단계에서는 Three way handshake라는 방식으로 Connection Establish를 하게 된다 이게뭐냐면 일단 Client가 통신하자고 Server에게 보내면 Server는 ㅇㅋ라고 하고 마지막으로 Client가 한번 더 확인차 ㅇㅋ라고 보내는 것 저렇게 세번 통신을 하여 Connection이 이루어지므로 Three way handshake인 것 위 그림 두개를 같이 봐야 한다 State Diagram을 볼 때는 점선 화살표가 Server, 실선 화살표가 Client인 것을 기억혀 그리고 edge에 붙어있는 라벨을 읽을 때 A/B이면 내가 지금 A를 했거나 A를 받은거고 그 다음에 B를 했다는 식으로 이해하면 됨 보면 Client가 Active open을 하고 Server한테 첫번째 악수를 날린다 Active open인 이유는 Client는 통신을 시작하는 주체이기 때문 - 적극적이다! 첫번째 악수를 날릴 때는 Control Flag의 SYN부분을 1로 만들어서 보낸다 그래서 저기 State Diagram에서 보면 Client는 Active open/SYN을 한 후에SYN-SENT상태에 진입하게 된다 그러면 Server는 Passive open을 하고 기다리다가 SYN을 받으면 Client에게 두번째 악수를 날린다 Passive open인 이유는 당연히 Server는 Client가 통신을 시작해야만 시작할 수 있으므로 수동적으로 통신을 열게 되는 것임 그리고 두번째 악수를 날릴 때는 Control Flag의 SYN부분과 ACK부분을 1로 만들어서 보낸다 그래서 State Diagram에서도 Server는 일단 **Passive open/-**이므로 수동적 통신 개시를 한 후에 LISTEN상태에서 기다리고 있다가 SYN/SYN + ACK을 한 후에 SYN-RCVD상태에 들어가게 된다 마지막으로 Client가 SYN + ACK를 받으면 세번째 악수를 날리며 Connection이 Establish된다 세번째 악수에서는 Client가 ACK하나만 올려서 보낸다 그럼 Server쪽에서는 ACK를 받았으므로 Connection establish를 하게 된다 그래서 Client쪽의 State Diagram을 보면 SYN + ACK/ACK을 하고 ESTABLISH상태로 가고 Server쪽의 State Diagram을 봐도 **ACK/-**를 하고 ESTABLISH상태로 가게 된다 그리고 여기서 Sequence Number하고 Acknowledge Number를 좀 유심히 봐야 하는데 첫번째 악수에서는 Client가 8000번이라는 난수를 보냄 - 처음으로 보낼때는 SEQ 에 그냥 난수를 하나 보내게 된다 두번째 악수에서는 Server가 SEQ 15000에 ACK로 8001번을 보내는 것을 알 수 있다 15000은 당연히 처음 보내는 것이기 때문에 난수이고 ACK가 8001이 되는 이유는 처음에 Client가 보낸 SEQ가 8000번이었으므로 이것을 잘 받았고 8001번을 나는 원한다는 뜻이 되는 거임 즉, ACK로 n을 받았으면 n - 1까지는 잘 받았고 이제 n을 보내주세요 라는 의미로 이해하면 된다 그리고 세번째 악수를 보면 Client가 여전히 8000을 보내고 ACK는 15001을 보낸다 뭐 ACK가 15001인 이유는 Server가 SEQ15000를 보냈기 때문이고 SEQ가 8000인 이유는 데이터를 보내기 위한 Segment가 아니기 때문이다 즉, 상대방의 ACK에 부응하여 그에 맞는 데이터를 보낼때는 상대방이 준 ACK를 SEQ에 넣어 데이터도 그에 맞는 것을 주지만 상대방에게 데이터를 보내는게 아닐때에는 SEQ로 ACK - 1을 주게 되는거 같음 그리고 ACK도 그냥 기계적으로 생각하면 편하다 - 상대방이 준 Segment를 잘 받았으면 그냥 그 다음거를 받기 원하는 거임 그리고 Control Flag에 대해서도 좀 정리를 해보면 SYN은 Connection을 하자는 의미인 거고 ACK는 방금 보낸 것을 잘 받았다는 의미인거다 따라서 첫번째 악수에는 Connection을 할건데 이전에 상대방이 보낸 것은 없으니까 SYN하나만 올라가있게 되는 것이고 두번째 악수는 Connection을 할거고 이전에 보낸 것을 잘 받았으니까 SYN과 ACK다 올라가 있는 것이다 그리고 세번째 악수는 Connection하자는 답변을 받았으므로 굳이 SYN을 올리지 않고 그냥 방금 니가 보낸거 잘 받았소 의 느낌으로 ACK하나만 올리게 되는 것 Data Transfer § 위의 예시에서 먼저 SEQ와 ACK를 보면 이제 데이터를 보낼꺼니까 상대방이 준 ACK를 반영해 SEQ에 8001을 넣어 데이터를 보내게 된다 그리고 방금 상대방이 준 것을 잘 받았고 이제 이걸 원한다는 의미로 ACK를 15001로 설정하는 것 여기서 데이터를 보내는데 ACK도 같이 보내는 이유는 TCP는 Full-duplex communication을 지원하므로 이런식으로 piggybacking을 할 수 있다는 것을 보여주기 위한 것 이다 즉, 데이터를 보냄과 동시에 ACK도 같이 보내 상대방도 ACK에 맞는 데이터를 보낼 수 있고 이런식으로 양방향 통신이 이루어지는 셈 - 이게 piggybacking인데 기억나시쥬? 위의 통신에서 두세번째를 보면 알 수 있다 - 두번째에서 방금 9000번까지 보냈으니까 이제 입벌려9001들어간다 느낌으로 SEQ 9001을 설정하고, 데이터와 함께 ACK 15001을 보내면 세번째에서 상대방은 그에 맞게 SEQ를 15001로 하여 자신도 데이터를 보내고 두번째에서 줬던 데이터를 잘 받았고 이제 10001을 원한다는 의미로 ACK를 같이 보내게 되는 것 마지막으로 네번째에서는 더 이상 보낼게 없으니까 SEQ는 그냥 마지막에 보낸 10000으로 하고 방금 보낸 데이터 잘 받았고 이제 17001을 원하고 있다는 것을 피력하기 위해 ACK를 17001로 설정해서 보내게 되는 것 그리고 Control Flag부분을 보면 상대방이 보낸 것에 대한 ACK가 Segment에 포함되어 있으므로 ACK FLAG를 올리게 된다 그리고 중요한게 저 PSH FLAG인데 이건 뭐냐면 TCP는 기본적으로 버퍼링을 해 버퍼에 일정수준의 바이트가 차기 전까지는 보내지 않고 받는쪽에서도 동일하게 어느정도 모이기 전까지는 Application layer로 올리지 않는다 받는쪽에서도 이렇게 기다리는 이유는 일단 Segment를 다 받고 정렬을 해서 올리기 위해서이기도 하고, 만일 데이터를 받을 Application이 바빠 지금 당장은 받지 못하는 경우에도 이렇게 기다렸다가 올리기 위해서이다 하지만 PSH FLAG가 올라가 있으면 기다리지 말고 바로 Application 으로 올리라는 의미를 가진다 보통 이것을 설정하는 것은 예를들어 채팅어플같은 실시간 통신이 중요할 때에는 기다리는 것이 곧 지연이기 때문에 이것을 막기 위해 바로 올려보내주세요 라고 하는 것이다 따라서 위의 예시에서는 첫 두 Segment에 PSH가 설정되어있으므로 쟤네들은 바로 Application으로 올라가게 된다 - 만약 이게 설정되어있지 않았더라면 첫번째는 버퍼에서 기다리고 두번째가 도착했을때 수신자의 판단 하에 Application으로 올릴 수 있는 것이다 위의 예시에서는 없지만 URG FLAG는 Urgent 즉, 긴급상황이 벌어진 것이다 이건 어떤 경우에 설정되냐면 예를들어서 큰 파일을 보내던 와중에 파일을 잘못보낸 것을 알고 이것을 취소하고자 할 때 사용한다 이런 상황이 생기면 TCP에서는 Special TCP Segment를 만들어 URG FLAG를 올리고 URG POINTER를 설정하여 데이터와 함께 보내게 된다 URG POINTER가 뭐냐면 위에 Segment Header구조 볼때 있던 필드인데 여기에 들어있는 값이 정상적인 데이터와 비정상적인 데이터를 구분하는 바이트 번호인 셈 즉, URG POINTER가 400이라고 되어 있으면 Segment의 데이터에서 400번째 바이트까지는 폐기해야되는 비정상적인 데이터이고, 그 이후에 나오는 바이트들은 정상적으로 수신해야 되는 데이터인 것 그래서 URG를 수신하게 되면 URG POINTER가 가르키는 곳까지 수신자는 폐기하게 된다 이렇게 하는 이유는 한번에 최대한 많은 데이터를 보내기 위함이다 - 문제가 생겼다고 문제가 있음을 알리는 Segment를 별도로 보내는게 아니고 문제가 있음을 알리면서 동시에 정상적인 데이터들도 보내고 싶으신거지 Connection Termination - Four-way Handshake(Half close) § Connection termination에서도 Establishment에서처럼 Three-way handshake로 할 수 있지만 요즘은 사용되지 않는댄다 그래서 요즘 사용하고 있는 방법은 Four-way Handshake(Half close) 라는 방법이다 그리고 위에서 언급한것처럼 Connection Termination단계에서 버퍼들을 반납하게 됨 위 그림이 통신 전반에 걸친 State Diagram인데 Established까지는 전부 배웠고 이제 그 아랫부분을 보면 된다 위와 같은 식으로 이루어짐 Client가 Active close를 하고 FIN FLAG을 올려서 Segment를 보냄 Establish때와 마찬가지로 항상 Client가 먼저 제안을 한다 뭐 FIN FLAG는 이름 그대로 이제 통신 그만하자 라는 뜻이다 State Diagram에서 봐도 Close를 하고 FIN을 보낸 뒤 FIN-WAIT-1상태로 들어간 것을 볼 수 있다 Server는 FIN을 받으면 알겠다고 ACK를 보내게 된다 State Diagram에서 보면 FIN을 받고 ACK를 날린 뒤 CLOSE-WAIT상태로 들어가게 된다 Client는 ACK를 받으면 아무것도 하지 않는다 State Diagram에서 보면 ACK를 받고 FIN-WAIT-2상태로 진입한걸 볼 수 있는데 이 단계가 뭐하는 거냐면 Client쪽은 데이터를 다 보냈어도 Server쪽은 Client가 요청한 데이터를 아직 덜 보냈을 수도 있기 때문에 Server가 마무리하는 단계가 되는 것이다 따라서 Client가 FIN-WAIT-2상태일때 Server는 못보낸 것들을 다 보내고 Client는 ACK를 날려 잘 받았다고 알려줌 Server는 마무리를 다 한 후에 FIN을 보낸다 State Diagram에서 보면 Close/FIN이라고 되어 있는데 이게 Close하는 동안 나머지 데이터를 전부 보내고 그 이후에 FIN을 보낸다는 것 FIN을 보내고 난 후에는 LAST-ACK상태로 들어가 ACK가 올때까지 기다린다 Client는 FIN을 받으면 ACK를 날리고 잠시 대기한다 State Diagram에서 보면 FIN/ACK후에 TIME-WAIT를 하는 것을 볼 수 있음 Server는 ACK를 받고 바로 Close로 들어간다 뭐 이제는 State diagram 설명안해도 되겠지 Client는 일정시간 기다린 후에 Close로 들어간다 Server는 바로 Close되는데 Client는 왜 일정시간 기다리는지 궁금하다면 대학원응안가 Flow Control § Window Size § 일단 TCP의 Flow Control에서 중요한 점은 Receiver의 요청에 의해 Sender의 버퍼 크기를 늘렸다 줄였다 한다는 것이다 이게 뭔소리냐면 만일 Receiver의 버퍼 용량이 5000이고 1000이 아직 Application으로 올라가지 못했다고 해보면 Receiver는 4000이상의 데이터를 받게 되면 버퍼가 터져나가게 된다 따라서 Receiver가 Sender한테 말하는 거임 - 4000이상 보내지 마라고 이때 Receiver가 사용할 수 있는 남은 버퍼의 크기를 rwnd라고 표현한다 또한 이러한 이유 말고도 다음 강의때 배울 cwnd라는 것도 있는데 이건 Congestion Window라고 네트워크의 혼잡도를 나타내는 것이다 - 네트워크가 혼잡하면 한번에 보내는 데이터의 양을 줄이라고 Sender에게 요청하는 것 이러한 일을 Segment Header에 있던 Window Size필드를 이용해 수행한다 Window Size필드의 값은 rwnd와 cwnd중 작은 값 으로 설정하여 Receiver가 Sender에게 요청하게 되는 것 - 두 값보다도 적은 사이즈로 보내야 정상적으로 수신할 수 있으므로 따라서 Sender의 버퍼를 보면 위와 같은 모양이 될 수 있다 일단 Window Size는 Receiver의 요청에 의해 9로 설정된 상태고 199까지는 전송했고 ACK까지 받은 애등 200~202까지는 전송했지만 ACK는 받지 못한 애들 그리고 203~208이 바로 전송할 수 있는 애들 209이후로는 Application한테 받았지만 Window size 제한때문에 보낼 수 없는 애들인 것이다 즉 위 그림에서 보이는것처럼 Window size가 정해져도 ACK를 받지 못한놈들 때문에 당장 보낼 수 있는 크기는 그것보다 작을 수도 있다는 것 ARQ § Flow Control이기 때문에 Data link layer에서의 Flow Control 방법을 사용하는데 Go-back-N ARQ가 아니라 Selective ARQ를 사용한댄다 기억안나면 06."/><meta name="generator" content="Quartz"/><link rel="preconnect" href="https://fonts.googleapis.com"/><link rel="preconnect" href="https://fonts.gstatic.com"/><link href="../../../../index.css" rel="stylesheet" type="text/css" spa-preserve/><link href="https://cdn.jsdelivr.net/npm/katex@0.16.0/dist/katex.min.css" rel="stylesheet" type="text/css" spa-preserve/><link href="https://fonts.googleapis.com/css2?family=IBM Plex Mono&amp;family=Gowun Batang:wght@400;700&amp;family=Gowun Dodum:ital,wght@0,400;0,600;1,400;1,600&amp;display=swap" rel="stylesheet" type="text/css" spa-preserve/><script src="../../../../prescript.js" type="application/javascript" spa-preserve></script><script type="application/javascript" spa-preserve>const fetchData = fetch(`../../../../static/contentIndex.json`).then(data => data.json())</script></head><body data-slug="gardens/network/originals/comnet.fall.2021.cse.cnu.ac.kr/09.-TCP"><div id="quartz-root" class="page"><div id="quartz-body"><div class="left sidebar"><h1 class="page-title "><a href="../../../..">Madison Digital Garden</a></h1><div class="spacer mobile-only"></div><div class="search "><div id="search-icon"><p>Search</p><div></div><svg tabIndex="0" aria-labelledby="title desc" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 19.9 19.7"><title id="title">Search</title><desc id="desc">Search</desc><g class="search-path" fill="none"><path stroke-linecap="square" d="M18.5 18.3l-5.4-5.4"></path><circle cx="8" cy="8" r="7"></circle></g></svg></div><div id="search-container"><div id="search-space"><input autocomplete="off" id="search-bar" name="search" type="text" aria-label="Search for something" placeholder="Search for something"/><div id="results-container"></div></div></div></div><div class="darkmode "><input class="toggle" id="darkmode-toggle" type="checkbox" tabIndex="-1"/><label id="toggle-label-light" for="darkmode-toggle" tabIndex="-1"><svg xmlns="http://www.w3.org/2000/svg" xmlnsXlink="http://www.w3.org/1999/xlink" version="1.1" id="dayIcon" x="0px" y="0px" viewBox="0 0 35 35" style="enable-background:new 0 0 35 35;" xmlSpace="preserve"><title>Light mode</title><path d="M6,17.5C6,16.672,5.328,16,4.5,16h-3C0.672,16,0,16.672,0,17.5    S0.672,19,1.5,19h3C5.328,19,6,18.328,6,17.5z M7.5,26c-0.414,0-0.789,0.168-1.061,0.439l-2,2C4.168,28.711,4,29.086,4,29.5    C4,30.328,4.671,31,5.5,31c0.414,0,0.789-0.168,1.06-0.44l2-2C8.832,28.289,9,27.914,9,27.5C9,26.672,8.329,26,7.5,26z M17.5,6    C18.329,6,19,5.328,19,4.5v-3C19,0.672,18.329,0,17.5,0S16,0.672,16,1.5v3C16,5.328,16.671,6,17.5,6z M27.5,9    c0.414,0,0.789-0.168,1.06-0.439l2-2C30.832,6.289,31,5.914,31,5.5C31,4.672,30.329,4,29.5,4c-0.414,0-0.789,0.168-1.061,0.44    l-2,2C26.168,6.711,26,7.086,26,7.5C26,8.328,26.671,9,27.5,9z M6.439,8.561C6.711,8.832,7.086,9,7.5,9C8.328,9,9,8.328,9,7.5    c0-0.414-0.168-0.789-0.439-1.061l-2-2C6.289,4.168,5.914,4,5.5,4C4.672,4,4,4.672,4,5.5c0,0.414,0.168,0.789,0.439,1.06    L6.439,8.561z M33.5,16h-3c-0.828,0-1.5,0.672-1.5,1.5s0.672,1.5,1.5,1.5h3c0.828,0,1.5-0.672,1.5-1.5S34.328,16,33.5,16z     M28.561,26.439C28.289,26.168,27.914,26,27.5,26c-0.828,0-1.5,0.672-1.5,1.5c0,0.414,0.168,0.789,0.439,1.06l2,2    C28.711,30.832,29.086,31,29.5,31c0.828,0,1.5-0.672,1.5-1.5c0-0.414-0.168-0.789-0.439-1.061L28.561,26.439z M17.5,29    c-0.829,0-1.5,0.672-1.5,1.5v3c0,0.828,0.671,1.5,1.5,1.5s1.5-0.672,1.5-1.5v-3C19,29.672,18.329,29,17.5,29z M17.5,7    C11.71,7,7,11.71,7,17.5S11.71,28,17.5,28S28,23.29,28,17.5S23.29,7,17.5,7z M17.5,25c-4.136,0-7.5-3.364-7.5-7.5    c0-4.136,3.364-7.5,7.5-7.5c4.136,0,7.5,3.364,7.5,7.5C25,21.636,21.636,25,17.5,25z"></path></svg></label><label id="toggle-label-dark" for="darkmode-toggle" tabIndex="-1"><svg xmlns="http://www.w3.org/2000/svg" xmlnsXlink="http://www.w3.org/1999/xlink" version="1.1" id="nightIcon" x="0px" y="0px" viewBox="0 0 100 100" style="enable-background='new 0 0 100 100'" xmlSpace="preserve"><title>Dark mode</title><path d="M96.76,66.458c-0.853-0.852-2.15-1.064-3.23-0.534c-6.063,2.991-12.858,4.571-19.655,4.571  C62.022,70.495,50.88,65.88,42.5,57.5C29.043,44.043,25.658,23.536,34.076,6.47c0.532-1.08,0.318-2.379-0.534-3.23  c-0.851-0.852-2.15-1.064-3.23-0.534c-4.918,2.427-9.375,5.619-13.246,9.491c-9.447,9.447-14.65,22.008-14.65,35.369  c0,13.36,5.203,25.921,14.65,35.368s22.008,14.65,35.368,14.65c13.361,0,25.921-5.203,35.369-14.65  c3.872-3.871,7.064-8.328,9.491-13.246C97.826,68.608,97.611,67.309,96.76,66.458z"></path></svg></label></div></div><div class="center"><div class="page-header"><div class="popover-hint"><h1 class="article-title ">09. TCP</h1><p class="content-meta ">Sep 02, 2024, 33 min read</p></div></div><article class="popover-hint"><blockquote class="callout" data-callout="info">
<div class="callout-title">
                  <div class="callout-icon"><svg xmlns="http://www.w3.org/2000/svg" width="100%" height="100%" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="10"></circle><line x1="12" y1="16" x2="12" y2="12"></line><line x1="12" y1="8" x2="12.01" y2="8"></line></svg></div>
                  <div class="callout-title-inner"><p>충남대학교 컴퓨터공학과 김상하 교수님의 &quot;컴퓨터 네트워크&quot; 강의를 필기한 내용입니다. </p></div>
                  
                </div>
</blockquote>
<blockquote class="callout" data-callout="warning">
<div class="callout-title">
                  <div class="callout-icon"><svg xmlns="http://www.w3.org/2000/svg" width="100%" height="100%" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="m21.73 18-8-14a2 2 0 0 0-3.48 0l-8 14A2 2 0 0 0 4 21h16a2 2 0 0 0 1.73-3Z"></path><line x1="12" y1="9" x2="12" y2="13"></line><line x1="12" y1="17" x2="12.01" y2="17"></line></svg></div>
                  <div class="callout-title-inner"><p>다소 잘못된 내용과 구어적 표현 이 포함되어 있을 수 있습니다. </p></div>
                  
                </div>
</blockquote>
<h2 id="tcp-services">TCP Services<a aria-hidden="true" tabindex="-1" href="#tcp-services" class="internal"> §</a></h2>
<h3 id="process-to-process-communication">Process-to-Process Communication<a aria-hidden="true" tabindex="-1" href="#process-to-process-communication" class="internal"> §</a></h3>
<ul>
<li>일단 뭐 Process-to-Process Deilivery를 지원하기 위한 port number를 사용하니까 <strong>Client-Server Model</strong>을 사용한다
<ul>
<li>TCP에서 사용하는 well know port는 80은 http, 53은 DNS라는것 정도는 알고 있어라</li>
</ul>
</li>
</ul>
<h3 id="stream-delivery-service">Stream Delivery Service<a aria-hidden="true" tabindex="-1" href="#stream-delivery-service" class="internal"> §</a></h3>
<p><img src="../../../../gardens/network/originals/comnet.fall.2021.cse.cnu.ac.kr/images/09_301bfe9a7a504c878eb201dca2a8ef33/image1.png" alt="%E1%84%8B%E1%85%B5%E1%84%85%E1%85%A9%E1%86%AB09%20-%20TCP%20301bfe9a7a504c878eb201dca2a8ef33/image1.png"/></p>
<ul>
<li>그리고 TCP에서는 <strong>Stream Delivery Service</strong>라는 것을 사용하는데 이게 뭐냐면</li>
<li>UDP같은 경우에는 Application Layer로부터 내려온 데이터를 하나의 데이터그램으로 만들어서 보낸다
<ul>
<li>이걸 내용적으로 의미있는 단위로 데이터그램을 전송한다하고 표현함</li>
</ul>
</li>
<li>하지만 TCP는 이렇게 하지 않고</li>
<li>Application Layer로부터 내려온 데이터들을 버퍼에 모았다가 버퍼가 일정 수준 쌓이면 그때 보내게 된다
<ul>
<li>즉, UDP처럼 내용으로 구분해서 전송하는게 아니고</li>
<li>버퍼에 쌓인 데이터의 크기로 구분해서 보내게 되는 것</li>
<li>따라서 여러개의 데이터가 하나의 단위로 묶여서 보내질 수도 있고 Application Layer에서 내려온 데이터가 많은 경우에는 얘네들을 잘라서 보내기도 하고 이런식이더라</li>
<li>뭐 예를들어서 Application Layer에서 두 프로세스가 각각 5byte, 1500byte의 데이터를 줬다면</li>
<li>UCP의 경우에는 5byte, 1500byte로 전송을 하겠지만</li>
<li>TCP의 경우에는 1000byte, 505byte로 전송을 한다 이말임</li>
</ul>
</li>
<li>이렇게 하는 것의 장점은 항상 비슷한 크기의 많은 데이터를 송수신하게 된다는 것이다
<ul>
<li>이게 왜 장점이 되냐면</li>
<li>데이터를 보낼때는 그것만 보내는게 아니고 여러 계층의 헤더를 붙여서 보내기 때문에 한번 보낼때 최대한 많은 데이터를 보내는게 효율적이기 때문</li>
<li>만일 Header를 다 합쳤을때 100바이트라면 UDP같은 경우에는 메시지가 5byte와 800byte두개가 들어오면 105byte, 900 byte 두번이 전송되지만</li>
<li>TCP같은 경우에는 얘네들을 합쳐서 보내기 때문에 905byte 한번만 전송하게 된다</li>
</ul>
</li>
<li>그리고 알아두어야할 게 Port별로 버퍼가 생성된다 - 어차피 Port들을 Multiplexing과 Demultiplexing을 다 하기 때문에 Port가 합쳐지는 것에 대한 생각은 하지 말고 Process-to-Process의 관점에서만 생각하면 된다</li>
</ul>
<p><img src="../../../../gardens/network/originals/comnet.fall.2021.cse.cnu.ac.kr/images/09_301bfe9a7a504c878eb201dca2a8ef33/image2.png" alt="%E1%84%8B%E1%85%B5%E1%84%85%E1%85%A9%E1%86%AB09%20-%20TCP%20301bfe9a7a504c878eb201dca2a8ef33/image2.png"/></p>
<ul>
<li>그리고 TCP는 Reliable한 전송을 보장하기 때문에 송수신 속도 차이에 따른 Flow error를 방지하고자 송수신측 모두 버퍼를 둔다</li>
<li>그래서 위 그림처럼 송수신측 모두 넉넉하게 버퍼를 준비해놓고 Sending process가 송신 버퍼에 쓰면 그걸 순차적으로 보내게 되고 받는쪽에서도 데이터를 받아 수신 버퍼에 쓰면 그걸 Receiving process가 가져가게 되는 구조</li>
<li>버퍼가 없다면 아직 보내지도 않았는데 Sending process가 데이터를 줘 Overwrite된다거나 수신측에서도 Receiving Process가 가져가지도 않았는데 데이터가 수신되어 Overwrite되는 일이 벌어지게 되는 것</li>
</ul>
<p><img src="../../../../gardens/network/originals/comnet.fall.2021.cse.cnu.ac.kr/images/09_301bfe9a7a504c878eb201dca2a8ef33/image3.png" alt="%E1%84%8B%E1%85%B5%E1%84%85%E1%85%A9%E1%86%AB09%20-%20TCP%20301bfe9a7a504c878eb201dca2a8ef33/image3.png"/></p>
<ul>
<li>위 내용을 종합해보면 위와 같은 그림으로 표현할 수 있다</li>
<li>송수신 속도 차이에 따른 Flow error를 막기 위해 송수신 버퍼가 존재하고</li>
<li>Message별로 데이터를 보내는게 아닌 일정 수준 크기로 데이터들을 뭉쳐 <strong>Segment</strong>라는 단위로 보내게 된다</li>
</ul>
<h3 id="full-duplex-communication">Full-duplex Communication<a aria-hidden="true" tabindex="-1" href="#full-duplex-communication" class="internal"> §</a></h3>
<ul>
<li><strong>Full-duplex communication</strong>은 TCP가 양방향 통신을 지원한다는 의미이다</li>
</ul>
<h3 id="connection-oriented-service">Connection Oriented Service<a aria-hidden="true" tabindex="-1" href="#connection-oriented-service" class="internal"> §</a></h3>
<ul>
<li>이전에 배운거처럼 TCP는 orderly delivery를 지원한다</li>
<li>그래서 일단 <strong>Connect Phase</strong>를 거치고 - 전송을 이제 시작할 것이니 송수신측 모두 버퍼를 준비해라 + 송신할 데이터에 numbering을 하여 순서대로 도착하지 않아도 수신측에서 number를 보고 정렬하여 상위계층으로 보낼 수 있도록</li>
<li>그리고 데이터를 송수신한 후 <strong>Disconnect Phase</strong>를 거쳐 준비한 버퍼를 삭제해 다른 통신에서도 사용할 수 있도록 함</li>
</ul>
<h3 id="reliable-service">Reliable Service<a aria-hidden="true" tabindex="-1" href="#reliable-service" class="internal"> §</a></h3>
<ul>
<li>TCP는 Reliable Communication을 지원한다 - Flow &amp; Error Control을 하여 이러한 문제가 생기지 않도록 함</li>
</ul>
<h2 id="numbering-system-of-tcp">Numbering System of TCP<a aria-hidden="true" tabindex="-1" href="#numbering-system-of-tcp" class="internal"> §</a></h2>
<ul>
<li>일단 TCP에서 Numbering 하는 데에 중요한 것은 번호가 Segment별로 붙는게 아니라는 점이다
<ul>
<li>이게 무슨말이냐면 위에서 TCP에서의 전송 단위가 <strong>Segment</strong>라고 했는데 첫번째 보내는 Segment는 0번, 두번째 보내는 Segment는 1번 이런식으로 숫자를 붙이지 않는다는 것 이다</li>
<li>그럼 뭐 어떻게 하느냐</li>
<li>Byte 별로 번호를 붙이는 시스템을 이용한다</li>
<li>이걸 위해 두개의 필드가 헤더에 들어감 - <strong>Sequence Number</strong>하고 <strong>Acknowledge Number</strong></li>
<li>얘네들은 Data link layer에서의 SEQ랑 ACK 번호랑 동일한 기능을 하는데 대신 번호를 매기는 단위가 Frame(Segment)가 아닌 바이트인 차이점이 있다</li>
<li>따라서 <strong>Sequence Number</strong>는 데이터의 첫번째 바이트에 붙는 번호이다</li>
<li>여기서 주의할 점은 <strong>Sequence Number</strong>는 0번부터 시작하지 않을 수도 있다는 점 - <strong>0 ~ 2^31 - 1</strong>의 숫자 중 하나를 랜덤으로 골라 번호를 붙이게 된다</li>
<li>그리고 첫번째를 이렇게 붙이고 그 다음 바이트부터 1씩 증가하다가 2^31 - 1을 넘어가면 다시 0번으로 돌아와서 번호가 붙는 셈</li>
<li>당연히 Numbering이 이런식으로 된다는 거지 실제 Segment에는 첫번째 바이트의 Number인 Sequence number밖에 저장되지 않는다</li>
<li>그리고 <strong>Acknowledge Number</strong>는 Data link layer에서와 동일하게 이전까지는 잘 받았고 이제 이거를 보내달라는 의미가 된다</li>
<li>뒤에서 실제 예시를 보면 으케되는지 더 잘 알 수 있을거임</li>
</ul>
</li>
<li>이런식으로 <strong>Byte-oriented Numbering System</strong>을 이용하기 때문에 Flow control과 Error control도 byte-oriented하게 이루어진다</li>
<li>뒤에 가서 어떻게 하는지 알려준댄다</li>
</ul>
<h2 id="segment">Segment<a aria-hidden="true" tabindex="-1" href="#segment" class="internal"> §</a></h2>
<p><img src="../../../../gardens/network/originals/comnet.fall.2021.cse.cnu.ac.kr/images/09_301bfe9a7a504c878eb201dca2a8ef33/image4.png" alt="%E1%84%8B%E1%85%B5%E1%84%85%E1%85%A9%E1%86%AB09%20-%20TCP%20301bfe9a7a504c878eb201dca2a8ef33/image4.png"/></p>
<ul>
<li>이게 Segment의 Header구조이다</li>
<li>위에서 언급 안한것만 살펴보면</li>
<li><strong>HLEN</strong>은 헤더의 크기이다 - 근데 이것도 IP헤더랑 비슷하게 4-byte단위로 표시함 - 즉, HLEN이 1이면 헤더가 4바이트라는 거고 HLEN의 최대 크기가 15이기 때문에 최대 헤더의 크기는 60byte인데 Option and Padding을 제외한 필수적인 부분이 20byte이기 때문에 Option and Padding부분은 40byte 이내로 상황에 맞게 들어가게 된다</li>
<li><strong>Reserved</strong>는 나중을 위해 비워둔 부분이고</li>
<li>주황색으로 표시된 <strong>Control</strong>이라고 불리는 Flag들은 Connection을 위해 있는 부분</li>
<li><strong>Window Size</strong>는 Flow Control을 위해 존재하는 부분</li>
<li><strong>Urgent Pointer</strong>는 뒤에서 배운댄다</li>
<li><strong>Checksum</strong>은 Error control을 위해 존재하는 부분이랜다</li>
</ul>
<h2 id="a-tcp-connection">A TCP Connection<a aria-hidden="true" tabindex="-1" href="#a-tcp-connection" class="internal"> §</a></h2>
<ul>
<li>Traffic이 막힌다던지 아니면 에러가 있어서 재전송을 하게 되는 등 전송의 순서가 바뀌게 되는 경우는 많다</li>
<li>그럼에도 불구하고 순서대로 데이터를 합치기 위해 Connection이 반드시 필요하게 됨</li>
<li><strong>Connect</strong> → <strong>Data Transfer</strong> → <strong>Disconnect</strong> 순서로 수행된다</li>
</ul>
<h3 id="connection-establishment-phase---three-way-handshake">Connection Establishment Phase - Three way handshake<a aria-hidden="true" tabindex="-1" href="#connection-establishment-phase---three-way-handshake" class="internal"> §</a></h3>
<ul>
<li>일단 Connection단계에서는 <strong>Three way handshake</strong>라는 방식으로 Connection Establish를 하게 된다</li>
<li>이게뭐냐면</li>
<li>일단 Client가 통신하자고 Server에게 보내면 Server는 ㅇㅋ라고 하고 마지막으로 Client가 한번 더 확인차 ㅇㅋ라고 보내는 것</li>
<li>저렇게 세번 통신을 하여 Connection이 이루어지므로 <strong>Three way handshake</strong>인 것</li>
</ul>
<p><img src="../../../../gardens/network/originals/comnet.fall.2021.cse.cnu.ac.kr/images/09_301bfe9a7a504c878eb201dca2a8ef33/image5.png" alt="%E1%84%8B%E1%85%B5%E1%84%85%E1%85%A9%E1%86%AB09%20-%20TCP%20301bfe9a7a504c878eb201dca2a8ef33/image5.png"/></p>
<p><img src="../../../../gardens/network/originals/comnet.fall.2021.cse.cnu.ac.kr/images/09_301bfe9a7a504c878eb201dca2a8ef33/image6.png" alt="%E1%84%8B%E1%85%B5%E1%84%85%E1%85%A9%E1%86%AB09%20-%20TCP%20301bfe9a7a504c878eb201dca2a8ef33/image6.png"/></p>
<ul>
<li>위 그림 두개를 같이 봐야 한다</li>
<li><strong>State Diagram</strong>을 볼 때는 점선 화살표가 Server, 실선 화살표가 Client인 것을 기억혀</li>
<li>그리고 edge에 붙어있는 라벨을 읽을 때 A/B이면 내가 지금 A를 했거나 A를 받은거고 그 다음에 B를 했다는 식으로 이해하면 됨</li>
<li>보면</li>
</ul>
<ol>
<li>Client가 <strong>Active open</strong>을 하고 Server한테 첫번째 악수를 날린다
<ul>
<li><strong>Active open</strong>인 이유는 Client는 통신을 시작하는 주체이기 때문 - 적극적이다!</li>
<li>첫번째 악수를 날릴 때는 Control Flag의 <strong>SYN</strong>부분을 1로 만들어서 보낸다</li>
<li>그래서 저기 State Diagram에서 보면 Client는 <strong>Active open/SYN</strong>을 한 후에<strong>SYN-SENT</strong>상태에 진입하게 된다</li>
</ul>
</li>
<li>그러면 Server는 <strong>Passive open</strong>을 하고 기다리다가 <strong>SYN</strong>을 받으면 Client에게 두번째 악수를 날린다
<ul>
<li><strong>Passive open</strong>인 이유는 당연히 Server는 Client가 통신을 시작해야만 시작할 수 있으므로 수동적으로 통신을 열게 되는 것임</li>
<li>그리고 두번째 악수를 날릴 때는 Control Flag의 <strong>SYN</strong>부분과 <strong>ACK</strong>부분을 1로 만들어서 보낸다</li>
<li>그래서 State Diagram에서도 Server는 일단 **Passive open/-**이므로 수동적 통신 개시를 한 후에 <strong>LISTEN</strong>상태에서 기다리고 있다가</li>
<li><strong>SYN/SYN + ACK</strong>을 한 후에 <strong>SYN-RCVD</strong>상태에 들어가게 된다</li>
</ul>
</li>
<li>마지막으로 Client가 <strong>SYN + ACK</strong>를 받으면 세번째 악수를 날리며 Connection이 Establish된다
<ul>
<li>세번째 악수에서는 Client가 <strong>ACK</strong>하나만 올려서 보낸다</li>
<li>그럼 Server쪽에서는 <strong>ACK</strong>를 받았으므로 Connection establish를 하게 된다</li>
<li>그래서 Client쪽의 State Diagram을 보면 <strong>SYN + ACK/ACK</strong>을 하고 <strong>ESTABLISH</strong>상태로 가고</li>
<li>Server쪽의 State Diagram을 봐도 **ACK/-**를 하고 <strong>ESTABLISH</strong>상태로 가게 된다</li>
</ul>
</li>
</ol>
<ul>
<li>그리고 여기서 <strong>Sequence Number</strong>하고 <strong>Acknowledge Number</strong>를 좀 유심히 봐야 하는데
<ul>
<li>첫번째 악수에서는 Client가 8000번이라는 난수를 보냄 - 처음으로 보낼때는 SEQ 에 그냥 난수를 하나 보내게 된다</li>
<li>두번째 악수에서는 Server가 SEQ 15000에 ACK로 8001번을 보내는 것을 알 수 있다</li>
<li>15000은 당연히 처음 보내는 것이기 때문에 난수이고</li>
<li>ACK가 8001이 되는 이유는 처음에 Client가 보낸 SEQ가 8000번이었으므로 이것을 잘 받았고 8001번을 나는 원한다는 뜻이 되는 거임</li>
<li>즉, ACK로 n을 받았으면 n - 1까지는 잘 받았고 이제 n을 보내주세요 라는 의미로 이해하면 된다</li>
<li>그리고 세번째 악수를 보면 Client가 여전히 8000을 보내고 ACK는 15001을 보낸다</li>
<li>뭐 ACK가 15001인 이유는 Server가 SEQ15000를 보냈기 때문이고</li>
<li>SEQ가 8000인 이유는 데이터를 보내기 위한 Segment가 아니기 때문이다</li>
<li>즉, 상대방의 ACK에 부응하여 그에 맞는 데이터를 보낼때는 상대방이 준 ACK를 SEQ에 넣어 데이터도 그에 맞는 것을 주지만 상대방에게 데이터를 보내는게 아닐때에는 SEQ로 ACK - 1을 주게 되는거 같음</li>
<li>그리고 ACK도 그냥 기계적으로 생각하면 편하다 - 상대방이 준 Segment를 잘 받았으면 그냥 그 다음거를 받기 원하는 거임</li>
</ul>
</li>
<li>그리고 Control Flag에 대해서도 좀 정리를 해보면 <strong>SYN</strong>은 Connection을 하자는 의미인 거고 <strong>ACK</strong>는 방금 보낸 것을 잘 받았다는 의미인거다
<ul>
<li>따라서 첫번째 악수에는 Connection을 할건데 이전에 상대방이 보낸 것은 없으니까 <strong>SYN</strong>하나만 올라가있게 되는 것이고</li>
<li>두번째 악수는 Connection을 할거고 이전에 보낸 것을 잘 받았으니까 <strong>SYN</strong>과 <strong>ACK</strong>다 올라가 있는 것이다</li>
<li>그리고 세번째 악수는 Connection하자는 답변을 받았으므로 굳이 <strong>SYN</strong>을 올리지 않고 그냥 방금 니가 보낸거 잘 받았소 의 느낌으로 <strong>ACK</strong>하나만 올리게 되는 것</li>
</ul>
</li>
</ul>
<h3 id="data-transfer">Data Transfer<a aria-hidden="true" tabindex="-1" href="#data-transfer" class="internal"> §</a></h3>
<p><img src="../../../../gardens/network/originals/comnet.fall.2021.cse.cnu.ac.kr/images/09_301bfe9a7a504c878eb201dca2a8ef33/image7.png" alt="%E1%84%8B%E1%85%B5%E1%84%85%E1%85%A9%E1%86%AB09%20-%20TCP%20301bfe9a7a504c878eb201dca2a8ef33/image7.png"/></p>
<ul>
<li>위의 예시에서 먼저 SEQ와 ACK를 보면
<ul>
<li>이제 데이터를 보낼꺼니까 상대방이 준 ACK를 반영해 SEQ에 8001을 넣어 데이터를 보내게 된다</li>
<li>그리고 방금 상대방이 준 것을 잘 받았고 이제 이걸 원한다는 의미로 ACK를 15001로 설정하는 것</li>
<li>여기서 데이터를 보내는데 ACK도 같이 보내는 이유는 TCP는 Full-duplex communication을 지원하므로 이런식으로 piggybacking을 할 수 있다는 것을 보여주기 위한 것 이다</li>
<li>즉, 데이터를 보냄과 동시에 ACK도 같이 보내 상대방도 ACK에 맞는 데이터를 보낼 수 있고 이런식으로 양방향 통신이 이루어지는 셈 - 이게 <strong>piggybacking</strong>인데 기억나시쥬?</li>
<li>위의 통신에서 두세번째를 보면 알 수 있다 - 두번째에서 방금 9000번까지 보냈으니까 이제 입벌려9001들어간다 느낌으로 SEQ 9001을 설정하고, 데이터와 함께 ACK 15001을 보내면</li>
<li>세번째에서 상대방은 그에 맞게 SEQ를 15001로 하여 자신도 데이터를 보내고 두번째에서 줬던 데이터를 잘 받았고 이제 10001을 원한다는 의미로 ACK를 같이 보내게 되는 것</li>
<li>마지막으로 네번째에서는 더 이상 보낼게 없으니까 SEQ는 그냥 마지막에 보낸 10000으로 하고 방금 보낸 데이터 잘 받았고 이제 17001을 원하고 있다는 것을 피력하기 위해 ACK를 17001로 설정해서 보내게 되는 것</li>
</ul>
</li>
<li>그리고 Control Flag부분을 보면
<ul>
<li>상대방이 보낸 것에 대한 ACK가 Segment에 포함되어 있으므로 ACK FLAG를 올리게 된다</li>
<li>그리고 중요한게 저 <strong>PSH FLAG</strong>인데 이건 뭐냐면</li>
<li>TCP는 기본적으로 버퍼링을 해 버퍼에 일정수준의 바이트가 차기 전까지는 보내지 않고 받는쪽에서도 동일하게 어느정도 모이기 전까지는 Application layer로 올리지 않는다</li>
<li>받는쪽에서도 이렇게 기다리는 이유는 일단 Segment를 다 받고 정렬을 해서 올리기 위해서이기도 하고, 만일 데이터를 받을 Application이 바빠 지금 당장은 받지 못하는 경우에도 이렇게 기다렸다가 올리기 위해서이다</li>
<li>하지만 <strong>PSH FLAG</strong>가 올라가 있으면 기다리지 말고 바로 Application 으로 올리라는 의미를 가진다</li>
<li>보통 이것을 설정하는 것은 예를들어 채팅어플같은 실시간 통신이 중요할 때에는 기다리는 것이 곧 지연이기 때문에 이것을 막기 위해 바로 올려보내주세요 라고 하는 것이다</li>
<li>따라서 위의 예시에서는 첫 두 Segment에 PSH가 설정되어있으므로 쟤네들은 바로 Application으로 올라가게 된다 - 만약 이게 설정되어있지 않았더라면 첫번째는 버퍼에서 기다리고 두번째가 도착했을때 수신자의 판단 하에 Application으로 올릴 수 있는 것이다</li>
</ul>
</li>
<li>위의 예시에서는 없지만 <strong>URG FLAG</strong>는 <strong>Urgent</strong> 즉, 긴급상황이 벌어진 것이다
<ul>
<li>이건 어떤 경우에 설정되냐면</li>
<li>예를들어서 큰 파일을 보내던 와중에 파일을 잘못보낸 것을 알고 이것을 취소하고자 할 때 사용한다</li>
<li>이런 상황이 생기면 TCP에서는 <strong>Special TCP Segment</strong>를 만들어 URG FLAG를 올리고 URG POINTER를 설정하여 데이터와 함께 보내게 된다</li>
<li>URG POINTER가 뭐냐면 위에 Segment Header구조 볼때 있던 필드인데 여기에 들어있는 값이 정상적인 데이터와 비정상적인 데이터를 구분하는 바이트 번호인 셈</li>
<li>즉, URG POINTER가 400이라고 되어 있으면 Segment의 데이터에서 400번째 바이트까지는 폐기해야되는 비정상적인 데이터이고, 그 이후에 나오는 바이트들은 정상적으로 수신해야 되는 데이터인 것</li>
<li>그래서 <strong>URG</strong>를 수신하게 되면 <strong>URG POINTER</strong>가 가르키는 곳까지 수신자는 폐기하게 된다</li>
<li>이렇게 하는 이유는 한번에 최대한 많은 데이터를 보내기 위함이다 - 문제가 생겼다고 문제가 있음을 알리는 Segment를 별도로 보내는게 아니고 문제가 있음을 알리면서 동시에 정상적인 데이터들도 보내고 싶으신거지</li>
</ul>
</li>
</ul>
<h3 id="connection-termination---four-way-handshakehalf-close">Connection Termination - Four-way Handshake(Half close)<a aria-hidden="true" tabindex="-1" href="#connection-termination---four-way-handshakehalf-close" class="internal"> §</a></h3>
<ul>
<li>Connection termination에서도 Establishment에서처럼 Three-way handshake로 할 수 있지만 요즘은 사용되지 않는댄다</li>
<li>그래서 요즘 사용하고 있는 방법은 <strong>Four-way Handshake(Half close)</strong> 라는 방법이다</li>
<li>그리고 위에서 언급한것처럼 Connection Termination단계에서 버퍼들을 반납하게 됨</li>
</ul>
<p><img src="../../../../gardens/network/originals/comnet.fall.2021.cse.cnu.ac.kr/images/09_301bfe9a7a504c878eb201dca2a8ef33/image8.png" alt="%E1%84%8B%E1%85%B5%E1%84%85%E1%85%A9%E1%86%AB09%20-%20TCP%20301bfe9a7a504c878eb201dca2a8ef33/image8.png"/></p>
<ul>
<li>위 그림이 통신 전반에 걸친 State Diagram인데 Established까지는 전부 배웠고 이제 그 아랫부분을 보면 된다</li>
</ul>
<p><img src="../../../../gardens/network/originals/comnet.fall.2021.cse.cnu.ac.kr/images/09_301bfe9a7a504c878eb201dca2a8ef33/image9.png" alt="%E1%84%8B%E1%85%B5%E1%84%85%E1%85%A9%E1%86%AB09%20-%20TCP%20301bfe9a7a504c878eb201dca2a8ef33/image9.png"/></p>
<ul>
<li>위와 같은 식으로 이루어짐</li>
</ul>
<ol>
<li>Client가 Active close를 하고 <strong>FIN FLAG</strong>을 올려서 Segment를 보냄
<ul>
<li>Establish때와 마찬가지로 항상 Client가 먼저 제안을 한다</li>
<li>뭐 <strong>FIN FLAG</strong>는 이름 그대로 이제 통신 그만하자 라는 뜻이다</li>
<li>State Diagram에서 봐도 Close를 하고 FIN을 보낸 뒤 <strong>FIN-WAIT-1</strong>상태로 들어간 것을 볼 수 있다</li>
</ul>
</li>
<li>Server는 FIN을 받으면 알겠다고 ACK를 보내게 된다
<ul>
<li>State Diagram에서 보면 FIN을 받고 ACK를 날린 뒤 <strong>CLOSE-WAIT</strong>상태로 들어가게 된다</li>
</ul>
</li>
<li>Client는 ACK를 받으면 아무것도 하지 않는다
<ul>
<li>State Diagram에서 보면 ACK를 받고 <strong>FIN-WAIT-2</strong>상태로 진입한걸 볼 수 있는데</li>
<li>이 단계가 뭐하는 거냐면 Client쪽은 데이터를 다 보냈어도 Server쪽은 Client가 요청한 데이터를 아직 덜 보냈을 수도 있기 때문에 Server가 마무리하는 단계가 되는 것이다</li>
<li>따라서 Client가 <strong>FIN-WAIT-2</strong>상태일때 Server는 못보낸 것들을 다 보내고 Client는 ACK를 날려 잘 받았다고 알려줌</li>
</ul>
</li>
<li>Server는 마무리를 다 한 후에 FIN을 보낸다
<ul>
<li>State Diagram에서 보면 Close/FIN이라고 되어 있는데 이게 Close하는 동안 나머지 데이터를 전부 보내고 그 이후에 FIN을 보낸다는 것</li>
<li>FIN을 보내고 난 후에는 <strong>LAST-ACK</strong>상태로 들어가 ACK가 올때까지 기다린다</li>
</ul>
</li>
<li>Client는 FIN을 받으면 ACK를 날리고 잠시 대기한다
<ul>
<li>State Diagram에서 보면 FIN/ACK후에 <strong>TIME-WAIT</strong>를 하는 것을 볼 수 있음</li>
</ul>
</li>
<li>Server는 ACK를 받고 바로 Close로 들어간다
<ul>
<li>뭐 이제는 State diagram 설명안해도 되겠지</li>
</ul>
</li>
<li>Client는 일정시간 기다린 후에 Close로 들어간다
<ul>
<li>Server는 바로 Close되는데 Client는 왜 일정시간 기다리는지 궁금하다면 대학원응안가</li>
</ul>
</li>
</ol>
<h2 id="flow-control">Flow Control<a aria-hidden="true" tabindex="-1" href="#flow-control" class="internal"> §</a></h2>
<h3 id="window-size">Window Size<a aria-hidden="true" tabindex="-1" href="#window-size" class="internal"> §</a></h3>
<ul>
<li>일단 TCP의 Flow Control에서 중요한 점은 Receiver의 요청에 의해 Sender의 버퍼 크기를 늘렸다 줄였다 한다는 것이다</li>
<li>이게 뭔소리냐면
<ul>
<li>만일 Receiver의 버퍼 용량이 5000이고 1000이 아직 Application으로 올라가지 못했다고 해보면</li>
<li>Receiver는 4000이상의 데이터를 받게 되면 버퍼가 터져나가게 된다</li>
<li>따라서 Receiver가 Sender한테 말하는 거임 - 4000이상 보내지 마라고</li>
<li>이때 Receiver가 사용할 수 있는 남은 버퍼의 크기를 <strong>rwnd</strong>라고 표현한다</li>
<li>또한 이러한 이유 말고도 다음 강의때 배울 <strong>cwnd</strong>라는 것도 있는데</li>
<li>이건 <strong>Congestion Window</strong>라고 네트워크의 혼잡도를 나타내는 것이다 - 네트워크가 혼잡하면 한번에 보내는 데이터의 양을 줄이라고 Sender에게 요청하는 것</li>
</ul>
</li>
<li>이러한 일을 Segment Header에 있던 <strong>Window Size</strong>필드를 이용해 수행한다</li>
<li><strong>Window Size</strong>필드의 값은 <strong>rwnd</strong>와 <strong>cwnd</strong>중 작은 값 으로 설정하여 Receiver가 Sender에게 요청하게 되는 것 - 두 값보다도 적은 사이즈로 보내야 정상적으로 수신할 수 있으므로</li>
</ul>
<p><img src="../../../../gardens/network/originals/comnet.fall.2021.cse.cnu.ac.kr/images/09_301bfe9a7a504c878eb201dca2a8ef33/image10.png" alt="%E1%84%8B%E1%85%B5%E1%84%85%E1%85%A9%E1%86%AB09%20-%20TCP%20301bfe9a7a504c878eb201dca2a8ef33/image10.png"/></p>
<ul>
<li>따라서 Sender의 버퍼를 보면 위와 같은 모양이 될 수 있다</li>
<li>일단 Window Size는 Receiver의 요청에 의해 9로 설정된 상태고</li>
<li>199까지는 전송했고 ACK까지 받은 애등</li>
<li>200~202까지는 전송했지만 ACK는 받지 못한 애들</li>
<li>그리고 203~208이 바로 전송할 수 있는 애들</li>
<li>209이후로는 Application한테 받았지만 Window size 제한때문에 보낼 수 없는 애들인 것이다</li>
<li>즉 위 그림에서 보이는것처럼 Window size가 정해져도 ACK를 받지 못한놈들 때문에 당장 보낼 수 있는 크기는 그것보다 작을 수도 있다는 것</li>
</ul>
<h3 id="arq">ARQ<a aria-hidden="true" tabindex="-1" href="#arq" class="internal"> §</a></h3>
<ul>
<li>Flow Control이기 때문에 Data link layer에서의 Flow Control 방법을 사용하는데</li>
<li>Go-back-N ARQ가 아니라 <strong>Selective ARQ</strong>를 사용한댄다</li>
<li>기억안나면 <a href="../../../../gardens/network/originals/datacommunication.spring.2021.cse.cnu.ac.kr/06.-ARQ-Protocol,-HDLC" class="internal" data-slug="gardens/network/originals/datacommunication.spring.2021.cse.cnu.ac.kr/06.-ARQ-Protocol,-HDLC">06. ARQ Protocol, HDLC</a></li>
</ul>
<h2 id="error-control">Error Control<a aria-hidden="true" tabindex="-1" href="#error-control" class="internal"> §</a></h2>
<ul>
<li><strong>Segment Header</strong>의 <strong>Checksum</strong> 이라는 필드를 이용해 Error detection을 함</li>
<li>그리고 수신측에서는 정상적으로 도착하면 ACK를 보내고 정상이 아니라면 아무것도 보내지 않는다 - 따라서 송신측에서는 ACK가 오지 않으면 <strong>Retransmission</strong>을 하게 됨
<ul>
<li>여기에는 두 가지 용어가 등장한다</li>
<li><strong>RTO(Retransmission Time Out)</strong> 이라는 것은 말 그대로 일정 시간이 지나도 ACK가 오지 않는 것을 의미하고</li>
<li><strong>RTT(Round Trip Time)</strong> 이라는 것은 송신측이 시간을 잴 때 고정된 시간이 지나면 Retransmission을 하는 것이 아니고 Segment 왕복시간을 평균내서 해당 시간보다 늦어지면 Retransmission을 하게 되는 것을 말한다</li>
<li>즉, 늦는다고 무조건 보내는게 아니고 Traffic에 의한 지연일 수도 있으니까 왕복시간을 고려해 타임아웃을 거는 구조다 이거지</li>
</ul>
</li>
<li>그리고 <strong>Three Duplicate ACK Segment</strong>가 와도 Retransmission을 하게 된다
<ul>
<li>이게 뭔지는 뒤에 나올거임</li>
</ul>
</li>
<li>중요한 것은 Selective ARQ이기 때문에 순서에 맞지 않게 나중꺼가 먼저 도착해도 그걸 버리지 않는다 - <strong>out-of-order</strong>라는 플래그를 달아서 보류해뒀다가 빠진 Segment가 도착하면 그때 정렬을 해서 Application으로 올려보내는 구조</li>
</ul>
<h3 id="normal-operation">Normal Operation<a aria-hidden="true" tabindex="-1" href="#normal-operation" class="internal"> §</a></h3>
<p><img src="../../../../gardens/network/originals/comnet.fall.2021.cse.cnu.ac.kr/images/09_301bfe9a7a504c878eb201dca2a8ef33/image11.png" alt="%E1%84%8B%E1%85%B5%E1%84%85%E1%85%A9%E1%86%AB09%20-%20TCP%20301bfe9a7a504c878eb201dca2a8ef33/image11.png"/></p>
<ul>
<li>이건 뭐 정상적인 경우인데</li>
<li>중요한점은 여러번의 수신을 하나의 ACK로 퉁칠수 있다는 것이다</li>
<li>위의 예제에서 보면 5001<del>6001을 보내고 6001</del>7001을 보낸 후에 ACK로 7001을 보내게 되면 6001에 대한 ACK가 없으므로 이게 누락됐다고 생각하는게 아니고 7000까지는 잘 받았다고 생각하게 되는 것</li>
</ul>
<h3 id="rtt-operation">RTT Operation<a aria-hidden="true" tabindex="-1" href="#rtt-operation" class="internal"> §</a></h3>
<p><img src="../../../../gardens/network/originals/comnet.fall.2021.cse.cnu.ac.kr/images/09_301bfe9a7a504c878eb201dca2a8ef33/image12.png" alt="%E1%84%8B%E1%85%B5%E1%84%85%E1%85%A9%E1%86%AB09%20-%20TCP%20301bfe9a7a504c878eb201dca2a8ef33/image12.png"/></p>
<ul>
<li>여기서 보면</li>
<li>701~800을 보내고 801~900을 보냈을 때 수신측은 701~800이 누락되었으므로 ACK 701를 한번 더 보내게 된다</li>
<li>근데 여기서 중요한점은 위에서 말한것처럼 Out of Order를 버리지 않는다는 것이다
<ul>
<li>위의 예제에서 보면 801~901까지는 정상적으로 왔는데 앞에꺼가 안왔다고 이것을 버리는게 아니라 Out of Order마킹해놓고 보류해놓은 뒤 701이 안왔다고 ACK 701을 보내게 되는 것</li>
</ul>
</li>
<li>송신측에서는 ACK 901을 기대하고있었는데 ACK 701이 오기도 했고</li>
<li>보낸 701~800이 타임아웃이 났기 때문에 701~800을 다시 보내게 됨</li>
<li>그럼 수신측에 도착하면 다 잘 받았다는 뜻으로 ACK 901을 주게 된다 - 701~800이 잘 도착했으므로 801~900을 Out of Order를 풀고 나머지를 이어 받거나 Application으로 올리던가 하게 됨</li>
</ul>
<h3 id="three-duplicate-ack---fast-retransmission">Three Duplicate ACK - Fast Retransmission<a aria-hidden="true" tabindex="-1" href="#three-duplicate-ack---fast-retransmission" class="internal"> §</a></h3>
<p><img src="../../../../gardens/network/originals/comnet.fall.2021.cse.cnu.ac.kr/images/09_301bfe9a7a504c878eb201dca2a8ef33/image13.png" alt="%E1%84%8B%E1%85%B5%E1%84%85%E1%85%A9%E1%86%AB09%20-%20TCP%20301bfe9a7a504c878eb201dca2a8ef33/image13.png"/></p>
<ul>
<li>말 그대로 동일한 ACK가 세번이나 들어왔을 때 재전송하는 것을 의미한다</li>
<li>RTT가 끝나기 전에 ACK가 세번이 들어오면 걔도 뭔가 문제가 있다고 판단하고 재전송을 하게 됨</li>
<li>위의 예제에서도 Out of Order를 버리지 않는다는 것이 나타난다 - 뒤에놈이 먼저 들어오면 Out of Order로 빼서 보류해두고 안들어온 301에 대해 ACK를 날리게 됨 - 이게 세번 중첩되면 재전송을 하고 재전송 성공하면 전부 다 들어왔음을 알리기 위해 ACK 701을 보내게 되는 것</li>
<li>근데 IP에서의 Packet Switching은 Datagram을 사용하기 때문에 누락된게 아니라 경로를 잘못 들어 좀 오래 걸리는 것일 수도 있음
<ul>
<li>근데도 동일한 ACK가 세번이나 들어오면 문제가 발생했다고 판단하긴 한다</li>
<li>이러한 이유때문에 Three duplicate ACK를 <strong>Weak Error</strong>라고 부른댄다 - 확실하지는 않은 오류라 이거지</li>
<li>반면에 RTT의 경우는 누락된 것이 확실하기 때문에 <strong>Strong Error</strong>라고 한댄다</li>
</ul>
</li>
</ul></article></div><div class="right sidebar"><div class="graph "><h3>Graph View</h3><div class="graph-outer"><div id="graph-container" data-cfg="{&quot;drag&quot;:true,&quot;zoom&quot;:true,&quot;depth&quot;:1,&quot;scale&quot;:1.1,&quot;repelForce&quot;:0.5,&quot;centerForce&quot;:0.3,&quot;linkDistance&quot;:30,&quot;fontSize&quot;:0.6,&quot;opacityScale&quot;:1,&quot;showTags&quot;:true,&quot;removeTags&quot;:[]}"></div><svg version="1.1" id="global-graph-icon" xmlns="http://www.w3.org/2000/svg" xmlnsXlink="http://www.w3.org/1999/xlink" x="0px" y="0px" viewBox="0 0 55 55" fill="currentColor" xmlSpace="preserve"><path d="M49,0c-3.309,0-6,2.691-6,6c0,1.035,0.263,2.009,0.726,2.86l-9.829,9.829C32.542,17.634,30.846,17,29,17
	s-3.542,0.634-4.898,1.688l-7.669-7.669C16.785,10.424,17,9.74,17,9c0-2.206-1.794-4-4-4S9,6.794,9,9s1.794,4,4,4
	c0.74,0,1.424-0.215,2.019-0.567l7.669,7.669C21.634,21.458,21,23.154,21,25s0.634,3.542,1.688,4.897L10.024,42.562
	C8.958,41.595,7.549,41,6,41c-3.309,0-6,2.691-6,6s2.691,6,6,6s6-2.691,6-6c0-1.035-0.263-2.009-0.726-2.86l12.829-12.829
	c1.106,0.86,2.44,1.436,3.898,1.619v10.16c-2.833,0.478-5,2.942-5,5.91c0,3.309,2.691,6,6,6s6-2.691,6-6c0-2.967-2.167-5.431-5-5.91
	v-10.16c1.458-0.183,2.792-0.759,3.898-1.619l7.669,7.669C41.215,39.576,41,40.26,41,41c0,2.206,1.794,4,4,4s4-1.794,4-4
	s-1.794-4-4-4c-0.74,0-1.424,0.215-2.019,0.567l-7.669-7.669C36.366,28.542,37,26.846,37,25s-0.634-3.542-1.688-4.897l9.665-9.665
	C46.042,11.405,47.451,12,49,12c3.309,0,6-2.691,6-6S52.309,0,49,0z M11,9c0-1.103,0.897-2,2-2s2,0.897,2,2s-0.897,2-2,2
	S11,10.103,11,9z M6,51c-2.206,0-4-1.794-4-4s1.794-4,4-4s4,1.794,4,4S8.206,51,6,51z M33,49c0,2.206-1.794,4-4,4s-4-1.794-4-4
	s1.794-4,4-4S33,46.794,33,49z M29,31c-3.309,0-6-2.691-6-6s2.691-6,6-6s6,2.691,6,6S32.309,31,29,31z M47,41c0,1.103-0.897,2-2,2
	s-2-0.897-2-2s0.897-2,2-2S47,39.897,47,41z M49,10c-2.206,0-4-1.794-4-4s1.794-4,4-4s4,1.794,4,4S51.206,10,49,10z"></path></svg></div><div id="global-graph-outer"><div id="global-graph-container" data-cfg="{&quot;drag&quot;:true,&quot;zoom&quot;:true,&quot;depth&quot;:-1,&quot;scale&quot;:0.9,&quot;repelForce&quot;:0.5,&quot;centerForce&quot;:0.3,&quot;linkDistance&quot;:30,&quot;fontSize&quot;:0.6,&quot;opacityScale&quot;:1,&quot;showTags&quot;:true,&quot;removeTags&quot;:[]}"></div></div></div><div class="toc desktop-only"><button type="button" id="toc"><h3>Table of Contents</h3><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="fold"><polyline points="6 9 12 15 18 9"></polyline></svg></button><div id="toc-content"><ul class="overflow"><li class="depth-0"><a href="#tcp-services" data-for="tcp-services">TCP Services</a></li><li class="depth-1"><a href="#process-to-process-communication" data-for="process-to-process-communication">Process-to-Process Communication</a></li><li class="depth-1"><a href="#stream-delivery-service" data-for="stream-delivery-service">Stream Delivery Service</a></li><li class="depth-1"><a href="#full-duplex-communication" data-for="full-duplex-communication">Full-duplex Communication</a></li><li class="depth-1"><a href="#connection-oriented-service" data-for="connection-oriented-service">Connection Oriented Service</a></li><li class="depth-1"><a href="#reliable-service" data-for="reliable-service">Reliable Service</a></li><li class="depth-0"><a href="#numbering-system-of-tcp" data-for="numbering-system-of-tcp">Numbering System of TCP</a></li><li class="depth-0"><a href="#segment" data-for="segment">Segment</a></li><li class="depth-0"><a href="#a-tcp-connection" data-for="a-tcp-connection">A TCP Connection</a></li><li class="depth-1"><a href="#connection-establishment-phase---three-way-handshake" data-for="connection-establishment-phase---three-way-handshake">Connection Establishment Phase - Three way handshake</a></li><li class="depth-1"><a href="#data-transfer" data-for="data-transfer">Data Transfer</a></li><li class="depth-1"><a href="#connection-termination---four-way-handshakehalf-close" data-for="connection-termination---four-way-handshakehalf-close">Connection Termination - Four-way Handshake(Half close)</a></li><li class="depth-0"><a href="#flow-control" data-for="flow-control">Flow Control</a></li><li class="depth-1"><a href="#window-size" data-for="window-size">Window Size</a></li><li class="depth-1"><a href="#arq" data-for="arq">ARQ</a></li><li class="depth-0"><a href="#error-control" data-for="error-control">Error Control</a></li><li class="depth-1"><a href="#normal-operation" data-for="normal-operation">Normal Operation</a></li><li class="depth-1"><a href="#rtt-operation" data-for="rtt-operation">RTT Operation</a></li><li class="depth-1"><a href="#three-duplicate-ack---fast-retransmission" data-for="three-duplicate-ack---fast-retransmission">Three Duplicate ACK - Fast Retransmission</a></li></ul></div></div><div class="backlinks "><h3>Backlinks</h3><ul class="overflow"><li><a href="../../../../gardens/network/originals/comnet.fall.2021.cse.cnu.ac.kr/(충남대)-컴퓨터-네트워크-강의록" class="internal">(충남대) 컴퓨터 네트워크 강의록</a></li></ul></div></div></div><footer class><hr/><p>Created with <a href="https://quartz.jzhao.xyz/">Quartz v4.1.0</a>, © 2024</p><ul><li><a href="https://github.com/haeramkeem">GitHub</a></li><li><a href="www.linkedin.com/in/haeram-kim-277404220">LinkedIn</a></li><li><a href="mailto:haeram.kim1@gmail.com">Email</a></li></ul></footer></div></body><script type="application/javascript">// quartz/components/scripts/quartz/components/scripts/callout.inline.ts
function toggleCallout() {
  const outerBlock = this.parentElement;
  outerBlock.classList.toggle(`is-collapsed`);
  const collapsed = outerBlock.classList.contains(`is-collapsed`);
  const height = collapsed ? this.scrollHeight : outerBlock.scrollHeight;
  outerBlock.style.maxHeight = height + `px`;
  let current = outerBlock;
  let parent = outerBlock.parentElement;
  while (parent) {
    if (!parent.classList.contains(`callout`)) {
      return;
    }
    const collapsed2 = parent.classList.contains(`is-collapsed`);
    const height2 = collapsed2 ? parent.scrollHeight : parent.scrollHeight + current.scrollHeight;
    parent.style.maxHeight = height2 + `px`;
    current = parent;
    parent = parent.parentElement;
  }
}
function setupCallout() {
  const collapsible = document.getElementsByClassName(
    `callout is-collapsible`
  );
  for (const div of collapsible) {
    const title = div.firstElementChild;
    if (title) {
      title.removeEventListener(`click`, toggleCallout);
      title.addEventListener(`click`, toggleCallout);
      const collapsed = div.classList.contains(`is-collapsed`);
      const height = collapsed ? title.scrollHeight : div.scrollHeight;
      div.style.maxHeight = height + `px`;
    }
  }
}
document.addEventListener(`nav`, setupCallout);
window.addEventListener(`resize`, setupCallout);
</script><script type="module">
          import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.esm.min.mjs';
          const darkMode = document.documentElement.getAttribute('saved-theme') === 'dark'
          mermaid.initialize({
            startOnLoad: false,
            securityLevel: 'loose',
            theme: darkMode ? 'dark' : 'default'
          });
          document.addEventListener('nav', async () => {
            await mermaid.run({
              querySelector: '.mermaid'
            })
          });
          </script><script src="https://cdn.jsdelivr.net/npm/katex@0.16.7/dist/contrib/copy-tex.min.js" type="application/javascript"></script><script src="https://www.googletagmanager.com/gtag/js?id=G-N68CCP1QHG" type="application/javascript"></script><script src="../../../../postscript.js" type="module"></script></html>