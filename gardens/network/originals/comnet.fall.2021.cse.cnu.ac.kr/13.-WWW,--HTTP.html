<!DOCTYPE html>
<html><head><title>13. WWW,  HTTP</title><meta charSet="utf-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:title" content="13. WWW,  HTTP"/><meta property="og:description" content="충남대학교 컴퓨터공학과 김상하 교수님의 &amp;quot;컴퓨터 네트워크&amp;quot; 강의를 필기한 내용입니다. 다소 잘못된 내용과 구어적 표현 이 포함되어 있을 수 있습니다. World Wide Web § www : 전 세계적으로 연결된 정보 저장소 Client, Server § 익숙한내용이니까 금방금방 넘어가자고 이런식으로 Client와 Server로 구성되어 있고 Server가 Web Page를 가지고 있으며 Client가 그걸 요청하면 전달해주는 식으로 돌아간다 그리고 이건 Client쪽 Browser의 구조를 나타낸건데 Web Document들을 HTTP, FTP 등의 Client Protocol을 이용해 가져오고 그걸 HTML, JS 등을 해석하는 Interpreter을 통해 화면에 뿌리게 되는데 이때 어떤 프로토콜을 이용할건지, 그리고 그걸 받아서 어떤 인터프리터를 사용할건지 연결해주는 것이 Controller가 하는 역할이다 URL § URL(Uniform Resource Locator) 는 Client가 자기가 원하는 정보가 Server의 정확히 어디에 있는지, 그리고 어떻게 가져와야 하는지를 명시하는 방법이다 지긋지긋하제? 제일 먼저 Protocol을 명시한다 - HTTP인지, HTTPS인지 등 그리고 Host는 숫자 혹은 DNS로 표현된 서버의 IP를 나타낸다 Port는 말그대로 포트번호고 Path는 서버 내에서의 디렉토리 구조상에서의 위치를 나타내는 것 Cookie § 얘가 뭔지는 이미 알테니까 얘를 왜쓰는지를 중점적으로 보면 HTTP는 Stateless - Client의 상태를 저장하지 않음."/><meta property="og:image" content="https://mdg.haeramk.im/static/og-image.png"/><meta property="og:width" content="1200"/><meta property="og:height" content="675"/><link rel="icon" href="../../../../static/icon.png"/><meta name="description" content="충남대학교 컴퓨터공학과 김상하 교수님의 &amp;quot;컴퓨터 네트워크&amp;quot; 강의를 필기한 내용입니다. 다소 잘못된 내용과 구어적 표현 이 포함되어 있을 수 있습니다. World Wide Web § www : 전 세계적으로 연결된 정보 저장소 Client, Server § 익숙한내용이니까 금방금방 넘어가자고 이런식으로 Client와 Server로 구성되어 있고 Server가 Web Page를 가지고 있으며 Client가 그걸 요청하면 전달해주는 식으로 돌아간다 그리고 이건 Client쪽 Browser의 구조를 나타낸건데 Web Document들을 HTTP, FTP 등의 Client Protocol을 이용해 가져오고 그걸 HTML, JS 등을 해석하는 Interpreter을 통해 화면에 뿌리게 되는데 이때 어떤 프로토콜을 이용할건지, 그리고 그걸 받아서 어떤 인터프리터를 사용할건지 연결해주는 것이 Controller가 하는 역할이다 URL § URL(Uniform Resource Locator) 는 Client가 자기가 원하는 정보가 Server의 정확히 어디에 있는지, 그리고 어떻게 가져와야 하는지를 명시하는 방법이다 지긋지긋하제? 제일 먼저 Protocol을 명시한다 - HTTP인지, HTTPS인지 등 그리고 Host는 숫자 혹은 DNS로 표현된 서버의 IP를 나타낸다 Port는 말그대로 포트번호고 Path는 서버 내에서의 디렉토리 구조상에서의 위치를 나타내는 것 Cookie § 얘가 뭔지는 이미 알테니까 얘를 왜쓰는지를 중점적으로 보면 HTTP는 Stateless - Client의 상태를 저장하지 않음."/><meta name="generator" content="Quartz"/><link rel="preconnect" href="https://fonts.googleapis.com"/><link rel="preconnect" href="https://fonts.gstatic.com"/><link href="../../../../index.css" rel="stylesheet" type="text/css" spa-preserve/><link href="https://cdn.jsdelivr.net/npm/katex@0.16.0/dist/katex.min.css" rel="stylesheet" type="text/css" spa-preserve/><link href="https://fonts.googleapis.com/css2?family=IBM Plex Mono&amp;family=Gowun Batang:wght@400;700&amp;family=Gowun Dodum:ital,wght@0,400;0,600;1,400;1,600&amp;display=swap" rel="stylesheet" type="text/css" spa-preserve/><script src="../../../../prescript.js" type="application/javascript" spa-preserve></script><script type="application/javascript" spa-preserve>const fetchData = fetch(`../../../../static/contentIndex.json`).then(data => data.json())</script></head><body data-slug="gardens/network/originals/comnet.fall.2021.cse.cnu.ac.kr/13.-WWW,--HTTP"><div id="quartz-root" class="page"><div id="quartz-body"><div class="left sidebar"><h1 class="page-title "><a href="../../../..">Madison Digital Garden</a></h1><div class="spacer mobile-only"></div><div class="search "><div id="search-icon"><p>Search</p><div></div><svg tabIndex="0" aria-labelledby="title desc" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 19.9 19.7"><title id="title">Search</title><desc id="desc">Search</desc><g class="search-path" fill="none"><path stroke-linecap="square" d="M18.5 18.3l-5.4-5.4"></path><circle cx="8" cy="8" r="7"></circle></g></svg></div><div id="search-container"><div id="search-space"><input autocomplete="off" id="search-bar" name="search" type="text" aria-label="Search for something" placeholder="Search for something"/><div id="results-container"></div></div></div></div><div class="darkmode "><input class="toggle" id="darkmode-toggle" type="checkbox" tabIndex="-1"/><label id="toggle-label-light" for="darkmode-toggle" tabIndex="-1"><svg xmlns="http://www.w3.org/2000/svg" xmlnsXlink="http://www.w3.org/1999/xlink" version="1.1" id="dayIcon" x="0px" y="0px" viewBox="0 0 35 35" style="enable-background:new 0 0 35 35;" xmlSpace="preserve"><title>Light mode</title><path d="M6,17.5C6,16.672,5.328,16,4.5,16h-3C0.672,16,0,16.672,0,17.5    S0.672,19,1.5,19h3C5.328,19,6,18.328,6,17.5z M7.5,26c-0.414,0-0.789,0.168-1.061,0.439l-2,2C4.168,28.711,4,29.086,4,29.5    C4,30.328,4.671,31,5.5,31c0.414,0,0.789-0.168,1.06-0.44l2-2C8.832,28.289,9,27.914,9,27.5C9,26.672,8.329,26,7.5,26z M17.5,6    C18.329,6,19,5.328,19,4.5v-3C19,0.672,18.329,0,17.5,0S16,0.672,16,1.5v3C16,5.328,16.671,6,17.5,6z M27.5,9    c0.414,0,0.789-0.168,1.06-0.439l2-2C30.832,6.289,31,5.914,31,5.5C31,4.672,30.329,4,29.5,4c-0.414,0-0.789,0.168-1.061,0.44    l-2,2C26.168,6.711,26,7.086,26,7.5C26,8.328,26.671,9,27.5,9z M6.439,8.561C6.711,8.832,7.086,9,7.5,9C8.328,9,9,8.328,9,7.5    c0-0.414-0.168-0.789-0.439-1.061l-2-2C6.289,4.168,5.914,4,5.5,4C4.672,4,4,4.672,4,5.5c0,0.414,0.168,0.789,0.439,1.06    L6.439,8.561z M33.5,16h-3c-0.828,0-1.5,0.672-1.5,1.5s0.672,1.5,1.5,1.5h3c0.828,0,1.5-0.672,1.5-1.5S34.328,16,33.5,16z     M28.561,26.439C28.289,26.168,27.914,26,27.5,26c-0.828,0-1.5,0.672-1.5,1.5c0,0.414,0.168,0.789,0.439,1.06l2,2    C28.711,30.832,29.086,31,29.5,31c0.828,0,1.5-0.672,1.5-1.5c0-0.414-0.168-0.789-0.439-1.061L28.561,26.439z M17.5,29    c-0.829,0-1.5,0.672-1.5,1.5v3c0,0.828,0.671,1.5,1.5,1.5s1.5-0.672,1.5-1.5v-3C19,29.672,18.329,29,17.5,29z M17.5,7    C11.71,7,7,11.71,7,17.5S11.71,28,17.5,28S28,23.29,28,17.5S23.29,7,17.5,7z M17.5,25c-4.136,0-7.5-3.364-7.5-7.5    c0-4.136,3.364-7.5,7.5-7.5c4.136,0,7.5,3.364,7.5,7.5C25,21.636,21.636,25,17.5,25z"></path></svg></label><label id="toggle-label-dark" for="darkmode-toggle" tabIndex="-1"><svg xmlns="http://www.w3.org/2000/svg" xmlnsXlink="http://www.w3.org/1999/xlink" version="1.1" id="nightIcon" x="0px" y="0px" viewBox="0 0 100 100" style="enable-background='new 0 0 100 100'" xmlSpace="preserve"><title>Dark mode</title><path d="M96.76,66.458c-0.853-0.852-2.15-1.064-3.23-0.534c-6.063,2.991-12.858,4.571-19.655,4.571  C62.022,70.495,50.88,65.88,42.5,57.5C29.043,44.043,25.658,23.536,34.076,6.47c0.532-1.08,0.318-2.379-0.534-3.23  c-0.851-0.852-2.15-1.064-3.23-0.534c-4.918,2.427-9.375,5.619-13.246,9.491c-9.447,9.447-14.65,22.008-14.65,35.369  c0,13.36,5.203,25.921,14.65,35.368s22.008,14.65,35.368,14.65c13.361,0,25.921-5.203,35.369-14.65  c3.872-3.871,7.064-8.328,9.491-13.246C97.826,68.608,97.611,67.309,96.76,66.458z"></path></svg></label></div></div><div class="center"><div class="page-header"><div class="popover-hint"><h1 class="article-title ">13. WWW,  HTTP</h1><p class="content-meta ">Dec 23, 2024, 26 min read</p></div></div><article class="popover-hint"><blockquote class="callout" data-callout="info">
<div class="callout-title">
                  <div class="callout-icon"><svg xmlns="http://www.w3.org/2000/svg" width="100%" height="100%" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="10"></circle><line x1="12" y1="16" x2="12" y2="12"></line><line x1="12" y1="8" x2="12.01" y2="8"></line></svg></div>
                  <div class="callout-title-inner"><p>충남대학교 컴퓨터공학과 김상하 교수님의 &quot;컴퓨터 네트워크&quot; 강의를 필기한 내용입니다. </p></div>
                  
                </div>
</blockquote>
<blockquote class="callout" data-callout="warning">
<div class="callout-title">
                  <div class="callout-icon"><svg xmlns="http://www.w3.org/2000/svg" width="100%" height="100%" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="m21.73 18-8-14a2 2 0 0 0-3.48 0l-8 14A2 2 0 0 0 4 21h16a2 2 0 0 0 1.73-3Z"></path><line x1="12" y1="9" x2="12" y2="13"></line><line x1="12" y1="17" x2="12.01" y2="17"></line></svg></div>
                  <div class="callout-title-inner"><p>다소 잘못된 내용과 구어적 표현 이 포함되어 있을 수 있습니다. </p></div>
                  
                </div>
</blockquote>
<h2 id="world-wide-web">World Wide Web<a aria-hidden="true" tabindex="-1" href="#world-wide-web" class="internal"> §</a></h2>
<ul>
<li><strong>www</strong> : 전 세계적으로 연결된 정보 저장소</li>
</ul>
<h3 id="client-server">Client, Server<a aria-hidden="true" tabindex="-1" href="#client-server" class="internal"> §</a></h3>
<ul>
<li>익숙한내용이니까 금방금방 넘어가자고</li>
</ul>
<p><img src="../../../../gardens/network/originals/comnet.fall.2021.cse.cnu.ac.kr/images/13_1084786578a1428cb81b8c7657e04338/image1.png" alt="%E1%84%8B%E1%85%B5%E1%84%85%E1%85%A9%E1%86%AB13%20-%20WWW,%20HTTP%201084786578a1428cb81b8c7657e04338/image1.png"/></p>
<ul>
<li>이런식으로 Client와 Server로 구성되어 있고 Server가 Web Page를 가지고 있으며 Client가 그걸 요청하면 전달해주는 식으로 돌아간다</li>
</ul>
<p><img src="../../../../gardens/network/originals/comnet.fall.2021.cse.cnu.ac.kr/images/13_1084786578a1428cb81b8c7657e04338/image2.png" alt="%E1%84%8B%E1%85%B5%E1%84%85%E1%85%A9%E1%86%AB13%20-%20WWW,%20HTTP%201084786578a1428cb81b8c7657e04338/image2.png"/></p>
<ul>
<li>그리고 이건 Client쪽 <strong>Browser</strong>의 구조를 나타낸건데</li>
<li>Web Document들을 HTTP, FTP 등의 <strong>Client Protocol</strong>을 이용해 가져오고</li>
<li>그걸 HTML, JS 등을 해석하는 <strong>Interpreter</strong>을 통해 화면에 뿌리게 되는데</li>
<li>이때 어떤 프로토콜을 이용할건지, 그리고 그걸 받아서 어떤 인터프리터를 사용할건지 연결해주는 것이 <strong>Controller</strong>가 하는 역할이다</li>
</ul>
<h3 id="url">URL<a aria-hidden="true" tabindex="-1" href="#url" class="internal"> §</a></h3>
<ul>
<li><strong>URL(Uniform Resource Locator)</strong> 는 Client가 자기가 원하는 정보가 Server의 정확히 어디에 있는지, 그리고 어떻게 가져와야 하는지를 명시하는 방법이다</li>
</ul>
<p><img src="../../../../gardens/network/originals/comnet.fall.2021.cse.cnu.ac.kr/images/13_1084786578a1428cb81b8c7657e04338/image3.png" alt="%E1%84%8B%E1%85%B5%E1%84%85%E1%85%A9%E1%86%AB13%20-%20WWW,%20HTTP%201084786578a1428cb81b8c7657e04338/image3.png"/></p>
<ul>
<li>지긋지긋하제?</li>
<li>제일 먼저 <strong>Protocol</strong>을 명시한다 - HTTP인지, HTTPS인지 등</li>
<li>그리고 <strong>Host</strong>는 숫자 혹은 DNS로 표현된 서버의 IP를 나타낸다</li>
<li><strong>Port</strong>는 말그대로 포트번호고</li>
<li><strong>Path</strong>는 서버 내에서의 디렉토리 구조상에서의 위치를 나타내는 것</li>
</ul>
<h3 id="cookie">Cookie<a aria-hidden="true" tabindex="-1" href="#cookie" class="internal"> §</a></h3>
<ul>
<li>얘가 뭔지는 이미 알테니까 얘를 왜쓰는지를 중점적으로 보면</li>
<li>HTTP는 Stateless - Client의 상태를 저장하지 않음. 즉, Client가 누구인지, 이전에는 어떤 요청을 해왔는지 등을 Server는 저장하지 않기 때문에 모른다 - 이기 때문에</li>
<li>작은 데이터 조각인 <strong>Cookie</strong>를 Client가 Server에게 요청을 보낼때 같이 보내 자신의 State를 알려주게 되는 것</li>
<li>따라서 다음과 같은 용도로 사용될 수 있음
<ol>
<li><strong>Session Management</strong> : Client와 Server가 교류하는 기간을 하나의 Session이라고 한다면 해당 Session을 컨트롤하는 용도나</li>
<li><strong>Personalization</strong> : Server로 하여금 Client 각각을 식별하게 하는 용도니</li>
<li><strong>Tracking</strong> : Client의 행동을 기록하고 분석하는 용도로 쓰이게 된다</li>
</ol>
</li>
</ul>
<h2 id="web-documents">Web Documents<a aria-hidden="true" tabindex="-1" href="#web-documents" class="internal"> §</a></h2>
<ul>
<li>Web Document는 Web에서 다루는 문서들을 의미하는 건데 이것도 아는거니까 금방금방 지나가자고</li>
</ul>
<h3 id="static-document">Static Document<a aria-hidden="true" tabindex="-1" href="#static-document" class="internal"> §</a></h3>
<ul>
<li>Server에서도 별다른 작업을 하지 않고 Client에서도 받은 다음에 화면에 뿌려주기만 하는 문서</li>
<li>뭐 Raw HTML 파일 이 여기에 해당한다고 할 수 있다 - HTML파일을 요청하면 그냥 Server에서도 요청받은 HTML파일 주면 되고 Client에서도 그거 그냥 렌더링하면 되니까</li>
<li>그래서 Client는 Static Document를 요청할때마다 같은 결과물을 받게 된다</li>
</ul>
<h3 id="dynamic-document">Dynamic Document<a aria-hidden="true" tabindex="-1" href="#dynamic-document" class="internal"> §</a></h3>
<ul>
<li>클라이언트의 요청에 대해 Server가 동적으로 Document를 만들어서 제공해주는 문서</li>
<li>뭐 php의 경우에도 그렇고 전에 DB 텀프할때도 nodejs로 html 생성해서 응답했자네 - 이런거 말하는거임</li>
<li>따라서 Client는 Dynamic Document를 요청할때마다 그 결과물이 달라질 수 있다</li>
</ul>
<h3 id="active-document">Active Document<a aria-hidden="true" tabindex="-1" href="#active-document" class="internal"> §</a></h3>
<ul>
<li>이건 Client의 요청으로 Server가 보내준 파일이 Server에서 렌더링해서 준게 아니고 Client가 직접 렌더링해야되는 문서를 말한다</li>
<li>JS 말하는거같은데 좀 다른거같다 - 수업때는 Java Applet이라는거 알려주던데</li>
</ul>
<p><img src="../../../../gardens/network/originals/comnet.fall.2021.cse.cnu.ac.kr/images/13_1084786578a1428cb81b8c7657e04338/image4.png" alt="%E1%84%8B%E1%85%B5%E1%84%85%E1%85%A9%E1%86%AB13%20-%20WWW,%20HTTP%201084786578a1428cb81b8c7657e04338/image4.png"/></p>
<ul>
<li>위 그림처럼 요청에 대해 Applet을 응답하고 이것을 Client 쪽에서 실행시켜서 결과물을 얻는댄다</li>
</ul>
<h2 id="http">HTTP<a aria-hidden="true" tabindex="-1" href="#http" class="internal"> §</a></h2>
<ul>
<li><strong>HTTP(HyperText Transfer Protocol)</strong> 은 Web Document를 통신하기에 최적화된 Application Layer Protocol이다</li>
<li>HTTP는 FTP와 SMTP를 합쳐놓은 것과 비슷하게 작동하는데, 몇가지 차이점이 있다
<ol>
<li>우선 파일 전송이 가능하다는 점에서는 HTTP와 FTP가 동일하지만, HTTP는 TCP Connection을 하나만 하는 반면에 FTP는 두개를 한다</li>
<li>그리고 (파일을 전송하더라도 문서화하여 전송하기 때문에)문서의 형태로 통신한다는 점에서는 SMTP와 유사하지만 SMTP는 보통 Mail Server를 거쳐서 통신하는 경우가 많지만 HTTP는 목적지 서버로 바로 달린다는 점에서 차이점이 있다</li>
</ol>
<ul>
<li>근데 강의시간에서는 PDF에서 소개된 SMTP와의 차이점은 부정확하댄다 - SMTP도 서버로 바로 보낼 수 있기 때문</li>
<li>싱하형이 말한 FTP 혹은 SMTP와 HTTP의 가장 큰 차이점 은 FTP나 SMTP의 경우에는 Application Layer Level에서 Command를 사용해 Connection을 맺고 할일을 한 뒤에 또 Command를 이용해 Termination을 하게 되지만 HTTP에서는 그런거 없이 Command도 보내는 메시지에 포함시켜 한번의 통신으로 결과물을 받아낸다는 것이다</li>
<li>그리고 이러한 성질이 HTTP에서의 Stateless와 연결되는데 FTP나 SMTP의 경우에는 Command가 오가며 연속적인 흐름이 존재하지만 HTTP는 한번 왔다갔다하면 끝이기 때문에 이러한 Stateless가 생기게 된다더라</li>
</ul>
</li>
<li>알고있었겟지만 HTTP는 TCP를 이용하고 Well known port로는 80번을 사용한다</li>
</ul>
<h3 id="http-transaction">HTTP Transaction<a aria-hidden="true" tabindex="-1" href="#http-transaction" class="internal"> §</a></h3>
<p><img src="../../../../gardens/network/originals/comnet.fall.2021.cse.cnu.ac.kr/images/13_1084786578a1428cb81b8c7657e04338/image5.png" alt="%E1%84%8B%E1%85%B5%E1%84%85%E1%85%A9%E1%86%AB13%20-%20WWW,%20HTTP%201084786578a1428cb81b8c7657e04338/image5.png"/></p>
<ul>
<li>반복학습이 짱이야 그지</li>
<li>일단 웹프에서 배운 내용 다시 짚어보면 HTTP의 메시지 포맷은 요청의 경우 Request Line, 응답의 경우에는 Status Line이 드가고 그 다음부터는 둘 다 Header가 드간 뒤 한칸 공백을 두고 Body가 드가게 된다</li>
</ul>
<p><img src="../../../../gardens/network/originals/comnet.fall.2021.cse.cnu.ac.kr/images/13_1084786578a1428cb81b8c7657e04338/image6.png" alt="%E1%84%8B%E1%85%B5%E1%84%85%E1%85%A9%E1%86%AB13%20-%20WWW,%20HTTP%201084786578a1428cb81b8c7657e04338/image6.png"/></p>
<ul>
<li>그리고 <strong>Request Line</strong>의 경우에는 METHOD URL HTTP_VER이런식으로HTTP 메소드와 URL, HTTP 버전이 공백을 두고 한줄에 위치하고</li>
<li><strong>Status Line</strong>의 경우에는 HTTP_VER STATUS_CODE STATUS_MSG 이런식으로 HTTP버전과 상태코드, 상태메시지가 공박을 두고 한줄에 들어가게 된다</li>
<li>이제 웹프에서와는 좀 다른 시각으로 이 메시지들을 보면</li>
<li>SMTP와 좀 비교를 해보면 만일 HTTP 메시지를 SMTP로 바꿔보면 Request Line에 있던것들이 Command로 보내질 수 있고 Status Line에 있던애들이 Responce로 보내질 수 있으며 나머지 Header와 Body는 메일의 Content로 들어가는 식으로 연관지을 수 있다
<ul>
<li>SMTP에서 무슨 요청을 보낼건지와 어디로 보낼건지 등을 Command로 보냈듯이 HTTP의 경우에는 그런것들이 다 첫번째 줄에 들어가게 되기 때문</li>
</ul>
</li>
<li>즉, 위에서 말한 HTTP는 SMTP와는 다르게 Command나 Response까지 전부 하나의 메시지에 합쳤다는게 바로 이소리임</li>
<li>Method와 Status Code에 대해서는 너가 아는 정도로도 충분하다 - 모르면 검색해</li>
</ul>
<h3 id="header">Header<a aria-hidden="true" tabindex="-1" href="#header" class="internal"> §</a></h3>
<p><img src="../../../../gardens/network/originals/comnet.fall.2021.cse.cnu.ac.kr/images/13_1084786578a1428cb81b8c7657e04338/image7.png" alt="%E1%84%8B%E1%85%B5%E1%84%85%E1%85%A9%E1%86%AB13%20-%20WWW,%20HTTP%201084786578a1428cb81b8c7657e04338/image7.png"/></p>
<ul>
<li>HTTP에서 요청과 응답에 대한 다양한 정보들을 Header에 담게 되는데</li>
<li>위처럼 HEADER_NAME: HEADER_VALUE의 포맷으로 명시된다</li>
<li>헤더의 종류에는 4가지가 있다는것 정도와 각각의 대표적 예시 몇개 챙거가거라</li>
<li><strong>General Header</strong> : 특정하게 분류하지 않은 공통적인 내용
<ul>
<li><strong>Date</strong> : 날짜</li>
<li><strong>MIME-version</strong> : HTTP 메시지의 경우 7-NVT ASCII만을 송수신 할 수 있기 때문에 SMTP에서처럼 Non-printable bitstream은 인코딩이 드간다 - 이때 사용되는 MIME의 버전을 나타내는 것</li>
</ul>
</li>
<li><strong>Request Header</strong> : Client가 보내는 요청에 대한 정보들
<ul>
<li><strong>Accept</strong> : Client가 원하는(받아들일 수 있는) 파일 형식</li>
<li><strong>Authorization</strong> : 요청에 필요한 권한을 담는 부분</li>
<li><strong>Host</strong> : 요청을 받아줄 Server의 host와 port</li>
</ul>
</li>
<li><strong>Response Header</strong> : Server가 보내는 응답에 대한 정보들
<ul>
<li><strong>Server</strong> : 응답을 보내는 서버에 대한 정보</li>
</ul>
</li>
<li><strong>Entity Header</strong> : 응답으로 보내는 Body에 대한 구체적인 정보들
<ul>
<li><strong>Content-length</strong> : 응답 Body의 길이</li>
<li><strong>Content-type</strong> : 응답 Body의 파일 파입 - 웹프에서 말한것처럼 파일을 처리하는 방법만 알려주면 모든 종류의 파일을 송수신하고 받아서 사용할 수 있게 할 수 있다는데 이부분이 그거임 - 파일의 타입을 명시해서 Client가 bitstream을 어떻게 처리해야될지 알려주게 됨</li>
</ul>
</li>
</ul>
<p><img src="../../../../gardens/network/originals/comnet.fall.2021.cse.cnu.ac.kr/images/13_1084786578a1428cb81b8c7657e04338/image8.png" alt="%E1%84%8B%E1%85%B5%E1%84%85%E1%85%A9%E1%86%AB13%20-%20WWW,%20HTTP%201084786578a1428cb81b8c7657e04338/image8.png"/></p>
<ul>
<li>예시 - 읽어보고 그렇구나만 해주면 됨</li>
</ul>
<h3 id="persistent-vs-non-persistent">Persistent VS Non-persistent<a aria-hidden="true" tabindex="-1" href="#persistent-vs-non-persistent" class="internal"> §</a></h3>
<ul>
<li>일단 <strong>Persistent Strategy</strong>는 한번의 Request - Response에서 한번의 TCP Connection을 맺었다가 끊는 것을 말하는데</li>
<li>당연히 이건 비효율적 이다 - 왜냐하면 TCP는 기본적으로 Three Handshake를 해서 Connection을 한 다음에 데이터를 전송하고, 전송한 다음에는 Terminate를 하기 때문에 데이터 전송 앞뒤로 추가적인 과정이 붙어 전송세션을 오래 끄는게 이득이고</li>
<li>앞에서 배운것처럼 TCP는 Slow Start를 하기 때문에 전송속도가 느리게 시작해서 점차 빨라지게 된다 - 따라서 전송을 짧게 여러번 하면 Slow Start를 여러번 하게 되므로 그만큼 평균속도는 느려지는 것</li>
<li>그래서 <strong>Non Persistent Strategy</strong>는 TCP Connection을 한번 하고 나면 Request - Response를 여러번 하고, 만일 일정기간동안 Request - Response가 없으면 그때 Terminate되는 Time out 전략을 쓰는 것을 의미한다</li>
<li>저번에 어떤새끼가 블로그에서 HTTP는 한번의 Request - Response에서 한번의 TCP Connection을 맺었다가 끊는다 라고 Persistent 전략을 사용하는 것으로 말해놨는데</li>
<li>저것도 어느정도는 맞는말일수도 있지만 HTTP1.1부터는 Non Persistent를 Default로 하고 있다</li>
</ul>
<h3 id="proxy-server">Proxy Server<a aria-hidden="true" tabindex="-1" href="#proxy-server" class="internal"> §</a></h3>
<ul>
<li>HTTP는 <strong>Proxy Server</strong>기능을 제공하는데 이건 원래 서버의 기능을 대리해주는 서버를 말한다</li>
<li>이게 뭔말이냐면</li>
<li>Client A가 B를 거쳐서 Server C에게 요청을 하고 받는 과정에서</li>
<li>B는 C가 보내는 응답을 저장해놓고 있다가</li>
<li>또 다른 Client D가 B를 거쳐서 C에게 요청을 하면</li>
<li>그 요청이 C까지 안가고 B가 저장해놓은 응답을 보내주는 것을 말함</li>
<li>즉, <strong>Proxy Server</strong>는 원래 Server의 응답을 저장해놨다가 누군가가 요청을 해오면 원래의 Server까지 안갔다와도 되게끔 Proxy Server가 대신 응답함으로써 응답을 좀 더 빨리 받을 수 있게 하는 것을 의미한다</li>
<li>당연히 이 기능을 이용할때도 DNS의 Authorize기능처럼 해당 응답이 원래의 Server가 아니고 Proxy Server에서 왔음을 Client에게 알리게 된다</li>
</ul>
<h2 id="http2">HTTP/2<a aria-hidden="true" tabindex="-1" href="#http2" class="internal"> §</a></h2>
<h3 id="problems-of-http-1x">Problems of HTTP 1.x<a aria-hidden="true" tabindex="-1" href="#problems-of-http-1x" class="internal"> §</a></h3>
<ul>
<li>HTTP 1.x의 문제점은 한번에 하나의 Request - Response가 가능하다는 것이다</li>
<li>뭐 HTTP 1.1부터는 Non Persistent가 됐다고 하더라도 이건 TCP를 연결하고 끊는 시간 낭비를 줄이는 정도이고</li>
<li>하나의 Request를 보내고 나면 그것의 Response가 올때까지 Client는 추가적인 요청을 할 수가 없다</li>
<li>따라서 하나의 웹페이지를 구성하기 위해서는 많은 Resource들이 필요한데 얘네들을 Parallel하게 보내지 못하고 Sequential하게 보내기 때문에 필요한 Resource들을 모두 요청하고 받는데까지 시간이 오래걸려 웹페이지 로딩이 오래걸리게 되는 것</li>
<li>HTTP에서도 Parallel하게 요청을 보낼 수 있는 방법이 있긴 하다 - TCP Connection을 여러개 맺으면 Parallel하게 보낼 수는 있지만 TCP는 연결할때 Buffer도 준비해야 하고 Handshake도 해야 하는 등 사전준비가 많이 필요한 작업임 - 따라서 TCP Connection을 여러개 맺는 것으로도 속도 저하는 해결하지는 못한다</li>
<li>이런 HTTP 1.x에서의 Parallel하게 요청을 보내고 받지 못하는 문제를 <strong>Head-of-Line Blocking</strong>이라고 한다</li>
</ul>
<h3 id="http2-1">HTTP/2<a aria-hidden="true" tabindex="-1" href="#http2-1" class="internal"> §</a></h3>
<ul>
<li>위와 같은 배경에서 HTTP/2가 등장하게 되는데</li>
<li>HTTP/2를 설계할때 가장 중점적이 되었던 것은 아래의 세 가지 이다
<ol>
<li>기존의 HTTP Message Interface가 바뀌어서는 안된다는 것
<ul>
<li>즉, HTTP 1.x에서의 HTTP Method, Status Code, URI, Header Field등이 이전과 동일해 HTTP Protocol을 이용하는 입장에서는 HTTP 1.x과 HTTP/2간의 호환성 문제가 생기면 안된다는 것</li>
</ul>
</li>
<li>Parallel Request - Response가 가능해야 된다는 것</li>
<li>TCP Connection은 기존과 동일하게 하나만 유지할 것</li>
</ol>
</li>
</ul>
<h3 id="request---response-multiplexing">Request - Response Multiplexing<a aria-hidden="true" tabindex="-1" href="#request---response-multiplexing" class="internal"> §</a></h3>
<ul>
<li>이제 위와 같은 문제점들을 어떻게 해결했는지 확인해보자고</li>
</ul>
<p><img src="../../../../gardens/network/originals/comnet.fall.2021.cse.cnu.ac.kr/images/13_1084786578a1428cb81b8c7657e04338/image9.png" alt="%E1%84%8B%E1%85%B5%E1%84%85%E1%85%A9%E1%86%AB13%20-%20WWW,%20HTTP%201084786578a1428cb81b8c7657e04338/image9.png"/></p>
<ul>
<li>Parallel과 Single TCP Connection을 모두 잡는 것의 핵심은 <strong>Multiplexing</strong>을 이용하는 것이다</li>
<li>즉, Parallel하게 정보를 전송할 수 있도록 <strong>Bidirectional Stream</strong>을 여러개 제공하여 각 Stream에 병렬적으로 <strong>Message</strong>를 송수신 할 수 있게 하는 것</li>
<li>그리고 Stream들을 하나로 모으는 <strong>Multiplexing</strong>을 한 다음 수신지에 도착해서는 그것을 다시 <strong>Demultiplexing</strong>하여 양 끝단에서는 마치 TCP Connection을 여러개 맺은 것 같은 착각에 빠지게 한다</li>
<li>그래서 위 그림처럼 되는거임 - 여러개의 Stream에서 나온 <strong>Frame</strong>들이 일렬로 쭉 들어선 모양으로 <strong>Multiplexing</strong>되어 Single TCP Connection을 타고 가게 되고 도착해서는 다시 <strong>Demultiplexing</strong>되는 것
<ul>
<li>저런식으로 여러개의 Stream에서 나온 Frame들이 일렬로 사이사이 끼어들어간 형태로 전송되는 것을 <strong>Interleaved Sequence of Frames</strong>라고 표현한다</li>
</ul>
</li>
<li>근데 위 그림에서 보이는 것처럼 Message단위로 전송되는게 아니라 이게 작게 Disintegrate되어서 <strong>Frame</strong>단위로 송신하고, 수신한 뒤에는 Frame들을 Reassemble하여 원래의 Message로 복원하는 작업을 하게 됨</li>
</ul>
<p><img src="../../../../gardens/network/originals/comnet.fall.2021.cse.cnu.ac.kr/images/13_1084786578a1428cb81b8c7657e04338/image10.png" alt="%E1%84%8B%E1%85%B5%E1%84%85%E1%85%A9%E1%86%AB13%20-%20WWW,%20HTTP%201084786578a1428cb81b8c7657e04338/image10.png"/></p>
<p><img src="../../../../gardens/network/originals/comnet.fall.2021.cse.cnu.ac.kr/images/13_1084786578a1428cb81b8c7657e04338/image11.png" alt="%E1%84%8B%E1%85%B5%E1%84%85%E1%85%A9%E1%86%AB13%20-%20WWW,%20HTTP%201084786578a1428cb81b8c7657e04338/image11.png"/></p>
<ul>
<li>그럼 위에있는 그림도 어느정도 이해가 갈거임 - 한개의 <strong>Connection</strong>안에 여러개의 <strong>Stream</strong>이 있고 해당 Stream으로 양방향으로 Request와 Response가 오가는 형태</li>
<li>따라서 <strong>Message</strong>들을 어떻게 <strong>Frame</strong>으로 잘라서 Multiplexing하냐가 관건인데 이를 담당하는 곳이 바로 <strong>Binary Framing Layer</strong>이다</li>
</ul>
<h3 id="용어정리">용어정리<a aria-hidden="true" tabindex="-1" href="#용어정리" class="internal"> §</a></h3>
<ul>
<li><strong>Binary Framing Layer</strong>를 설명하기에 앞서 용어정리를 딱 하고 넘어가면
<ul>
<li><strong>Message</strong>는 HTTP API에서 사용하는 그 메세지(Line, Header, Body가 7-bit ASCII로 적혀있는)이고
<ul>
<li>즉, 하나의 완성된 Request혹은 Response를 말하는거임</li>
</ul>
</li>
<li>그리고 <strong>Stream</strong>들에 의해 Message들이 Parallel하게 양방향으로 오가고</li>
<li><strong>Frame</strong>은 Multiplexing을 하기 위해 Message를 여러 조각으로 자른 것을 의미한다
<ul>
<li>또한 Multiplexing과 Demultiplexing을 하기 위해서는 이 Frame이 어느 Stream에서 왔는지 알아야 하기 때문에 <strong>Stream Identifier</strong>가 Frame마다 붙게 된다</li>
<li>이 Frame이 HTTP/2 Communication의 제일 작은 단위가 됨</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="binary-framing-layer">Binary Framing Layer<a aria-hidden="true" tabindex="-1" href="#binary-framing-layer" class="internal"> §</a></h3>
<p><img src="../../../../gardens/network/originals/comnet.fall.2021.cse.cnu.ac.kr/images/13_1084786578a1428cb81b8c7657e04338/image12.png" alt="%E1%84%8B%E1%85%B5%E1%84%85%E1%85%A9%E1%86%AB13%20-%20WWW,%20HTTP%201084786578a1428cb81b8c7657e04338/image12.png"/></p>
<ul>
<li>얘는 일단 뭐 이름부터가 <strong>Layer</strong>인 것 처럼 HTTP/2에서의 Sublayer라고 보면 된다 - HTTP 안에서 하부에 위치해있는 Layer
<ul>
<li>따라서 HTTP 상단부를 <strong>HTTP API</strong>라고 부르고 <strong>Binary Framing Layer</strong>는 아래의 <strong>Socket Layer</strong>와 <strong>HTTP API</strong>사이에 끼어있는 계층이 되는 셈</li>
</ul>
</li>
<li>얘가 하는 일은 크게 세가지 인데</li>
</ul>
<ol>
<li>Message를 잘라서 Frame으로 Disintegrate하고</li>
<li>Frame들을 Binary로 변환하는 일</li>
<li>위에서 말한 Streaming과 Multiplexing</li>
</ol>
<ul>
<li>우선 왜 Frame들을 Binary로 바꾸는 짓을 하나면
<ul>
<li>기존의 Message는 Text-Driven 7-bit ASCII이고 CRLF같은 Delimiter로 한줄한줄이 구분되어 있는데</li>
<li>이것을 컴퓨터가 알아듣기 위해서는 마치 Interprete하는 것 같은 과정이 필요하다 - 따라서 Binary로 표현하는 것이 컴퓨터 입장에서는 Compact 한 Representation인 것</li>
</ul>
</li>
<li>그리고 위에서 Multiplexing하기 위해 Message들을 Frame단위로 자른다고 했는데 이걸 으케하냐면
<ul>
<li>Header는 하나의 Frame안에 다 우겨넣고</li>
<li>Body는 크기가 클 경우만 Frame들로 소분하게 된다</li>
</ul>
</li>
<li>그래서 종합해보면 <strong>Binary Framing Layer</strong>는 HTTP 메세지들이 어떻게 캡슐화되는지(<strong>Encapsulated</strong>), 그리고 전송되는지(<strong>Transfered</strong>)를 담당한다고 생각할 수 있다</li>
<li>HTTP/2를 이렇게 설계함으로써 HTTP 1.x만을 지원하는 기기와는 통신이 불가능하다는 단점이 있지만</li>
<li>HTTP API의 변화는 없기 때문에 HTTP를 사용하는 Application에의 변화는 불필요하다는 장점을 취하게 되는 것</li>
</ul>
<h3 id="stream-prioritization">Stream Prioritization<a aria-hidden="true" tabindex="-1" href="#stream-prioritization" class="internal"> §</a></h3>
<p><img src="../../../../gardens/network/originals/comnet.fall.2021.cse.cnu.ac.kr/images/13_1084786578a1428cb81b8c7657e04338/image13.png" alt="%E1%84%8B%E1%85%B5%E1%84%85%E1%85%A9%E1%86%AB13%20-%20WWW,%20HTTP%201084786578a1428cb81b8c7657e04338/image13.png"/></p>
<ul>
<li>근데 이제 원래의 메세지를 Frame단위로 쪼개서 보내게 되면 순서가 중요한 경우에는 받는놈 입장에서 뭐가 앞에 있었고 뭐가 뒤에 있었는지 모른다</li>
<li>그래서 위처럼 선후관계를 Edge로 하고, 각각의 Frame에 우선순위가 존재하는 <strong>Prioritization Tree</strong>를 각 Stream마다 두게 되고 그것을 이용해 Receive를 하게 된다</li>
<li>뭐 어떻게 그리는지는 신경쓰지 마셈</li>
</ul>
<h3 id="server-push">Server Push<a aria-hidden="true" tabindex="-1" href="#server-push" class="internal"> §</a></h3>
<p><img src="../../../../gardens/network/originals/comnet.fall.2021.cse.cnu.ac.kr/images/13_1084786578a1428cb81b8c7657e04338/image14.png" alt="%E1%84%8B%E1%85%B5%E1%84%85%E1%85%A9%E1%86%AB13%20-%20WWW,%20HTTP%201084786578a1428cb81b8c7657e04338/image14.png"/></p>
<ul>
<li>HTTP는 <strong>Server Push</strong>라는 기능도 제공하는데 이게 뭐냐면</li>
<li>Client가 요청을 했을 때 요청한 것 외에도 추가적으로 필요할거 같은 것을 Server가 추가적으로 보내주는 것</li>
<li>수동적인 포지션에 있는 Server가 요청받지 않은 것을 자의적으로 파일을 보내주기 때문에 <strong>Server Push</strong>라는 이름이 붙은거라고 생각하면 됨</li>
<li>다르게 말해보면 Request 하나에 대해 Response를 여러개 보내는 것이라고 말할 수도 있는 것</li>
<li>서버가 클라이언트가 필요한것을 어케 아냐고 궁금증을 갖지 마셈 - 뭐 적당히 알아낸댄다</li>
<li>이렇게 하는 것의 이점은 Client가 요청을 하지 않아도 Server가 연관된 Resource들을 같이 보내주기 때문에 그것들에 대한 요청을 Client가 하지 않아도 되고, 따라서 통신의 Latency가 더 줄어들게 된다</li>
</ul>
<h3 id="header-compression">Header Compression<a aria-hidden="true" tabindex="-1" href="#header-compression" class="internal"> §</a></h3>
<p><img src="../../../../gardens/network/originals/comnet.fall.2021.cse.cnu.ac.kr/images/13_1084786578a1428cb81b8c7657e04338/image15.png" alt="%E1%84%8B%E1%85%B5%E1%84%85%E1%85%A9%E1%86%AB13%20-%20WWW,%20HTTP%201084786578a1428cb81b8c7657e04338/image15.png"/></p>
<ul>
<li>얘는 자주 쓰이는 Header Field와 Value 쌍들을 테이블에 저장해놓고 해당 Header 쌍에 대해서는 Header쌍 전체를 보내는 것이 아니라 그 인덱스만 보내서 Header의 크기를 획기적으로 줄이는 방법이다</li>
<li>현재 통신과 상관없이 자주 사용되는 Header 쌍에 대해서는 <strong>Static Table</strong>에 저장이 되어 있고</li>
<li>현재 통신에 한정에서 자주 사용되는 Header 쌍은 <strong>Dynamic Table</strong>에 동적으로 추가가 되는데</li>
<li>위의 예제를 보면 method: GET같은 경우에는 경장히 자주 사용되는 Field - Value 이기 때문에 Static Table에 저장이 되어 있고</li>
<li>host: example.com은 다른 통신에서는 host값이 달라지기 때문에 흔하게 사용된다고 할 수는 없지만 적어도 현재의 통신에서는 여러 Request에 걸쳐 host가 바뀌지 않을 것이기 때문에 Dynamic Table에 드가게 되는 것</li>
<li>따라서 이러한 테이블에 근거해서 왼쪽의 Request Header가 오른쪽처럼 축약되는 것이다</li>
<li>근데 위의 예시를 보면 Table에 들어있지 않은 Header 쌍에 대해서는 <strong>Huffman Code</strong>라는 것을 이용해서 표현되게 되는데 이게 뭔지는 궁금하면 찾아보고 그냥 저걸 이용해서 Table에 있지 않은 Header쌍에 대해서도 크기를 줄일 수 있다는 것 정도만 알아두거라</li>
</ul></article></div><div class="right sidebar"><div class="graph "><h3>Graph View</h3><div class="graph-outer"><div id="graph-container" data-cfg="{&quot;drag&quot;:true,&quot;zoom&quot;:true,&quot;depth&quot;:1,&quot;scale&quot;:1.1,&quot;repelForce&quot;:0.5,&quot;centerForce&quot;:0.3,&quot;linkDistance&quot;:30,&quot;fontSize&quot;:0.6,&quot;opacityScale&quot;:1,&quot;showTags&quot;:true,&quot;removeTags&quot;:[]}"></div><svg version="1.1" id="global-graph-icon" xmlns="http://www.w3.org/2000/svg" xmlnsXlink="http://www.w3.org/1999/xlink" x="0px" y="0px" viewBox="0 0 55 55" fill="currentColor" xmlSpace="preserve"><path d="M49,0c-3.309,0-6,2.691-6,6c0,1.035,0.263,2.009,0.726,2.86l-9.829,9.829C32.542,17.634,30.846,17,29,17
	s-3.542,0.634-4.898,1.688l-7.669-7.669C16.785,10.424,17,9.74,17,9c0-2.206-1.794-4-4-4S9,6.794,9,9s1.794,4,4,4
	c0.74,0,1.424-0.215,2.019-0.567l7.669,7.669C21.634,21.458,21,23.154,21,25s0.634,3.542,1.688,4.897L10.024,42.562
	C8.958,41.595,7.549,41,6,41c-3.309,0-6,2.691-6,6s2.691,6,6,6s6-2.691,6-6c0-1.035-0.263-2.009-0.726-2.86l12.829-12.829
	c1.106,0.86,2.44,1.436,3.898,1.619v10.16c-2.833,0.478-5,2.942-5,5.91c0,3.309,2.691,6,6,6s6-2.691,6-6c0-2.967-2.167-5.431-5-5.91
	v-10.16c1.458-0.183,2.792-0.759,3.898-1.619l7.669,7.669C41.215,39.576,41,40.26,41,41c0,2.206,1.794,4,4,4s4-1.794,4-4
	s-1.794-4-4-4c-0.74,0-1.424,0.215-2.019,0.567l-7.669-7.669C36.366,28.542,37,26.846,37,25s-0.634-3.542-1.688-4.897l9.665-9.665
	C46.042,11.405,47.451,12,49,12c3.309,0,6-2.691,6-6S52.309,0,49,0z M11,9c0-1.103,0.897-2,2-2s2,0.897,2,2s-0.897,2-2,2
	S11,10.103,11,9z M6,51c-2.206,0-4-1.794-4-4s1.794-4,4-4s4,1.794,4,4S8.206,51,6,51z M33,49c0,2.206-1.794,4-4,4s-4-1.794-4-4
	s1.794-4,4-4S33,46.794,33,49z M29,31c-3.309,0-6-2.691-6-6s2.691-6,6-6s6,2.691,6,6S32.309,31,29,31z M47,41c0,1.103-0.897,2-2,2
	s-2-0.897-2-2s0.897-2,2-2S47,39.897,47,41z M49,10c-2.206,0-4-1.794-4-4s1.794-4,4-4s4,1.794,4,4S51.206,10,49,10z"></path></svg></div><div id="global-graph-outer"><div id="global-graph-container" data-cfg="{&quot;drag&quot;:true,&quot;zoom&quot;:true,&quot;depth&quot;:-1,&quot;scale&quot;:0.9,&quot;repelForce&quot;:0.5,&quot;centerForce&quot;:0.3,&quot;linkDistance&quot;:30,&quot;fontSize&quot;:0.6,&quot;opacityScale&quot;:1,&quot;showTags&quot;:true,&quot;removeTags&quot;:[]}"></div></div></div><div class="toc desktop-only"><button type="button" id="toc"><h3>Table of Contents</h3><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="fold"><polyline points="6 9 12 15 18 9"></polyline></svg></button><div id="toc-content"><ul class="overflow"><li class="depth-0"><a href="#world-wide-web" data-for="world-wide-web">World Wide Web</a></li><li class="depth-1"><a href="#client-server" data-for="client-server">Client, Server</a></li><li class="depth-1"><a href="#url" data-for="url">URL</a></li><li class="depth-1"><a href="#cookie" data-for="cookie">Cookie</a></li><li class="depth-0"><a href="#web-documents" data-for="web-documents">Web Documents</a></li><li class="depth-1"><a href="#static-document" data-for="static-document">Static Document</a></li><li class="depth-1"><a href="#dynamic-document" data-for="dynamic-document">Dynamic Document</a></li><li class="depth-1"><a href="#active-document" data-for="active-document">Active Document</a></li><li class="depth-0"><a href="#http" data-for="http">HTTP</a></li><li class="depth-1"><a href="#http-transaction" data-for="http-transaction">HTTP Transaction</a></li><li class="depth-1"><a href="#header" data-for="header">Header</a></li><li class="depth-1"><a href="#persistent-vs-non-persistent" data-for="persistent-vs-non-persistent">Persistent VS Non-persistent</a></li><li class="depth-1"><a href="#proxy-server" data-for="proxy-server">Proxy Server</a></li><li class="depth-0"><a href="#http2" data-for="http2">HTTP/2</a></li><li class="depth-1"><a href="#problems-of-http-1x" data-for="problems-of-http-1x">Problems of HTTP 1.x</a></li><li class="depth-1"><a href="#http2-1" data-for="http2-1">HTTP/2</a></li><li class="depth-1"><a href="#request---response-multiplexing" data-for="request---response-multiplexing">Request - Response Multiplexing</a></li><li class="depth-1"><a href="#용어정리" data-for="용어정리">용어정리</a></li><li class="depth-1"><a href="#binary-framing-layer" data-for="binary-framing-layer">Binary Framing Layer</a></li><li class="depth-1"><a href="#stream-prioritization" data-for="stream-prioritization">Stream Prioritization</a></li><li class="depth-1"><a href="#server-push" data-for="server-push">Server Push</a></li><li class="depth-1"><a href="#header-compression" data-for="header-compression">Header Compression</a></li></ul></div></div><div class="backlinks "><h3>Backlinks</h3><ul class="overflow"><li><a href="../../../../gardens/network/originals/comnet.fall.2021.cse.cnu.ac.kr/(충남대)-컴퓨터-네트워크-강의록" class="internal">(충남대) 컴퓨터 네트워크 강의록</a></li></ul></div></div></div><footer class><hr/><p>Created with <a href="https://quartz.jzhao.xyz/">Quartz v4.1.0</a>, © 2024</p><ul><li><a href="https://github.com/haeramkeem">GitHub</a></li><li><a href="www.linkedin.com/in/haeram-kim-277404220">LinkedIn</a></li><li><a href="mailto:haeram.kim1@gmail.com">Email</a></li></ul></footer></div></body><script type="application/javascript">// quartz/components/scripts/quartz/components/scripts/callout.inline.ts
function toggleCallout() {
  const outerBlock = this.parentElement;
  outerBlock.classList.toggle(`is-collapsed`);
  const collapsed = outerBlock.classList.contains(`is-collapsed`);
  const height = collapsed ? this.scrollHeight : outerBlock.scrollHeight;
  outerBlock.style.maxHeight = height + `px`;
  let current = outerBlock;
  let parent = outerBlock.parentElement;
  while (parent) {
    if (!parent.classList.contains(`callout`)) {
      return;
    }
    const collapsed2 = parent.classList.contains(`is-collapsed`);
    const height2 = collapsed2 ? parent.scrollHeight : parent.scrollHeight + current.scrollHeight;
    parent.style.maxHeight = height2 + `px`;
    current = parent;
    parent = parent.parentElement;
  }
}
function setupCallout() {
  const collapsible = document.getElementsByClassName(
    `callout is-collapsible`
  );
  for (const div of collapsible) {
    const title = div.firstElementChild;
    if (title) {
      title.removeEventListener(`click`, toggleCallout);
      title.addEventListener(`click`, toggleCallout);
      const collapsed = div.classList.contains(`is-collapsed`);
      const height = collapsed ? title.scrollHeight : div.scrollHeight;
      div.style.maxHeight = height + `px`;
    }
  }
}
document.addEventListener(`nav`, setupCallout);
window.addEventListener(`resize`, setupCallout);
</script><script type="module">
          import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.esm.min.mjs';
          const darkMode = document.documentElement.getAttribute('saved-theme') === 'dark'
          mermaid.initialize({
            startOnLoad: false,
            securityLevel: 'loose',
            theme: darkMode ? 'dark' : 'default'
          });
          document.addEventListener('nav', async () => {
            await mermaid.run({
              querySelector: '.mermaid'
            })
          });
          </script><script src="https://cdn.jsdelivr.net/npm/katex@0.16.7/dist/contrib/copy-tex.min.js" type="application/javascript"></script><script src="https://www.googletagmanager.com/gtag/js?id=G-N68CCP1QHG" type="application/javascript"></script><script src="../../../../postscript.js" type="module"></script></html>