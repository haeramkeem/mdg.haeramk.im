<!DOCTYPE html>
<html><head><title>부록 - 실습자료 1) Network layer &amp; ARP</title><meta charSet="utf-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:title" content="부록 - 실습자료 1) Network layer &amp; ARP"/><meta property="og:description" content="충남대학교 컴퓨터공학과 김상하 교수님의 &amp;quot;컴퓨터 네트워크&amp;quot; 강의를 필기한 내용입니다. 다소 잘못된 내용과 구어적 표현 이 포함되어 있을 수 있습니다. Network Layer의 역할 § Internetworking : 다른 네트워크(뭐 예를 들면 네트워크 케이블로 직접 연결되어있지 않은)들 간 연결을 해줘 하나의 네트워크처럼 보이게 하는 것 Addressing : 전 세계의 어느 곳이든 통신할 수 있게 하기 위해 기기들의 고유한 주소를 할당 Routing : 패킷이 목적지에 도착하기까지의 최적의 경로를 설정하는 역할 Packetizing : 상위계층으로부터 받은 데이터를 단편화해 패킷화하는 것 Fragmentation : 이건 프레임을 받아 처리한 후 새로운 프레임으로 구성하는 것 패킷화랑은 다르다! - 라우터에서 데이터링크 계층으로부터 받은 프레임을 decapsulation하여 루트를 설정하고 다른 포트로 보내기 위해 다시 프레임화 하는 과정을 떠올리면 됨 Address Resolution Protocol § 일단 너가 옛날에 가졌던 의문에 대한 답이 나오는데 물리주소와 논리주소쳬게를 별도로 분리하는 이유는 찐으로 고유한 값을 가지는 물리주소를 논리주소로도 이용하게 된다면 다른 네트워크로 빠져나가는 과정에서 문제가 생기게 된다 러프하게 생각해보면 모든 단말들의 물리주소가 고유하게 다르기 때문에 특정 주소의 단말로 가기 위해 라우팅 테이블로 다음 목적지를 알아내기 위해서는 이 모든 물리주소들에 대한 정보가 라우팅 테이블에 어느정도 들어있어야됨 - 근데 이게 불가능하기 때문인거같은뎅 IP주소는 32bit이고 MAC주소는 48bit이라는거정도는 알고있어야되지 않나 위의 그림이 ARP에서 사용되는 프레임의 포맷이다 다른 프레임의 구조와 동일하게, 맨 처음 6바이트는 수신지 물리주소가 들어가게 되고, 그 다음 6바이트는 송신지 물리주소가 들어가게 되며 그 다음 2바이트에는 이 프레임의 타입을 지정하는 숫자가 들어가게 된다 ARP에선 ARP Request, reply 모두 0x0806을 frame type에 넣어 이 프레임이 ARP를 위한 프레임임을 나타낸다 ARP에서는 이전에 배웠다시피 Ethernet destination address에는 broadcast가 들어가게 된다 그리고 Hard type은 통신에 사용하고 있는 데이터 링크 계층의 프로토콜 종류를 나타내고, Ethernet인 경우에는 0x0001이 들어가게 된다 또한 Prot type에는 통신에 사용하고 있는 네트워크 계층의 프로토콜 종류를 나타내고, IP인 경우에는 0x0800이 들어가게 된다 Hard &amp;amp; Prot size의 경우에는 데이터링크와 네트워크 계층에서 각각의 프로토콜에 사용될 주소의 길이를 1바이트에 저장하게 된다 - Ethernet인 경우에는 주소의 길이는 6바이트이므로 0x06이 들어가게 되고 IP의 경우에는 주소의 길이는 4바이트이므로 0x04가 들어가게 된다 Op필드의 경우에는 어떤 패킷인지 나타내는 숫자가 들어가게 되는데, ARP request인 경우에는 1, reply인 경우에는 2, RARP(물리주소로 논리주소 알아내는 프로토콜) request인 경우에는 3, reply인 경우에는 4가 들어가게 된다 마지막 4개의 필드에는 그림에 보이는것처럼 각각 송수신지의 물리주소와 논리주소가 들어가게 된다 ARP를 통해 물리주소를 알아낸 뒤에는 해당 주소를 캐쉬에 넣어놓고 추가적인 ARP 과정 없이 바로 보내게 된다 니가 아는 그 캐쉬 맞다 - 캐쉬 테이블에는 최근에 통신을 한 대상에 대한 물리주소가 저장되어 있어 IP만 가지고 선형탐색과정 없이 아주 빠른 속도로 물리주소를 알아낼 수 있음 따라서 ARP를 하기 전에 먼저 캐쉬 테이블에 이미 있나를 먼저 확인하고 없다면 ARP가 진행되는 방식인 것 물리주소를 찾은 경우 - Completed인 경우에는 캐쉬 테이블에 20분간 저장을 하게 되고 그렇지 않은 Incompleted인 경우에는 3분간 저장을 하게 된다 주소를 캐쉬에 넣어놓는 작업은 송수신자만 하는게 아니다 - ARP Request를 받은 모든 노드가 이걸 통해 송신자의 IP와 MAC을 매칭시킬 수 있기 때문에 자신한테 온 ARP Request가 아니라 하더라도 송신자의 IP와 MAC을 캐쉬에 넣어놓게 된다 실습때 구현할때 request와 reply에 패킷에 저장된 내용의 순서가 바뀌는 것에 유의해라 응답을 보낼때는 받은 패킷의 송신자가 응답 패킷의 수신자가 되므로 ."/><meta property="og:image" content="https://mdg.haeramk.im/static/og-image.png"/><meta property="og:width" content="1200"/><meta property="og:height" content="675"/><link rel="icon" href="../../../../static/icon.png"/><meta name="description" content="충남대학교 컴퓨터공학과 김상하 교수님의 &amp;quot;컴퓨터 네트워크&amp;quot; 강의를 필기한 내용입니다. 다소 잘못된 내용과 구어적 표현 이 포함되어 있을 수 있습니다. Network Layer의 역할 § Internetworking : 다른 네트워크(뭐 예를 들면 네트워크 케이블로 직접 연결되어있지 않은)들 간 연결을 해줘 하나의 네트워크처럼 보이게 하는 것 Addressing : 전 세계의 어느 곳이든 통신할 수 있게 하기 위해 기기들의 고유한 주소를 할당 Routing : 패킷이 목적지에 도착하기까지의 최적의 경로를 설정하는 역할 Packetizing : 상위계층으로부터 받은 데이터를 단편화해 패킷화하는 것 Fragmentation : 이건 프레임을 받아 처리한 후 새로운 프레임으로 구성하는 것 패킷화랑은 다르다! - 라우터에서 데이터링크 계층으로부터 받은 프레임을 decapsulation하여 루트를 설정하고 다른 포트로 보내기 위해 다시 프레임화 하는 과정을 떠올리면 됨 Address Resolution Protocol § 일단 너가 옛날에 가졌던 의문에 대한 답이 나오는데 물리주소와 논리주소쳬게를 별도로 분리하는 이유는 찐으로 고유한 값을 가지는 물리주소를 논리주소로도 이용하게 된다면 다른 네트워크로 빠져나가는 과정에서 문제가 생기게 된다 러프하게 생각해보면 모든 단말들의 물리주소가 고유하게 다르기 때문에 특정 주소의 단말로 가기 위해 라우팅 테이블로 다음 목적지를 알아내기 위해서는 이 모든 물리주소들에 대한 정보가 라우팅 테이블에 어느정도 들어있어야됨 - 근데 이게 불가능하기 때문인거같은뎅 IP주소는 32bit이고 MAC주소는 48bit이라는거정도는 알고있어야되지 않나 위의 그림이 ARP에서 사용되는 프레임의 포맷이다 다른 프레임의 구조와 동일하게, 맨 처음 6바이트는 수신지 물리주소가 들어가게 되고, 그 다음 6바이트는 송신지 물리주소가 들어가게 되며 그 다음 2바이트에는 이 프레임의 타입을 지정하는 숫자가 들어가게 된다 ARP에선 ARP Request, reply 모두 0x0806을 frame type에 넣어 이 프레임이 ARP를 위한 프레임임을 나타낸다 ARP에서는 이전에 배웠다시피 Ethernet destination address에는 broadcast가 들어가게 된다 그리고 Hard type은 통신에 사용하고 있는 데이터 링크 계층의 프로토콜 종류를 나타내고, Ethernet인 경우에는 0x0001이 들어가게 된다 또한 Prot type에는 통신에 사용하고 있는 네트워크 계층의 프로토콜 종류를 나타내고, IP인 경우에는 0x0800이 들어가게 된다 Hard &amp;amp; Prot size의 경우에는 데이터링크와 네트워크 계층에서 각각의 프로토콜에 사용될 주소의 길이를 1바이트에 저장하게 된다 - Ethernet인 경우에는 주소의 길이는 6바이트이므로 0x06이 들어가게 되고 IP의 경우에는 주소의 길이는 4바이트이므로 0x04가 들어가게 된다 Op필드의 경우에는 어떤 패킷인지 나타내는 숫자가 들어가게 되는데, ARP request인 경우에는 1, reply인 경우에는 2, RARP(물리주소로 논리주소 알아내는 프로토콜) request인 경우에는 3, reply인 경우에는 4가 들어가게 된다 마지막 4개의 필드에는 그림에 보이는것처럼 각각 송수신지의 물리주소와 논리주소가 들어가게 된다 ARP를 통해 물리주소를 알아낸 뒤에는 해당 주소를 캐쉬에 넣어놓고 추가적인 ARP 과정 없이 바로 보내게 된다 니가 아는 그 캐쉬 맞다 - 캐쉬 테이블에는 최근에 통신을 한 대상에 대한 물리주소가 저장되어 있어 IP만 가지고 선형탐색과정 없이 아주 빠른 속도로 물리주소를 알아낼 수 있음 따라서 ARP를 하기 전에 먼저 캐쉬 테이블에 이미 있나를 먼저 확인하고 없다면 ARP가 진행되는 방식인 것 물리주소를 찾은 경우 - Completed인 경우에는 캐쉬 테이블에 20분간 저장을 하게 되고 그렇지 않은 Incompleted인 경우에는 3분간 저장을 하게 된다 주소를 캐쉬에 넣어놓는 작업은 송수신자만 하는게 아니다 - ARP Request를 받은 모든 노드가 이걸 통해 송신자의 IP와 MAC을 매칭시킬 수 있기 때문에 자신한테 온 ARP Request가 아니라 하더라도 송신자의 IP와 MAC을 캐쉬에 넣어놓게 된다 실습때 구현할때 request와 reply에 패킷에 저장된 내용의 순서가 바뀌는 것에 유의해라 응답을 보낼때는 받은 패킷의 송신자가 응답 패킷의 수신자가 되므로 ."/><meta name="generator" content="Quartz"/><link rel="preconnect" href="https://fonts.googleapis.com"/><link rel="preconnect" href="https://fonts.gstatic.com"/><link href="../../../../index.css" rel="stylesheet" type="text/css" spa-preserve/><link href="https://cdn.jsdelivr.net/npm/katex@0.16.0/dist/katex.min.css" rel="stylesheet" type="text/css" spa-preserve/><link href="https://fonts.googleapis.com/css2?family=IBM Plex Mono&amp;family=Gowun Batang:wght@400;700&amp;family=Gowun Dodum:ital,wght@0,400;0,600;1,400;1,600&amp;display=swap" rel="stylesheet" type="text/css" spa-preserve/><script src="../../../../prescript.js" type="application/javascript" spa-preserve></script><script type="application/javascript" spa-preserve>const fetchData = fetch(`../../../../static/contentIndex.json`).then(data => data.json())</script></head><body data-slug="gardens/network/originals/comnet.fall.2021.cse.cnu.ac.kr/부록---실습자료-1)-Network-layer-&amp;-ARP"><div id="quartz-root" class="page"><div id="quartz-body"><div class="left sidebar"><h1 class="page-title "><a href="../../../..">Madison Digital Garden</a></h1><div class="spacer mobile-only"></div><div class="search "><div id="search-icon"><p>Search</p><div></div><svg tabIndex="0" aria-labelledby="title desc" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 19.9 19.7"><title id="title">Search</title><desc id="desc">Search</desc><g class="search-path" fill="none"><path stroke-linecap="square" d="M18.5 18.3l-5.4-5.4"></path><circle cx="8" cy="8" r="7"></circle></g></svg></div><div id="search-container"><div id="search-space"><input autocomplete="off" id="search-bar" name="search" type="text" aria-label="Search for something" placeholder="Search for something"/><div id="results-container"></div></div></div></div><div class="darkmode "><input class="toggle" id="darkmode-toggle" type="checkbox" tabIndex="-1"/><label id="toggle-label-light" for="darkmode-toggle" tabIndex="-1"><svg xmlns="http://www.w3.org/2000/svg" xmlnsXlink="http://www.w3.org/1999/xlink" version="1.1" id="dayIcon" x="0px" y="0px" viewBox="0 0 35 35" style="enable-background:new 0 0 35 35;" xmlSpace="preserve"><title>Light mode</title><path d="M6,17.5C6,16.672,5.328,16,4.5,16h-3C0.672,16,0,16.672,0,17.5    S0.672,19,1.5,19h3C5.328,19,6,18.328,6,17.5z M7.5,26c-0.414,0-0.789,0.168-1.061,0.439l-2,2C4.168,28.711,4,29.086,4,29.5    C4,30.328,4.671,31,5.5,31c0.414,0,0.789-0.168,1.06-0.44l2-2C8.832,28.289,9,27.914,9,27.5C9,26.672,8.329,26,7.5,26z M17.5,6    C18.329,6,19,5.328,19,4.5v-3C19,0.672,18.329,0,17.5,0S16,0.672,16,1.5v3C16,5.328,16.671,6,17.5,6z M27.5,9    c0.414,0,0.789-0.168,1.06-0.439l2-2C30.832,6.289,31,5.914,31,5.5C31,4.672,30.329,4,29.5,4c-0.414,0-0.789,0.168-1.061,0.44    l-2,2C26.168,6.711,26,7.086,26,7.5C26,8.328,26.671,9,27.5,9z M6.439,8.561C6.711,8.832,7.086,9,7.5,9C8.328,9,9,8.328,9,7.5    c0-0.414-0.168-0.789-0.439-1.061l-2-2C6.289,4.168,5.914,4,5.5,4C4.672,4,4,4.672,4,5.5c0,0.414,0.168,0.789,0.439,1.06    L6.439,8.561z M33.5,16h-3c-0.828,0-1.5,0.672-1.5,1.5s0.672,1.5,1.5,1.5h3c0.828,0,1.5-0.672,1.5-1.5S34.328,16,33.5,16z     M28.561,26.439C28.289,26.168,27.914,26,27.5,26c-0.828,0-1.5,0.672-1.5,1.5c0,0.414,0.168,0.789,0.439,1.06l2,2    C28.711,30.832,29.086,31,29.5,31c0.828,0,1.5-0.672,1.5-1.5c0-0.414-0.168-0.789-0.439-1.061L28.561,26.439z M17.5,29    c-0.829,0-1.5,0.672-1.5,1.5v3c0,0.828,0.671,1.5,1.5,1.5s1.5-0.672,1.5-1.5v-3C19,29.672,18.329,29,17.5,29z M17.5,7    C11.71,7,7,11.71,7,17.5S11.71,28,17.5,28S28,23.29,28,17.5S23.29,7,17.5,7z M17.5,25c-4.136,0-7.5-3.364-7.5-7.5    c0-4.136,3.364-7.5,7.5-7.5c4.136,0,7.5,3.364,7.5,7.5C25,21.636,21.636,25,17.5,25z"></path></svg></label><label id="toggle-label-dark" for="darkmode-toggle" tabIndex="-1"><svg xmlns="http://www.w3.org/2000/svg" xmlnsXlink="http://www.w3.org/1999/xlink" version="1.1" id="nightIcon" x="0px" y="0px" viewBox="0 0 100 100" style="enable-background='new 0 0 100 100'" xmlSpace="preserve"><title>Dark mode</title><path d="M96.76,66.458c-0.853-0.852-2.15-1.064-3.23-0.534c-6.063,2.991-12.858,4.571-19.655,4.571  C62.022,70.495,50.88,65.88,42.5,57.5C29.043,44.043,25.658,23.536,34.076,6.47c0.532-1.08,0.318-2.379-0.534-3.23  c-0.851-0.852-2.15-1.064-3.23-0.534c-4.918,2.427-9.375,5.619-13.246,9.491c-9.447,9.447-14.65,22.008-14.65,35.369  c0,13.36,5.203,25.921,14.65,35.368s22.008,14.65,35.368,14.65c13.361,0,25.921-5.203,35.369-14.65  c3.872-3.871,7.064-8.328,9.491-13.246C97.826,68.608,97.611,67.309,96.76,66.458z"></path></svg></label></div></div><div class="center"><div class="page-header"><div class="popover-hint"><h1 class="article-title ">부록 - 실습자료 1) Network layer &amp; ARP</h1><p class="content-meta ">Jan 05, 2025, 7 min read</p></div></div><article class="popover-hint"><blockquote class="callout" data-callout="info">
<div class="callout-title">
                  <div class="callout-icon"><svg xmlns="http://www.w3.org/2000/svg" width="100%" height="100%" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="10"></circle><line x1="12" y1="16" x2="12" y2="12"></line><line x1="12" y1="8" x2="12.01" y2="8"></line></svg></div>
                  <div class="callout-title-inner"><p>충남대학교 컴퓨터공학과 김상하 교수님의 &quot;컴퓨터 네트워크&quot; 강의를 필기한 내용입니다. </p></div>
                  
                </div>
</blockquote>
<blockquote class="callout" data-callout="warning">
<div class="callout-title">
                  <div class="callout-icon"><svg xmlns="http://www.w3.org/2000/svg" width="100%" height="100%" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="m21.73 18-8-14a2 2 0 0 0-3.48 0l-8 14A2 2 0 0 0 4 21h16a2 2 0 0 0 1.73-3Z"></path><line x1="12" y1="9" x2="12" y2="13"></line><line x1="12" y1="17" x2="12.01" y2="17"></line></svg></div>
                  <div class="callout-title-inner"><p>다소 잘못된 내용과 구어적 표현 이 포함되어 있을 수 있습니다. </p></div>
                  
                </div>
</blockquote>
<h2 id="network-layer의-역할">Network Layer의 역할<a aria-hidden="true" tabindex="-1" href="#network-layer의-역할" class="internal"> §</a></h2>
<ol>
<li><strong>Internetworking</strong> : 다른 네트워크(뭐 예를 들면 네트워크 케이블로 직접 연결되어있지 않은)들 간 연결을 해줘 하나의 네트워크처럼 보이게 하는 것</li>
<li><strong>Addressing</strong> : 전 세계의 어느 곳이든 통신할 수 있게 하기 위해 기기들의 고유한 주소를 할당</li>
<li><strong>Routing</strong> : 패킷이 목적지에 도착하기까지의 최적의 경로를 설정하는 역할</li>
<li><strong>Packetizing</strong> : 상위계층으로부터 받은 데이터를 단편화해 패킷화하는 것</li>
<li><strong>Fragmentation</strong> : 이건 프레임을 받아 처리한 후 새로운 프레임으로 구성하는 것
<ul>
<li>패킷화랑은 다르다! - 라우터에서 데이터링크 계층으로부터 받은 프레임을 decapsulation하여 루트를 설정하고 다른 포트로 보내기 위해 다시 프레임화 하는 과정을 떠올리면 됨</li>
</ul>
</li>
</ol>
<h2 id="address-resolution-protocol">Address Resolution Protocol<a aria-hidden="true" tabindex="-1" href="#address-resolution-protocol" class="internal"> §</a></h2>
<ul>
<li>일단 너가 옛날에 가졌던 의문에 대한 답이 나오는데</li>
<li>물리주소와 논리주소쳬게를 별도로 분리하는 이유는 찐으로 고유한 값을 가지는 물리주소를 논리주소로도 이용하게 된다면 다른 네트워크로 빠져나가는 과정에서 문제가 생기게 된다
<ul>
<li>러프하게 생각해보면 모든 단말들의 물리주소가 고유하게 다르기 때문에 특정 주소의 단말로 가기 위해 라우팅 테이블로 다음 목적지를 알아내기 위해서는 이 모든 물리주소들에 대한 정보가 라우팅 테이블에 어느정도 들어있어야됨 - 근데 이게 불가능하기 때문인거같은뎅</li>
</ul>
</li>
<li>IP주소는 32bit이고 MAC주소는 48bit이라는거정도는 알고있어야되지 않나</li>
</ul>
<p><img src="../../../../gardens/network/originals/comnet.fall.2021.cse.cnu.ac.kr/images/prac01_bb21adcc32be4540a2975c2f22e5fbc5/image1.png" alt="%E1%84%89%E1%85%B5%E1%86%AF%E1%84%89%E1%85%B3%E1%86%B802%20-%20Network%20layer%20&amp;%20ARP%20bb21adcc32be4540a2975c2f22e5fbc5/image1.png"/></p>
<ul>
<li>위의 그림이 ARP에서 사용되는 프레임의 포맷이다</li>
<li>다른 프레임의 구조와 동일하게, 맨 처음 6바이트는 수신지 물리주소가 들어가게 되고, 그 다음 6바이트는 송신지 물리주소가 들어가게 되며 그 다음 2바이트에는 이 프레임의 타입을 지정하는 숫자가 들어가게 된다</li>
<li>ARP에선 ARP Request, reply 모두 <strong>0x0806</strong>을 frame type에 넣어 이 프레임이 ARP를 위한 프레임임을 나타낸다</li>
<li>ARP에서는 이전에 배웠다시피 Ethernet destination address에는 broadcast가 들어가게 된다</li>
<li>그리고 <strong>Hard type</strong>은 통신에 사용하고 있는 데이터 링크 계층의 프로토콜 종류를 나타내고, Ethernet인 경우에는 <strong>0x0001</strong>이 들어가게 된다</li>
<li>또한 <strong>Prot type</strong>에는 통신에 사용하고 있는 네트워크 계층의 프로토콜 종류를 나타내고, IP인 경우에는 <strong>0x0800</strong>이 들어가게 된다</li>
<li><strong>Hard &amp; Prot size</strong>의 경우에는 데이터링크와 네트워크 계층에서 각각의 프로토콜에 사용될 주소의 길이를 1바이트에 저장하게 된다 - Ethernet인 경우에는 주소의 길이는 6바이트이므로 0x06이 들어가게 되고 IP의 경우에는 주소의 길이는 4바이트이므로 0x04가 들어가게 된다</li>
<li><strong>Op</strong>필드의 경우에는 어떤 패킷인지 나타내는 숫자가 들어가게 되는데, ARP request인 경우에는 1, reply인 경우에는 2, RARP(물리주소로 논리주소 알아내는 프로토콜) request인 경우에는 3, reply인 경우에는 4가 들어가게 된다</li>
<li>마지막 4개의 필드에는 그림에 보이는것처럼 각각 송수신지의 물리주소와 논리주소가 들어가게 된다</li>
<li>ARP를 통해 물리주소를 알아낸 뒤에는 해당 주소를 캐쉬에 넣어놓고 추가적인 ARP 과정 없이 바로 보내게 된다
<ul>
<li>니가 아는 그 캐쉬 맞다 - 캐쉬 테이블에는 최근에 통신을 한 대상에 대한 물리주소가 저장되어 있어 IP만 가지고 선형탐색과정 없이 아주 빠른 속도로 물리주소를 알아낼 수 있음</li>
<li>따라서 ARP를 하기 전에 먼저 캐쉬 테이블에 이미 있나를 먼저 확인하고 없다면 ARP가 진행되는 방식인 것</li>
<li>물리주소를 찾은 경우 - <strong>Completed</strong>인 경우에는 캐쉬 테이블에 20분간 저장을 하게 되고 그렇지 않은 <strong>Incompleted</strong>인 경우에는 3분간 저장을 하게 된다</li>
<li>주소를 캐쉬에 넣어놓는 작업은 송수신자만 하는게 아니다 - ARP Request를 받은 모든 노드가 이걸 통해 송신자의 IP와 MAC을 매칭시킬 수 있기 때문에 자신한테 온 ARP Request가 아니라 하더라도 송신자의 IP와 MAC을 캐쉬에 넣어놓게 된다</li>
</ul>
</li>
<li>실습때 구현할때 request와 reply에 패킷에 저장된 내용의 순서가 바뀌는 것에 유의해라
<ul>
<li>응답을 보낼때는 받은 패킷의 송신자가 응답 패킷의 수신자가 되므로</li>
</ul>
</li>
</ul></article></div><div class="right sidebar"><div class="graph "><h3>Graph View</h3><div class="graph-outer"><div id="graph-container" data-cfg="{&quot;drag&quot;:true,&quot;zoom&quot;:true,&quot;depth&quot;:1,&quot;scale&quot;:1.1,&quot;repelForce&quot;:0.5,&quot;centerForce&quot;:0.3,&quot;linkDistance&quot;:30,&quot;fontSize&quot;:0.6,&quot;opacityScale&quot;:1,&quot;showTags&quot;:true,&quot;removeTags&quot;:[]}"></div><svg version="1.1" id="global-graph-icon" xmlns="http://www.w3.org/2000/svg" xmlnsXlink="http://www.w3.org/1999/xlink" x="0px" y="0px" viewBox="0 0 55 55" fill="currentColor" xmlSpace="preserve"><path d="M49,0c-3.309,0-6,2.691-6,6c0,1.035,0.263,2.009,0.726,2.86l-9.829,9.829C32.542,17.634,30.846,17,29,17
	s-3.542,0.634-4.898,1.688l-7.669-7.669C16.785,10.424,17,9.74,17,9c0-2.206-1.794-4-4-4S9,6.794,9,9s1.794,4,4,4
	c0.74,0,1.424-0.215,2.019-0.567l7.669,7.669C21.634,21.458,21,23.154,21,25s0.634,3.542,1.688,4.897L10.024,42.562
	C8.958,41.595,7.549,41,6,41c-3.309,0-6,2.691-6,6s2.691,6,6,6s6-2.691,6-6c0-1.035-0.263-2.009-0.726-2.86l12.829-12.829
	c1.106,0.86,2.44,1.436,3.898,1.619v10.16c-2.833,0.478-5,2.942-5,5.91c0,3.309,2.691,6,6,6s6-2.691,6-6c0-2.967-2.167-5.431-5-5.91
	v-10.16c1.458-0.183,2.792-0.759,3.898-1.619l7.669,7.669C41.215,39.576,41,40.26,41,41c0,2.206,1.794,4,4,4s4-1.794,4-4
	s-1.794-4-4-4c-0.74,0-1.424,0.215-2.019,0.567l-7.669-7.669C36.366,28.542,37,26.846,37,25s-0.634-3.542-1.688-4.897l9.665-9.665
	C46.042,11.405,47.451,12,49,12c3.309,0,6-2.691,6-6S52.309,0,49,0z M11,9c0-1.103,0.897-2,2-2s2,0.897,2,2s-0.897,2-2,2
	S11,10.103,11,9z M6,51c-2.206,0-4-1.794-4-4s1.794-4,4-4s4,1.794,4,4S8.206,51,6,51z M33,49c0,2.206-1.794,4-4,4s-4-1.794-4-4
	s1.794-4,4-4S33,46.794,33,49z M29,31c-3.309,0-6-2.691-6-6s2.691-6,6-6s6,2.691,6,6S32.309,31,29,31z M47,41c0,1.103-0.897,2-2,2
	s-2-0.897-2-2s0.897-2,2-2S47,39.897,47,41z M49,10c-2.206,0-4-1.794-4-4s1.794-4,4-4s4,1.794,4,4S51.206,10,49,10z"></path></svg></div><div id="global-graph-outer"><div id="global-graph-container" data-cfg="{&quot;drag&quot;:true,&quot;zoom&quot;:true,&quot;depth&quot;:-1,&quot;scale&quot;:0.9,&quot;repelForce&quot;:0.5,&quot;centerForce&quot;:0.3,&quot;linkDistance&quot;:30,&quot;fontSize&quot;:0.6,&quot;opacityScale&quot;:1,&quot;showTags&quot;:true,&quot;removeTags&quot;:[]}"></div></div></div><div class="toc desktop-only"><button type="button" id="toc"><h3>Table of Contents</h3><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="fold"><polyline points="6 9 12 15 18 9"></polyline></svg></button><div id="toc-content"><ul class="overflow"><li class="depth-0"><a href="#network-layer의-역할" data-for="network-layer의-역할">Network Layer의 역할</a></li><li class="depth-0"><a href="#address-resolution-protocol" data-for="address-resolution-protocol">Address Resolution Protocol</a></li></ul></div></div><div class="backlinks "><h3>Backlinks</h3><ul class="overflow"><li><a href="../../../../gardens/network/originals/comnet.fall.2021.cse.cnu.ac.kr/(충남대)-컴퓨터-네트워크-강의록" class="internal">(충남대) 컴퓨터 네트워크 강의록</a></li><li><a href="../../../../gardens/network/originals/comnet.fall.2021.cse.cnu.ac.kr/07.-Address-mapping,-Multicasting,-Error-rep" class="internal">07. Address mapping, Multicasting, Error rep</a></li></ul></div></div></div><footer class><hr/><p>Created with <a href="https://quartz.jzhao.xyz/">Quartz v4.1.0</a>, © 2025</p><ul><li><a href="https://github.com/haeramkeem">GitHub</a></li><li><a href="www.linkedin.com/in/haeram-kim-277404220">LinkedIn</a></li><li><a href="mailto:haeram.kim1@gmail.com">Email</a></li></ul></footer></div></body><script type="application/javascript">// quartz/components/scripts/quartz/components/scripts/callout.inline.ts
function toggleCallout() {
  const outerBlock = this.parentElement;
  outerBlock.classList.toggle(`is-collapsed`);
  const collapsed = outerBlock.classList.contains(`is-collapsed`);
  const height = collapsed ? this.scrollHeight : outerBlock.scrollHeight;
  outerBlock.style.maxHeight = height + `px`;
  let current = outerBlock;
  let parent = outerBlock.parentElement;
  while (parent) {
    if (!parent.classList.contains(`callout`)) {
      return;
    }
    const collapsed2 = parent.classList.contains(`is-collapsed`);
    const height2 = collapsed2 ? parent.scrollHeight : parent.scrollHeight + current.scrollHeight;
    parent.style.maxHeight = height2 + `px`;
    current = parent;
    parent = parent.parentElement;
  }
}
function setupCallout() {
  const collapsible = document.getElementsByClassName(
    `callout is-collapsible`
  );
  for (const div of collapsible) {
    const title = div.firstElementChild;
    if (title) {
      title.removeEventListener(`click`, toggleCallout);
      title.addEventListener(`click`, toggleCallout);
      const collapsed = div.classList.contains(`is-collapsed`);
      const height = collapsed ? title.scrollHeight : div.scrollHeight;
      div.style.maxHeight = height + `px`;
    }
  }
}
document.addEventListener(`nav`, setupCallout);
window.addEventListener(`resize`, setupCallout);
</script><script type="module">
          import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.esm.min.mjs';
          const darkMode = document.documentElement.getAttribute('saved-theme') === 'dark'
          mermaid.initialize({
            startOnLoad: false,
            securityLevel: 'loose',
            theme: darkMode ? 'dark' : 'default'
          });
          document.addEventListener('nav', async () => {
            await mermaid.run({
              querySelector: '.mermaid'
            })
          });
          </script><script src="https://cdn.jsdelivr.net/npm/katex@0.16.7/dist/contrib/copy-tex.min.js" type="application/javascript"></script><script src="https://www.googletagmanager.com/gtag/js?id=G-N68CCP1QHG" type="application/javascript"></script><script src="../../../../postscript.js" type="module"></script></html>