<!DOCTYPE html>
<html><head><title>02. Network Layer</title><meta charSet="utf-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:title" content="02. Network Layer"/><meta property="og:description" content="충남대학교 컴퓨터공학과 김상하 교수님의 &amp;quot;컴퓨터 네트워크&amp;quot; 강의를 필기한 내용입니다. 다소 잘못된 내용과 구어적 표현 이 포함되어 있을 수 있습니다. IP § 일단 IP는 Network Layer의 한 종류인데 이것 말고도 다른 것들도 있었지만 결과적으로 IP가 승리를 거두었고 앞으로도 계속 쓰이게 될 것이다 Network Layer로 IP를 사용하는 통신망에 연결되어 있으면 인터넷에 연결되어 있다고 하더라 그리고 컴퓨터같은 송수신지 말고 중간에 거쳐가는 Intermediate Node같은 경우에는 Network Layer까지만 있고 그 상위 프로토콜에 대한 기능은 가지고 있지 않더라 - 까지도 데통시간에 배웠쥬? Packet Switching § 뭐 옛날에는 Circuit switching이라는 기술도 있었지만 지금은 거의 안쓴댄다 Principles of Packet Switching § 일단 송신하려고 하는 user data를 패킷단위로 쪼개고 각 패킷에 packet header라는 control information을 붙인다."/><meta property="og:image" content="https://mdg.haeramk.im/static/og-image.png"/><meta property="og:width" content="1200"/><meta property="og:height" content="675"/><link rel="icon" href="../../../../static/icon.png"/><meta name="description" content="충남대학교 컴퓨터공학과 김상하 교수님의 &amp;quot;컴퓨터 네트워크&amp;quot; 강의를 필기한 내용입니다. 다소 잘못된 내용과 구어적 표현 이 포함되어 있을 수 있습니다. IP § 일단 IP는 Network Layer의 한 종류인데 이것 말고도 다른 것들도 있었지만 결과적으로 IP가 승리를 거두었고 앞으로도 계속 쓰이게 될 것이다 Network Layer로 IP를 사용하는 통신망에 연결되어 있으면 인터넷에 연결되어 있다고 하더라 그리고 컴퓨터같은 송수신지 말고 중간에 거쳐가는 Intermediate Node같은 경우에는 Network Layer까지만 있고 그 상위 프로토콜에 대한 기능은 가지고 있지 않더라 - 까지도 데통시간에 배웠쥬? Packet Switching § 뭐 옛날에는 Circuit switching이라는 기술도 있었지만 지금은 거의 안쓴댄다 Principles of Packet Switching § 일단 송신하려고 하는 user data를 패킷단위로 쪼개고 각 패킷에 packet header라는 control information을 붙인다."/><meta name="generator" content="Quartz"/><link rel="preconnect" href="https://fonts.googleapis.com"/><link rel="preconnect" href="https://fonts.gstatic.com"/><link href="../../../../index.css" rel="stylesheet" type="text/css" spa-preserve/><link href="https://cdn.jsdelivr.net/npm/katex@0.16.0/dist/katex.min.css" rel="stylesheet" type="text/css" spa-preserve/><link href="https://fonts.googleapis.com/css2?family=IBM Plex Mono&amp;family=Gowun Batang:wght@400;700&amp;family=Gowun Dodum:ital,wght@0,400;0,600;1,400;1,600&amp;display=swap" rel="stylesheet" type="text/css" spa-preserve/><script src="../../../../prescript.js" type="application/javascript" spa-preserve></script><script type="application/javascript" spa-preserve>const fetchData = fetch(`../../../../static/contentIndex.json`).then(data => data.json())</script></head><body data-slug="gardens/network/originals/comnet.fall.2021.cse.cnu.ac.kr/02.-Network-Layer"><div id="quartz-root" class="page"><div id="quartz-body"><div class="left sidebar"><h1 class="page-title "><a href="../../../..">Madison Digital Garden</a></h1><div class="spacer mobile-only"></div><div class="search "><div id="search-icon"><p>Search</p><div></div><svg tabIndex="0" aria-labelledby="title desc" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 19.9 19.7"><title id="title">Search</title><desc id="desc">Search</desc><g class="search-path" fill="none"><path stroke-linecap="square" d="M18.5 18.3l-5.4-5.4"></path><circle cx="8" cy="8" r="7"></circle></g></svg></div><div id="search-container"><div id="search-space"><input autocomplete="off" id="search-bar" name="search" type="text" aria-label="Search for something" placeholder="Search for something"/><div id="results-container"></div></div></div></div><div class="darkmode "><input class="toggle" id="darkmode-toggle" type="checkbox" tabIndex="-1"/><label id="toggle-label-light" for="darkmode-toggle" tabIndex="-1"><svg xmlns="http://www.w3.org/2000/svg" xmlnsXlink="http://www.w3.org/1999/xlink" version="1.1" id="dayIcon" x="0px" y="0px" viewBox="0 0 35 35" style="enable-background:new 0 0 35 35;" xmlSpace="preserve"><title>Light mode</title><path d="M6,17.5C6,16.672,5.328,16,4.5,16h-3C0.672,16,0,16.672,0,17.5    S0.672,19,1.5,19h3C5.328,19,6,18.328,6,17.5z M7.5,26c-0.414,0-0.789,0.168-1.061,0.439l-2,2C4.168,28.711,4,29.086,4,29.5    C4,30.328,4.671,31,5.5,31c0.414,0,0.789-0.168,1.06-0.44l2-2C8.832,28.289,9,27.914,9,27.5C9,26.672,8.329,26,7.5,26z M17.5,6    C18.329,6,19,5.328,19,4.5v-3C19,0.672,18.329,0,17.5,0S16,0.672,16,1.5v3C16,5.328,16.671,6,17.5,6z M27.5,9    c0.414,0,0.789-0.168,1.06-0.439l2-2C30.832,6.289,31,5.914,31,5.5C31,4.672,30.329,4,29.5,4c-0.414,0-0.789,0.168-1.061,0.44    l-2,2C26.168,6.711,26,7.086,26,7.5C26,8.328,26.671,9,27.5,9z M6.439,8.561C6.711,8.832,7.086,9,7.5,9C8.328,9,9,8.328,9,7.5    c0-0.414-0.168-0.789-0.439-1.061l-2-2C6.289,4.168,5.914,4,5.5,4C4.672,4,4,4.672,4,5.5c0,0.414,0.168,0.789,0.439,1.06    L6.439,8.561z M33.5,16h-3c-0.828,0-1.5,0.672-1.5,1.5s0.672,1.5,1.5,1.5h3c0.828,0,1.5-0.672,1.5-1.5S34.328,16,33.5,16z     M28.561,26.439C28.289,26.168,27.914,26,27.5,26c-0.828,0-1.5,0.672-1.5,1.5c0,0.414,0.168,0.789,0.439,1.06l2,2    C28.711,30.832,29.086,31,29.5,31c0.828,0,1.5-0.672,1.5-1.5c0-0.414-0.168-0.789-0.439-1.061L28.561,26.439z M17.5,29    c-0.829,0-1.5,0.672-1.5,1.5v3c0,0.828,0.671,1.5,1.5,1.5s1.5-0.672,1.5-1.5v-3C19,29.672,18.329,29,17.5,29z M17.5,7    C11.71,7,7,11.71,7,17.5S11.71,28,17.5,28S28,23.29,28,17.5S23.29,7,17.5,7z M17.5,25c-4.136,0-7.5-3.364-7.5-7.5    c0-4.136,3.364-7.5,7.5-7.5c4.136,0,7.5,3.364,7.5,7.5C25,21.636,21.636,25,17.5,25z"></path></svg></label><label id="toggle-label-dark" for="darkmode-toggle" tabIndex="-1"><svg xmlns="http://www.w3.org/2000/svg" xmlnsXlink="http://www.w3.org/1999/xlink" version="1.1" id="nightIcon" x="0px" y="0px" viewBox="0 0 100 100" style="enable-background='new 0 0 100 100'" xmlSpace="preserve"><title>Dark mode</title><path d="M96.76,66.458c-0.853-0.852-2.15-1.064-3.23-0.534c-6.063,2.991-12.858,4.571-19.655,4.571  C62.022,70.495,50.88,65.88,42.5,57.5C29.043,44.043,25.658,23.536,34.076,6.47c0.532-1.08,0.318-2.379-0.534-3.23  c-0.851-0.852-2.15-1.064-3.23-0.534c-4.918,2.427-9.375,5.619-13.246,9.491c-9.447,9.447-14.65,22.008-14.65,35.369  c0,13.36,5.203,25.921,14.65,35.368s22.008,14.65,35.368,14.65c13.361,0,25.921-5.203,35.369-14.65  c3.872-3.871,7.064-8.328,9.491-13.246C97.826,68.608,97.611,67.309,96.76,66.458z"></path></svg></label></div></div><div class="center"><div class="page-header"><div class="popover-hint"><h1 class="article-title ">02. Network Layer</h1><p class="content-meta ">Oct 07, 2024, 16 min read</p></div></div><article class="popover-hint"><blockquote class="callout" data-callout="info">
<div class="callout-title">
                  <div class="callout-icon"><svg xmlns="http://www.w3.org/2000/svg" width="100%" height="100%" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="10"></circle><line x1="12" y1="16" x2="12" y2="12"></line><line x1="12" y1="8" x2="12.01" y2="8"></line></svg></div>
                  <div class="callout-title-inner"><p>충남대학교 컴퓨터공학과 김상하 교수님의 &quot;컴퓨터 네트워크&quot; 강의를 필기한 내용입니다. </p></div>
                  
                </div>
</blockquote>
<blockquote class="callout" data-callout="warning">
<div class="callout-title">
                  <div class="callout-icon"><svg xmlns="http://www.w3.org/2000/svg" width="100%" height="100%" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="m21.73 18-8-14a2 2 0 0 0-3.48 0l-8 14A2 2 0 0 0 4 21h16a2 2 0 0 0 1.73-3Z"></path><line x1="12" y1="9" x2="12" y2="13"></line><line x1="12" y1="17" x2="12.01" y2="17"></line></svg></div>
                  <div class="callout-title-inner"><p>다소 잘못된 내용과 구어적 표현 이 포함되어 있을 수 있습니다. </p></div>
                  
                </div>
</blockquote>
<h2 id="ip">IP<a aria-hidden="true" tabindex="-1" href="#ip" class="internal"> §</a></h2>
<ul>
<li>일단 IP는 Network Layer의 한 종류인데</li>
<li>이것 말고도 다른 것들도 있었지만 결과적으로 IP가 승리를 거두었고 앞으로도 계속 쓰이게 될 것이다</li>
<li>Network Layer로 IP를 사용하는 통신망에 연결되어 있으면 인터넷에 연결되어 있다고 하더라</li>
<li>그리고 컴퓨터같은 송수신지 말고 중간에 거쳐가는 Intermediate Node같은 경우에는 Network Layer까지만 있고 그 상위 프로토콜에 대한 기능은 가지고 있지 않더라 - 까지도 데통시간에 배웠쥬?</li>
</ul>
<h2 id="packet-switching">Packet Switching<a aria-hidden="true" tabindex="-1" href="#packet-switching" class="internal"> §</a></h2>
<ul>
<li>뭐 옛날에는 Circuit switching이라는 기술도 있었지만 지금은 거의 안쓴댄다</li>
</ul>
<h3 id="principles-of-packet-switching">Principles of Packet Switching<a aria-hidden="true" tabindex="-1" href="#principles-of-packet-switching" class="internal"> §</a></h3>
<p><img src="../../../../gardens/network/originals/comnet.fall.2021.cse.cnu.ac.kr/images/02_c838e9f353ea4739a7de8281a9e81ba1/image1.png" alt="%E1%84%8B%E1%85%B5%E1%84%85%E1%85%A9%E1%86%AB02%20-%20Network%20Layer%20c838e9f353ea4739a7de8281a9e81ba1/image1.png"/></p>
<ul>
<li>일단 송신하려고 하는 user data를 패킷단위로 쪼개고 각 패킷에 <strong>packet header</strong>라는 control information을 붙인다.
<ul>
<li><strong>packet header</strong>에는 송수신지의 Network address(IP address)와 다른 여러 정보들이 들어가게 된다</li>
</ul>
</li>
<li>그리고 <strong>Packet Switching</strong>이라는 것은 큐에 있는 패킷을 바꿔치기 하는 것을 의미한다
<ul>
<li>이러한 작업을 하는 장비를 <strong>Router</strong>라고 하며 <strong>Packet Switch</strong>라는 말과 동일하게 쓰인다</li>
</ul>
</li>
</ul>
<p><img src="../../../../gardens/network/originals/comnet.fall.2021.cse.cnu.ac.kr/images/02_c838e9f353ea4739a7de8281a9e81ba1/image2.png" alt="%E1%84%8B%E1%85%B5%E1%84%85%E1%85%A9%E1%86%AB02%20-%20Network%20Layer%20c838e9f353ea4739a7de8281a9e81ba1/image2.png"/></p>
<ul>
<li>근데 갑자기 뭔 큐냐</li>
<li>위 그림의 왼쪽은 전체 네트워크 구조의 예시이고 오른쪽은 저 네트워크 안에서 2번 라우터의 구조를 나타낸 것이다 - 보면 C, 3, 5, 1과 연결되어 있는 것을 알 수 있다</li>
<li>그리고 각각의 노드마다 입출력 회선이 존재한다 - 그림에서는 선 하나로 표현됐지만 사실 두개인 것이다</li>
<li>또한 각각의 회선의 끝에는 큐가 존재한다 - 입력 회선의 경우에는 Input queue가 존재해 들어오는 패킷들이 쌓이고, 출력 회선의 경우에는 output queue가 존재해 나가야 되는 패킷들이 쌓이게 된다</li>
<li>오른쪽 그림을 통해 Packet switching의 과정을 보면
<ol>
<li>1번 노드와 연결된 회선으로 송신지 B, 수신지 D인 패킷이 들어온다</li>
<li>그럼 그 패킷이 그 회선의 input queue에 쌓인다</li>
<li>queue에서 나오면, 2번 노드가 보고 수신지가 D인 것을 확인한 후 3번 노드로 나가는 output queue에 넣어주게 된다</li>
<li>Output queue에서 기다리다 3번 노드로 나가게 된다</li>
</ol>
</li>
</ul>
<h2 id="two-types-of-packet-switching">Two types of packet switching<a aria-hidden="true" tabindex="-1" href="#two-types-of-packet-switching" class="internal"> §</a></h2>
<ul>
<li><strong>Datagram</strong>방식 : <strong>Connectionless</strong>한 방식</li>
<li><strong>Virtual-circuit</strong>방식 : <strong>Connect-oriented</strong>방식 - <strong>Orderly Delivery</strong>(connection / disconnection 프로세스를 필요로함)</li>
<li>뭔 개소린지 이제 배운다</li>
</ul>
<h3 id="datagram">Datagram<a aria-hidden="true" tabindex="-1" href="#datagram" class="internal"> §</a></h3>
<ul>
<li><strong>Datagram</strong>방식은 패킷화하여 분리된 패킷들이 같은 경로로 가든 다른 경로로 가든 상관 없는 방식이다</li>
</ul>
<p><img src="../../../../gardens/network/originals/comnet.fall.2021.cse.cnu.ac.kr/images/02_c838e9f353ea4739a7de8281a9e81ba1/image3.png" alt="%E1%84%8B%E1%85%B5%E1%84%85%E1%85%A9%E1%86%AB02%20-%20Network%20Layer%20c838e9f353ea4739a7de8281a9e81ba1/image3.png"/></p>
<ul>
<li>위의 예시를 보면</li>
<li>일단 datagram방식이나 virtual circuit이나 패킷으로 나누는건 동일하다</li>
<li>그리고 나눈 패킷 중</li>
<li>첫번째 패킷은 B → 1 → 4 → 5 → 3 → D의 경로로 갔고</li>
<li>두번째 패킷은 B → 1 → 2 → 5 → 3 → D의 경로로 가고</li>
<li>세번째 패킷은 B → 1 → 2 → 3 → D의 경로로 갔다고 해보자</li>
<li>이 경로를 설정하는 것은 각각 노드 맘대로 하는거다 - 한쪽이 트래픽이 몰려서 다른길로 보낼 수도 있고 뭐 지꼴리는대로 판단해서 보내는 것</li>
<li>Datagram방식은 이처럼 가는 경로가 일정하지 않고, 따라서 D에 도착하는 순서도 출발한 순서가 아닐 수도 있다 - 따라서 <strong>Orderly delivery</strong>를 지원하지 않게 되는 것</li>
<li>현재 IP망만 Datagram방식을 사용해 통신하고 있고, 전화망같은 다른 망의 경우에는 뒤이어 설명하는 Virtual Circuit방식을 사용한다 - 생각해보면 당연한일 - 전화의 경우 순서가 중요한데 순서가 바뀔 수 있는 Datagram으로 보내는 것은 이상하제</li>
</ul>
<h3 id="virtual-circuit">Virtual Circuit<a aria-hidden="true" tabindex="-1" href="#virtual-circuit" class="internal"> §</a></h3>
<ul>
<li><strong>Virtual Circuit</strong>의 경우에는 패킷화해서 분리된 패킷들이 항상 같은 경로를 따라 가게 되는 방식이다</li>
<li>그리고 이를 위해 <strong>Connect / Disconnect</strong>과정이 들어간다</li>
<li>Virtual circuit의 작동방식은 다음과 같다</li>
</ul>
<h4 id="1-connect-phase">1. Connect Phase<a aria-hidden="true" tabindex="-1" href="#1-connect-phase" class="internal"> §</a></h4>
<p><img src="../../../../gardens/network/originals/comnet.fall.2021.cse.cnu.ac.kr/images/02_c838e9f353ea4739a7de8281a9e81ba1/image4.png" alt="%E1%84%8B%E1%85%B5%E1%84%85%E1%85%A9%E1%86%AB02%20-%20Network%20Layer%20c838e9f353ea4739a7de8281a9e81ba1/image4.png"/></p>
<ul>
<li>일단 위와 같은 망에서 B → D로 보낸다고 하자</li>
<li>그럼 패킷들을 보내기 앞서 다음과 같은 구조의 컨트롤 패킷을 B가 먼저 보낸다</li>
</ul>
<p><img src="../../../../gardens/network/originals/comnet.fall.2021.cse.cnu.ac.kr/images/02_c838e9f353ea4739a7de8281a9e81ba1/image5.png" alt="%E1%84%8B%E1%85%B5%E1%84%85%E1%85%A9%E1%86%AB02%20-%20Network%20Layer%20c838e9f353ea4739a7de8281a9e81ba1/image5.png"/></p>
<ul>
<li>보면 일단 Connect packet인 것을 나타내기 위한 정보와 함께 <strong>Virtual circuit number</strong>, 송수신지 주소가 들어간다</li>
<li><strong>Virtual circuit number</strong>는 예시 보다 보면 왜필요한지 딱알게 된다 - 약간 통신 id같은 느낌임</li>
</ul>
<p><img src="../../../../gardens/network/originals/comnet.fall.2021.cse.cnu.ac.kr/images/02_c838e9f353ea4739a7de8281a9e81ba1/image6.png" alt="%E1%84%8B%E1%85%B5%E1%84%85%E1%85%A9%E1%86%AB02%20-%20Network%20Layer%20c838e9f353ea4739a7de8281a9e81ba1/image6.png"/></p>
<ul>
<li>Connect phase가 끝나고 나면 다음과 같은 구조가 되는데 어떻게 이래되는지 보자</li>
<li>일단 B가 1번으로 보내는게 좋겠다고 판단해 connect packet을 보내며 자신의 <strong>virtual circuit table</strong>에 행을 하나 추가한다 - virtual circuit number는 자기가 보낸 virtual circuit number인 0, 송신지는 자신이니까 적을 필요 없고 수신지는 1번 노드 - <strong>virtual circuit table</strong>은 현재 진행되고 있는 virtual circuit 정보를 저장하는 테이블</li>
<li>그리고 1번 노드가 이걸 받고 2번으로 보내는게 좋겠다고 판단하면 2번으로 connect packet을 전달하며 자신의 virtual circuit table에도 행을 하나 추가한다 - virtual circuit number는 받은 connect packet에 담긴 번호인 0, 송신지는 B, 수신지는 2번</li>
<li>마찬가지로 2번 노드도 connect packet을 전달받고 3번 노드로 보내는게 좋겠다고 판단한 경우 3번으로 전달하며 자신의 virtual circuit table에도 행을 하나 추가한다 - virtual circuit number는 받은 connect packet에 담긴 번호인 0, 송신지는 1, 수신지는 3</li>
<li>3번 노드에서도 동일한 과정을 거치고 D가 받은 다음에도 동일하게 virtual circuit 0에 대한 정보를 자신의 virtual circuit table에 넣는다</li>
<li>이렇게 각 노드마다 virtual circuit table에 행이 하나씩 들어가게 되면 Connect phase가 끝이난다</li>
</ul>
<h4 id="2-data-transfer-phase">2. Data Transfer Phase<a aria-hidden="true" tabindex="-1" href="#2-data-transfer-phase" class="internal"> §</a></h4>
<p><img src="../../../../gardens/network/originals/comnet.fall.2021.cse.cnu.ac.kr/images/02_c838e9f353ea4739a7de8281a9e81ba1/image7.png" alt="%E1%84%8B%E1%85%B5%E1%84%85%E1%85%A9%E1%86%AB02%20-%20Network%20Layer%20c838e9f353ea4739a7de8281a9e81ba1/image7.png"/></p>
<ul>
<li>Connect phase 가 끝나고 나서 이제 B가 위의 그림과 같은 패킷들을 전송한다 - 여기서 중요한 점은 패킷의 헤더에 송수신지 주소가 들어가는게 아니고 virtual circuit number랑 몇번째 패킷인지의 정보가 들어가게 된다는 것이다</li>
<li>왜냐하면 virtual circuit number가 0인 통신에 대한 경로가 다 각각 노드의 virtual circuit table에 들어가 있기 때문에 virtual circuit number만 보내도 경로를 따라갈 수 있기 때문</li>
<li>B가 virtual circuit table을 보고 1번으로 보내야겠다는것을 알아낸 뒤, 1번 노드로 패킷을 보낸다</li>
<li>그럼 1번노드는 패킷을 받아들고 virtual circuit table에 가서 확인한다 - virtual circuit number가 0이고 송신지가 B이므로 2번으로 보내야 된다는 것을 알아내게 됨 - 따라서 1번 노드는 패킷을 2번노드로 보내게 된다</li>
<li>2번 노드도 마찬가지로 패킷을 받은 뒤 virtual circuit table에 가서 어디로 보내야되는지 찾는다 - virtual circuit number가 0번이고 송신지가 1번이므로 3번으로 보내야 되는 것을 알아냄 - 따라서 2번 노드는 3번노드로 보내게 된다</li>
<li>3번 노드도 동일한 과정을 거치게 되고 결과적으로 모든 패킷이 같은 경로를 따라 D번 노드에 도착하게 된다</li>
</ul>
<h4 id="3-disconnect-phase">3. Disconnect Phase<a aria-hidden="true" tabindex="-1" href="#3-disconnect-phase" class="internal"> §</a></h4>
<ul>
<li>통신이 끝난 뒤에 각각 노드의 virtual circuit table에 해당 행을 지워 저장공간을 확보해야 된다 - 하지만 각각 노드는 통신이 끝났는지 모르기 때문에 <strong>Disconnect Phase</strong>가 진행되게 되는 것</li>
</ul>
<p><img src="../../../../gardens/network/originals/comnet.fall.2021.cse.cnu.ac.kr/images/02_c838e9f353ea4739a7de8281a9e81ba1/image8.png" alt="%E1%84%8B%E1%85%B5%E1%84%85%E1%85%A9%E1%86%AB02%20-%20Network%20Layer%20c838e9f353ea4739a7de8281a9e81ba1/image8.png"/></p>
<ul>
<li>통신이 끝난 뒤에 B는 위와 같은 <strong>Disconnect packet</strong>을 전송하게 된다 - virtual circuit table을 보고 1번으로 보내야 한다는 것을 알아낸 뒤 1번으로 보내고 자신의 virtual circuit table에서 해당 행을 지운다</li>
<li>Disconnect packet을 받아든 1번 노드는 virtual circuit number가 0번이고 송신지가 B인 행을 찾은 뒤 2번으로 보내야 된다는 것을 알아낸다 - 이후 2번으로 보내고 자신의 virtual circuit table에서 해당 행을 지운다</li>
<li>2번과 3번, D에서도 동일한 과정을 거치게 되고 결과적으로 모든 노드에서 이번 통신에 대한 virtual circuit 정보가 지워지게 된다</li>
</ul>
<p><img src="../../../../gardens/network/originals/comnet.fall.2021.cse.cnu.ac.kr/images/02_c838e9f353ea4739a7de8281a9e81ba1/image9.png" alt="%E1%84%8B%E1%85%B5%E1%84%85%E1%85%A9%E1%86%AB02%20-%20Network%20Layer%20c838e9f353ea4739a7de8281a9e81ba1/image9.png"/></p>
<ul>
<li><strong>Virtual Circuit</strong>방식은 패킷들이 항상 같은 경로를 따라가기 때문에 복잡하긴하지만 송신순서와 동일한 순서로 수신되게 된다 - <strong>Orderly Delivery</strong>를 지원한다</li>
<li>옛날에는 순서대로 가는 것이 당연하다 생각했기 때문에 역사가 오래된 방식이며 IP를 제외한 대부분의 통신이 이 방식을 사용하게 된다</li>
</ul>
<h2 id="example-code">Example code<a aria-hidden="true" tabindex="-1" href="#example-code" class="internal"> §</a></h2>
<p><img src="../../../../gardens/network/originals/comnet.fall.2021.cse.cnu.ac.kr/images/02_c838e9f353ea4739a7de8281a9e81ba1/image10.png" alt="%E1%84%8B%E1%85%B5%E1%84%85%E1%85%A9%E1%86%AB02%20-%20Network%20Layer%20c838e9f353ea4739a7de8281a9e81ba1/image10.png"/></p>
<ul>
<li>Packet은 종착역에 도착할때까지 변하지 않지만 Frame의 물리주소는 계속 바뀌게 된다</li>
</ul>
<p><img src="../../../../gardens/network/originals/comnet.fall.2021.cse.cnu.ac.kr/images/02_c838e9f353ea4739a7de8281a9e81ba1/image11.png" alt="%E1%84%8B%E1%85%B5%E1%84%85%E1%85%A9%E1%86%AB02%20-%20Network%20Layer%20c838e9f353ea4739a7de8281a9e81ba1/image11.png"/></p>
<ul>
<li>위와 같은 구조를 대강 코드로 짜보면 아래와 같다 - 다만 위의 그림에서는 Frame의 색깔이 전부 동일하게 표현되었지만 위에서 말한거처럼 Frame의 내용은 매번 달라진다 - Packet이 동일하게 유지되는거고 Frame은 물리주소가 계속 바뀌기 때문에 달라짐</li>
</ul>
<p><img src="../../../../gardens/network/originals/comnet.fall.2021.cse.cnu.ac.kr/images/02_c838e9f353ea4739a7de8281a9e81ba1/image12.png" alt="%E1%84%8B%E1%85%B5%E1%84%85%E1%85%A9%E1%86%AB02%20-%20Network%20Layer%20c838e9f353ea4739a7de8281a9e81ba1/image12.png"/></p>
<ul>
<li>일단 이건 packet과 frame의 자료구조</li>
</ul>
<p><img src="../../../../gardens/network/originals/comnet.fall.2021.cse.cnu.ac.kr/images/02_c838e9f353ea4739a7de8281a9e81ba1/image13.png" alt="%E1%84%8B%E1%85%B5%E1%84%85%E1%85%A9%E1%86%AB02%20-%20Network%20Layer%20c838e9f353ea4739a7de8281a9e81ba1/image13.png"/></p>
<ul>
<li>이건 Sender의 코드</li>
</ul>
<p><img src="../../../../gardens/network/originals/comnet.fall.2021.cse.cnu.ac.kr/images/02_c838e9f353ea4739a7de8281a9e81ba1/image14.png" alt="%E1%84%8B%E1%85%B5%E1%84%85%E1%85%A9%E1%86%AB02%20-%20Network%20Layer%20c838e9f353ea4739a7de8281a9e81ba1/image14.png"/></p>
<ul>
<li>이건 1~4번 노드의 코드 - Intermediate node의 경우에는 Network layer까지밖에 없기 때문에 main()함수가 Network layer의 역할을 하고 있다</li>
</ul>
<p><img src="../../../../gardens/network/originals/comnet.fall.2021.cse.cnu.ac.kr/images/02_c838e9f353ea4739a7de8281a9e81ba1/image15.png" alt="%E1%84%8B%E1%85%B5%E1%84%85%E1%85%A9%E1%86%AB02%20-%20Network%20Layer%20c838e9f353ea4739a7de8281a9e81ba1/image15.png"/></p>
<ul>
<li>이건 Receiver의 코드</li>
<li>위의 코드들은 걍 한 읽어보면 뭐 어떻게 작동하는지 알 수 있을것이다</li>
<li>여기서 중요한건 일단</li>
<li><strong>Transparency</strong>가 잘 지켜져야 된다는 것이다 - 보면 Network layer에서만 packet_type이 등장하고 다른 layer에서는 등장하지 않음 - 마찬가지로 Data link layer에서만 frame_type이 등장하고 다른 layer에서는 등장하지 않는다
<ul>
<li>Sender의 경우에 main()에서 Packet을 생성하여 send_data()를 호출할 수도 있지만 그렇게 하지 않고 주소와 데이터를 전달해 send_data()에서 packet을 생성하는 이유가 이러한 이유에서인 것</li>
<li>이렇게 하는 이유는 만약에 Packet의 구조가 달라졌을 때 network계층만 손보면 되기 때문 - 그 상위계층에서 Packet을 만들어 전달하는 구조였다면 Packet의 구조가 바뀌게 되었을 때 상위계층의 구현도 바꿔줘야 하는 문제점이 발생하게 된다</li>
<li>하지만 <strong>Transparency</strong>라는 것이 모든걸 다 숨긴다는 것이 아니다 - 각 계층의 자료구조를 숨긴다는 것이고 위의 예제에서 보는것처럼 각 계층에서 사용하는 주소의 경우에는 상위 계층에서도 사용할 수 있다</li>
</ul>
</li>
<li>또한 항상 상위계층에서 하위계층의 함수를 호출하는 방식으로 구현된다는 점이다
<ul>
<li>일단 sender의 경우에는 상위 계층에서 하위계층으로 전달하는 방식이기 때문에 이와 같은 구조가 이상하지 않음</li>
<li>하지만 receiver의 경우에는 하위계층에서 상위계층으로 전달하는 방식이지만 함수호출은 상위계층에서 하위계층으로 이루어지게 된다</li>
<li>왜냐면 상위계층에서 하위계층의 함수를 호출하고, 하위계층에서는 패킷 / 프레임이 도착할때까지 기다렸다가 도착하면 처리한 다음에 return하거나 주소를 참조하는 방식으로 상위계층에 전달하는 구조이기 때문</li>
<li>main()함수에는 항상 최상위 계층의 코드가 들어가게 되는 것이 이러한 이유에서이다</li>
</ul>
</li>
</ul></article></div><div class="right sidebar"><div class="graph "><h3>Graph View</h3><div class="graph-outer"><div id="graph-container" data-cfg="{&quot;drag&quot;:true,&quot;zoom&quot;:true,&quot;depth&quot;:1,&quot;scale&quot;:1.1,&quot;repelForce&quot;:0.5,&quot;centerForce&quot;:0.3,&quot;linkDistance&quot;:30,&quot;fontSize&quot;:0.6,&quot;opacityScale&quot;:1,&quot;showTags&quot;:true,&quot;removeTags&quot;:[]}"></div><svg version="1.1" id="global-graph-icon" xmlns="http://www.w3.org/2000/svg" xmlnsXlink="http://www.w3.org/1999/xlink" x="0px" y="0px" viewBox="0 0 55 55" fill="currentColor" xmlSpace="preserve"><path d="M49,0c-3.309,0-6,2.691-6,6c0,1.035,0.263,2.009,0.726,2.86l-9.829,9.829C32.542,17.634,30.846,17,29,17
	s-3.542,0.634-4.898,1.688l-7.669-7.669C16.785,10.424,17,9.74,17,9c0-2.206-1.794-4-4-4S9,6.794,9,9s1.794,4,4,4
	c0.74,0,1.424-0.215,2.019-0.567l7.669,7.669C21.634,21.458,21,23.154,21,25s0.634,3.542,1.688,4.897L10.024,42.562
	C8.958,41.595,7.549,41,6,41c-3.309,0-6,2.691-6,6s2.691,6,6,6s6-2.691,6-6c0-1.035-0.263-2.009-0.726-2.86l12.829-12.829
	c1.106,0.86,2.44,1.436,3.898,1.619v10.16c-2.833,0.478-5,2.942-5,5.91c0,3.309,2.691,6,6,6s6-2.691,6-6c0-2.967-2.167-5.431-5-5.91
	v-10.16c1.458-0.183,2.792-0.759,3.898-1.619l7.669,7.669C41.215,39.576,41,40.26,41,41c0,2.206,1.794,4,4,4s4-1.794,4-4
	s-1.794-4-4-4c-0.74,0-1.424,0.215-2.019,0.567l-7.669-7.669C36.366,28.542,37,26.846,37,25s-0.634-3.542-1.688-4.897l9.665-9.665
	C46.042,11.405,47.451,12,49,12c3.309,0,6-2.691,6-6S52.309,0,49,0z M11,9c0-1.103,0.897-2,2-2s2,0.897,2,2s-0.897,2-2,2
	S11,10.103,11,9z M6,51c-2.206,0-4-1.794-4-4s1.794-4,4-4s4,1.794,4,4S8.206,51,6,51z M33,49c0,2.206-1.794,4-4,4s-4-1.794-4-4
	s1.794-4,4-4S33,46.794,33,49z M29,31c-3.309,0-6-2.691-6-6s2.691-6,6-6s6,2.691,6,6S32.309,31,29,31z M47,41c0,1.103-0.897,2-2,2
	s-2-0.897-2-2s0.897-2,2-2S47,39.897,47,41z M49,10c-2.206,0-4-1.794-4-4s1.794-4,4-4s4,1.794,4,4S51.206,10,49,10z"></path></svg></div><div id="global-graph-outer"><div id="global-graph-container" data-cfg="{&quot;drag&quot;:true,&quot;zoom&quot;:true,&quot;depth&quot;:-1,&quot;scale&quot;:0.9,&quot;repelForce&quot;:0.5,&quot;centerForce&quot;:0.3,&quot;linkDistance&quot;:30,&quot;fontSize&quot;:0.6,&quot;opacityScale&quot;:1,&quot;showTags&quot;:true,&quot;removeTags&quot;:[]}"></div></div></div><div class="toc desktop-only"><button type="button" id="toc"><h3>Table of Contents</h3><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="fold"><polyline points="6 9 12 15 18 9"></polyline></svg></button><div id="toc-content"><ul class="overflow"><li class="depth-0"><a href="#ip" data-for="ip">IP</a></li><li class="depth-0"><a href="#packet-switching" data-for="packet-switching">Packet Switching</a></li><li class="depth-1"><a href="#principles-of-packet-switching" data-for="principles-of-packet-switching">Principles of Packet Switching</a></li><li class="depth-0"><a href="#two-types-of-packet-switching" data-for="two-types-of-packet-switching">Two types of packet switching</a></li><li class="depth-1"><a href="#datagram" data-for="datagram">Datagram</a></li><li class="depth-1"><a href="#virtual-circuit" data-for="virtual-circuit">Virtual Circuit</a></li><li class="depth-0"><a href="#example-code" data-for="example-code">Example code</a></li></ul></div></div><div class="backlinks "><h3>Backlinks</h3><ul class="overflow"><li><a href="../../../../gardens/network/originals/comnet.fall.2021.cse.cnu.ac.kr/(충남대)-컴퓨터-네트워크-강의록" class="internal">(충남대) 컴퓨터 네트워크 강의록</a></li></ul></div></div></div><footer class><hr/><p>Created with <a href="https://quartz.jzhao.xyz/">Quartz v4.1.0</a>, © 2024</p><ul><li><a href="https://github.com/haeramkeem">GitHub</a></li><li><a href="www.linkedin.com/in/haeram-kim-277404220">LinkedIn</a></li><li><a href="mailto:haeram.kim1@gmail.com">Email</a></li></ul></footer></div></body><script type="application/javascript">// quartz/components/scripts/quartz/components/scripts/callout.inline.ts
function toggleCallout() {
  const outerBlock = this.parentElement;
  outerBlock.classList.toggle(`is-collapsed`);
  const collapsed = outerBlock.classList.contains(`is-collapsed`);
  const height = collapsed ? this.scrollHeight : outerBlock.scrollHeight;
  outerBlock.style.maxHeight = height + `px`;
  let current = outerBlock;
  let parent = outerBlock.parentElement;
  while (parent) {
    if (!parent.classList.contains(`callout`)) {
      return;
    }
    const collapsed2 = parent.classList.contains(`is-collapsed`);
    const height2 = collapsed2 ? parent.scrollHeight : parent.scrollHeight + current.scrollHeight;
    parent.style.maxHeight = height2 + `px`;
    current = parent;
    parent = parent.parentElement;
  }
}
function setupCallout() {
  const collapsible = document.getElementsByClassName(
    `callout is-collapsible`
  );
  for (const div of collapsible) {
    const title = div.firstElementChild;
    if (title) {
      title.removeEventListener(`click`, toggleCallout);
      title.addEventListener(`click`, toggleCallout);
      const collapsed = div.classList.contains(`is-collapsed`);
      const height = collapsed ? title.scrollHeight : div.scrollHeight;
      div.style.maxHeight = height + `px`;
    }
  }
}
document.addEventListener(`nav`, setupCallout);
window.addEventListener(`resize`, setupCallout);
</script><script type="module">
          import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.esm.min.mjs';
          const darkMode = document.documentElement.getAttribute('saved-theme') === 'dark'
          mermaid.initialize({
            startOnLoad: false,
            securityLevel: 'loose',
            theme: darkMode ? 'dark' : 'default'
          });
          document.addEventListener('nav', async () => {
            await mermaid.run({
              querySelector: '.mermaid'
            })
          });
          </script><script src="https://cdn.jsdelivr.net/npm/katex@0.16.7/dist/contrib/copy-tex.min.js" type="application/javascript"></script><script src="https://www.googletagmanager.com/gtag/js?id=G-N68CCP1QHG" type="application/javascript"></script><script src="../../../../postscript.js" type="module"></script></html>