<!DOCTYPE html>
<html><head><title>07. MAC</title><meta charSet="utf-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:title" content="07. MAC"/><meta property="og:description" content="충남대학교 컴퓨터공학과 김상하 교수님의 &amp;quot;데이터 통신&amp;quot; 강의를 필기한 내용입니다. 다소 잘못된 내용과 구어적 표현 이 포함되어 있을 수 있습니다. Multiple Access Control(MAC) § Data link layer에서 Data link control(지금까지 배운 거)와 함께 제일 중요한 내용이다 하나의 매체(회선)을 여러명이 접근할 수 있게 하는 기술 - 이럴 때 혼선/충돌이 일어나지 않게 하는 기술 한사람이 데이터를 보낼때는 다른사람은 보내지 않다가 이사람이 끝나면 그때기 보내기 시작하는 방법을 이용한다 에러는 회선에서의 자연적인 노이즈때문에 에러가 나기도 하지만 다른사람의 데이터랑 충돌해서 에러가 나기도 한다 - 이때 충돌에 의한 에러는 자연적 요인이 아니므로 우리가 어느정도 제어가 가능하다."/><meta property="og:image" content="https://mdg.haeramk.im/static/og-image.png"/><meta property="og:width" content="1200"/><meta property="og:height" content="675"/><link rel="icon" href="../../../../static/icon.png"/><meta name="description" content="충남대학교 컴퓨터공학과 김상하 교수님의 &amp;quot;데이터 통신&amp;quot; 강의를 필기한 내용입니다. 다소 잘못된 내용과 구어적 표현 이 포함되어 있을 수 있습니다. Multiple Access Control(MAC) § Data link layer에서 Data link control(지금까지 배운 거)와 함께 제일 중요한 내용이다 하나의 매체(회선)을 여러명이 접근할 수 있게 하는 기술 - 이럴 때 혼선/충돌이 일어나지 않게 하는 기술 한사람이 데이터를 보낼때는 다른사람은 보내지 않다가 이사람이 끝나면 그때기 보내기 시작하는 방법을 이용한다 에러는 회선에서의 자연적인 노이즈때문에 에러가 나기도 하지만 다른사람의 데이터랑 충돌해서 에러가 나기도 한다 - 이때 충돌에 의한 에러는 자연적 요인이 아니므로 우리가 어느정도 제어가 가능하다."/><meta name="generator" content="Quartz"/><link rel="preconnect" href="https://fonts.googleapis.com"/><link rel="preconnect" href="https://fonts.gstatic.com"/><link href="../../../../index.css" rel="stylesheet" type="text/css" spa-preserve/><link href="https://cdn.jsdelivr.net/npm/katex@0.16.0/dist/katex.min.css" rel="stylesheet" type="text/css" spa-preserve/><link href="https://fonts.googleapis.com/css2?family=IBM Plex Mono&amp;family=Gowun Batang:wght@400;700&amp;family=Gowun Dodum:ital,wght@0,400;0,600;1,400;1,600&amp;display=swap" rel="stylesheet" type="text/css" spa-preserve/><script src="../../../../prescript.js" type="application/javascript" spa-preserve></script><script type="application/javascript" spa-preserve>const fetchData = fetch(`../../../../static/contentIndex.json`).then(data => data.json())</script></head><body data-slug="gardens/network/originals/datacommunication.spring.2021.cse.cnu.ac.kr/07.-MAC"><div id="quartz-root" class="page"><div id="quartz-body"><div class="left sidebar"><h1 class="page-title "><a href="../../../..">Madison Digital Garden</a></h1><div class="spacer mobile-only"></div><div class="search "><div id="search-icon"><p>Search</p><div></div><svg tabIndex="0" aria-labelledby="title desc" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 19.9 19.7"><title id="title">Search</title><desc id="desc">Search</desc><g class="search-path" fill="none"><path stroke-linecap="square" d="M18.5 18.3l-5.4-5.4"></path><circle cx="8" cy="8" r="7"></circle></g></svg></div><div id="search-container"><div id="search-space"><input autocomplete="off" id="search-bar" name="search" type="text" aria-label="Search for something" placeholder="Search for something"/><div id="results-container"></div></div></div></div><div class="darkmode "><input class="toggle" id="darkmode-toggle" type="checkbox" tabIndex="-1"/><label id="toggle-label-light" for="darkmode-toggle" tabIndex="-1"><svg xmlns="http://www.w3.org/2000/svg" xmlnsXlink="http://www.w3.org/1999/xlink" version="1.1" id="dayIcon" x="0px" y="0px" viewBox="0 0 35 35" style="enable-background:new 0 0 35 35;" xmlSpace="preserve"><title>Light mode</title><path d="M6,17.5C6,16.672,5.328,16,4.5,16h-3C0.672,16,0,16.672,0,17.5    S0.672,19,1.5,19h3C5.328,19,6,18.328,6,17.5z M7.5,26c-0.414,0-0.789,0.168-1.061,0.439l-2,2C4.168,28.711,4,29.086,4,29.5    C4,30.328,4.671,31,5.5,31c0.414,0,0.789-0.168,1.06-0.44l2-2C8.832,28.289,9,27.914,9,27.5C9,26.672,8.329,26,7.5,26z M17.5,6    C18.329,6,19,5.328,19,4.5v-3C19,0.672,18.329,0,17.5,0S16,0.672,16,1.5v3C16,5.328,16.671,6,17.5,6z M27.5,9    c0.414,0,0.789-0.168,1.06-0.439l2-2C30.832,6.289,31,5.914,31,5.5C31,4.672,30.329,4,29.5,4c-0.414,0-0.789,0.168-1.061,0.44    l-2,2C26.168,6.711,26,7.086,26,7.5C26,8.328,26.671,9,27.5,9z M6.439,8.561C6.711,8.832,7.086,9,7.5,9C8.328,9,9,8.328,9,7.5    c0-0.414-0.168-0.789-0.439-1.061l-2-2C6.289,4.168,5.914,4,5.5,4C4.672,4,4,4.672,4,5.5c0,0.414,0.168,0.789,0.439,1.06    L6.439,8.561z M33.5,16h-3c-0.828,0-1.5,0.672-1.5,1.5s0.672,1.5,1.5,1.5h3c0.828,0,1.5-0.672,1.5-1.5S34.328,16,33.5,16z     M28.561,26.439C28.289,26.168,27.914,26,27.5,26c-0.828,0-1.5,0.672-1.5,1.5c0,0.414,0.168,0.789,0.439,1.06l2,2    C28.711,30.832,29.086,31,29.5,31c0.828,0,1.5-0.672,1.5-1.5c0-0.414-0.168-0.789-0.439-1.061L28.561,26.439z M17.5,29    c-0.829,0-1.5,0.672-1.5,1.5v3c0,0.828,0.671,1.5,1.5,1.5s1.5-0.672,1.5-1.5v-3C19,29.672,18.329,29,17.5,29z M17.5,7    C11.71,7,7,11.71,7,17.5S11.71,28,17.5,28S28,23.29,28,17.5S23.29,7,17.5,7z M17.5,25c-4.136,0-7.5-3.364-7.5-7.5    c0-4.136,3.364-7.5,7.5-7.5c4.136,0,7.5,3.364,7.5,7.5C25,21.636,21.636,25,17.5,25z"></path></svg></label><label id="toggle-label-dark" for="darkmode-toggle" tabIndex="-1"><svg xmlns="http://www.w3.org/2000/svg" xmlnsXlink="http://www.w3.org/1999/xlink" version="1.1" id="nightIcon" x="0px" y="0px" viewBox="0 0 100 100" style="enable-background='new 0 0 100 100'" xmlSpace="preserve"><title>Dark mode</title><path d="M96.76,66.458c-0.853-0.852-2.15-1.064-3.23-0.534c-6.063,2.991-12.858,4.571-19.655,4.571  C62.022,70.495,50.88,65.88,42.5,57.5C29.043,44.043,25.658,23.536,34.076,6.47c0.532-1.08,0.318-2.379-0.534-3.23  c-0.851-0.852-2.15-1.064-3.23-0.534c-4.918,2.427-9.375,5.619-13.246,9.491c-9.447,9.447-14.65,22.008-14.65,35.369  c0,13.36,5.203,25.921,14.65,35.368s22.008,14.65,35.368,14.65c13.361,0,25.921-5.203,35.369-14.65  c3.872-3.871,7.064-8.328,9.491-13.246C97.826,68.608,97.611,67.309,96.76,66.458z"></path></svg></label></div></div><div class="center"><div class="page-header"><div class="popover-hint"><h1 class="article-title ">07. MAC</h1><p class="content-meta ">Sep 29, 2024, 30 min read</p></div></div><article class="popover-hint"><blockquote class="callout" data-callout="info">
<div class="callout-title">
                  <div class="callout-icon"><svg xmlns="http://www.w3.org/2000/svg" width="100%" height="100%" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="10"></circle><line x1="12" y1="16" x2="12" y2="12"></line><line x1="12" y1="8" x2="12.01" y2="8"></line></svg></div>
                  <div class="callout-title-inner"><p>충남대학교 컴퓨터공학과 김상하 교수님의 &quot;데이터 통신&quot; 강의를 필기한 내용입니다. </p></div>
                  
                </div>
</blockquote>
<blockquote class="callout" data-callout="warning">
<div class="callout-title">
                  <div class="callout-icon"><svg xmlns="http://www.w3.org/2000/svg" width="100%" height="100%" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="m21.73 18-8-14a2 2 0 0 0-3.48 0l-8 14A2 2 0 0 0 4 21h16a2 2 0 0 0 1.73-3Z"></path><line x1="12" y1="9" x2="12" y2="13"></line><line x1="12" y1="17" x2="12.01" y2="17"></line></svg></div>
                  <div class="callout-title-inner"><p>다소 잘못된 내용과 구어적 표현 이 포함되어 있을 수 있습니다. </p></div>
                  
                </div>
</blockquote>
<h2 id="multiple-access-controlmac">Multiple Access Control(MAC)<a aria-hidden="true" tabindex="-1" href="#multiple-access-controlmac" class="internal"> §</a></h2>
<ul>
<li>Data link layer에서 Data link control(지금까지 배운 거)와 함께 제일 중요한 내용이다</li>
<li>하나의 매체(회선)을 여러명이 접근할 수 있게 하는 기술 - 이럴 때 혼선/충돌이 일어나지 않게 하는 기술</li>
<li>한사람이 데이터를 보낼때는 다른사람은 보내지 않다가 이사람이 끝나면 그때기 보내기 시작하는 방법을 이용한다</li>
<li>에러는 회선에서의 자연적인 노이즈때문에 에러가 나기도 하지만 다른사람의 데이터랑 충돌해서 에러가 나기도 한다 - 이때 충돌에 의한 에러는 자연적 요인이 아니므로 우리가 어느정도 제어가 가능하다. 따라서 이러한 에러를 최대한 줄이고자 하는 것이 **Multiple Access Control(Resolution)**이며, 자연적이거나 충돌에 의한 에러가 있음에도 ACK, NAK등의 기법을 이용해 제대로 수신할 수 있는 방안을 마련한 것이 <strong>Data Link Control</strong>이다</li>
<li>즉, 정리해보면 다음과 같다
<ul>
<li><strong>Physical Layer</strong>는 자연적으로 일어나는 노이즈 등으로부터 최대한 에러가 발생하지 않게 막는 계층이고</li>
<li>Data Link Layer의 <strong>Data Link Control</strong>은 에러가 나도 재전송받거나 correction등의 방법을 통해 에러가 전혀 없게 하는 역할이고</li>
<li>Data Link Layer의 <strong>Media Access Control</strong>은 데이터들 간의 충돌에 의한 에러를 막는 역할인 것이다</li>
</ul>
</li>
<li>MAC은 크게 <strong>Random Access Protocol</strong>, <strong>Controlled Access Protocol</strong>, <strong>Channelization Protocol</strong>이렇게 나누어진다 - 하지만 얘네들이 별개가 아니라 다 통합되더라</li>
</ul>
<h2 id="random-access">Random Access<a aria-hidden="true" tabindex="-1" href="#random-access" class="internal"> §</a></h2>
<ul>
<li>데이터를 보내고자 하는 포인트들이 경쟁을 통해 그 매체의 이용권을 얻는 것</li>
<li>순전히 경쟁을 통해 이용권을 얻으므로 랜덤하게 이용권이 주어진다 - 즉, 운나쁘면 한놈이 오랫동안 점유하는것도 가능하다 이말이야 - 이러한 특성을 <strong>Memoryless property</strong>라고 한다</li>
</ul>
<h2 id="aloha-알고리즘">ALOHA 알고리즘<a aria-hidden="true" tabindex="-1" href="#aloha-알고리즘" class="internal"> §</a></h2>
<ul>
<li>봐봐라</li>
<li>만약에 프레임 여러개가 겹쳐서 충돌이 났다 쳐봐라</li>
<li>그러면 이제 충돌난애들은 ack가 안오므로 타임아웃이 걸려 다시 보내것제?</li>
<li>근데 만약에 컴퓨터들마다 타임아웃 걸리는 시간이 다 똑같이 설정되어있으면</li>
<li>아까처럼 똑같이 보내고 다같이 충돌나게 되더라 이말이여</li>
<li>이러한 문제를 해결하는게 ALOHA 알고리즘이다</li>
</ul>
<p><img src="../../../../gardens/network/originals/datacommunication.spring.2021.cse.cnu.ac.kr/images/07_11f3b00bf54a426f96184c589fc5668d/image1.png" alt="%E1%84%8B%E1%85%B5%E1%84%85%E1%85%A9%E1%86%AB07%20-%20MAC%2011f3b00bf54a426f96184c589fc5668d/image1.png"/></p>
<ul>
<li>여기서 <strong>Tp</strong>란 데이터가 한번 전송되는데 걸리는 시간이다. 근데 데이터를 보내고 ack를 받아야 하므로 왕복이니까 2를 곱해주는거</li>
<li>여기서 이제 ACK를 받지 못하면 시도 횟수를 뜻하는 <strong>K</strong>를 1 올리게 된다 이 K는 일반적으로 15를 최대치로 두며 이 최대치를 넘어가면 Abort(포기)한다 - 15번을 반복해서 보내보고 안되면 포기한다는 뜻</li>
<li>그리고 이번에는. 임의의 시간간격동안 기다린 다음 프레임을 전송한다.
<ul>
<li>위에서 말한 저 충돌 이후에도 모두가 같은시간을 기다린후 다같이 보내 또다시 충돌이 일어나는 문제를 해결하기 위해 다른 컴퓨터와의 랜덤한 시간차를 두는 것 이다</li>
<li>여기서 난수는 <strong>0~(2^k - 1)</strong> 중에 아무 숫자나 랜덤으로 고르는 과정을 거치는데 이것을 <strong>Binary Back-off</strong> 라고 하고 이로부터 결정을 <strong>R</strong>로 표현한다</li>
<li>그리고 <strong>R * Tp</strong>를 통해 대기시간을 산정하고 대기한다</li>
</ul>
</li>
<li>하지만 단점이 있다 - 실제로 써보니까 딴놈의 전송이 거의 다 끝나갈때쯤에 또 딴놈이 전송시작하고 이런식으로 걸치는 일이 많이 일어나더라 - 효율을 계산해봤더니 매체의 최대 전송 역량중 20프로밖에 발휘를 못하더라</li>
</ul>
<h2 id="slotted-aloha-알고리즘">Slotted ALOHA 알고리즘<a aria-hidden="true" tabindex="-1" href="#slotted-aloha-알고리즘" class="internal"> §</a></h2>
<ul>
<li>얘는 이제 그냥 ALOHA 알고리즘과 동일하나 슬롯을 정해서 이때만 보낼 수 있다는 개념이다</li>
</ul>
<p><img src="../../../../gardens/network/originals/datacommunication.spring.2021.cse.cnu.ac.kr/images/07_11f3b00bf54a426f96184c589fc5668d/image2.png" alt="%E1%84%8B%E1%85%B5%E1%84%85%E1%85%A9%E1%86%AB07%20-%20MAC%2011f3b00bf54a426f96184c589fc5668d/image2.png"/></p>
<ul>
<li>이게 뭔말인가 하면 내가 상위 계층으로부터 프레임을 받으면 바로 보내는게 일반적인 ALOHA 알고리즘이다 - 얘는 그럼 프레임이 출발할 수 있는 시간이 정해져있지 않고 연속적으로 분포한다</li>
<li>슬롯으로 정해져있다는 말은 위의 그림 보면 이해될거다
<ul>
<li>프레임이 출발할 수 있는 시간이 일정한 시간간격으로 정해져 있어 이때만 프레임을 보낼 수 있다는 것</li>
<li>따라서 중간에 걸쳐있으면 잠깐 기다렸다가 슬롯이 시작되는 시점에 전송되는 것</li>
</ul>
</li>
<li>그리고 슬롯 오면 바로 전송하는게 아닌 여기서도 랜덤을 사용한다 - 랜덤하게 숫자를 하나 뽑아 그 수만큼 슬롯을 넘기고 그 다음에 전송을 시작하는 것</li>
<li>얘는 이제 장점이 완전히 겹치는 경우는 존재하지만 애매하게 겹치는 경우는 존재하지 않는다는것이다 - 따라서 충돌의 확률이 줄어드는 것</li>
<li>얘는 이제 효율이 36.8프로로 기존 알로하보다 2배나 개선시킬 수 있다</li>
</ul>
<h2 id="carrier-sense-multiple-accesscsma">Carrier Sense Multiple Access(CSMA)<a aria-hidden="true" tabindex="-1" href="#carrier-sense-multiple-accesscsma" class="internal"> §</a></h2>
<ul>
<li><strong>Carrier Sense</strong>라는 것은 이제 전송매체에 귀를 기울이고 듣고 있다는 것을 뜻한다</li>
<li>이 방법은 이제 계속 주시하고있다가 아무도 매체를 이용하지 않는 시점에 전송을 시작하는 방법이다</li>
<li>충돌이 일어나는 경우는 두가지가 있다</li>
</ul>
<p><img src="../../../../gardens/network/originals/datacommunication.spring.2021.cse.cnu.ac.kr/images/07_11f3b00bf54a426f96184c589fc5668d/image3.png" alt="%E1%84%8B%E1%85%B5%E1%84%85%E1%85%A9%E1%86%AB07%20-%20MAC%2011f3b00bf54a426f96184c589fc5668d/image3.png"/></p>
<ul>
<li>첫번째는 위의 경우처럼 저쪽에서 전송을 시작했는데 아직까지 내가 있는 위치까지는 전달이 안돼서 내가 전송을 시작하게 되는 경우이다.
<ul>
<li>위의 그림에서 보면 B가 전송을 시작했는데(노란색) C까지 아직 도달하지 않아 idle하다고 판단해 프레임을 전송한다(파란색). 하지만 B의 프레임이 오던 중이었기 때문에 충돌이 일어난다(회색).</li>
<li>하지만 보통 전파속도가 아주 빠르기 때문에 흔하게 일어나지는 않는다</li>
</ul>
</li>
<li>두번째는 지금 이미 한놈이 데이터를 보내고 있고 그게 끝나기만을 기다리는 놈들이 여러명 있을 때 이제 보내던 애가 끝나자마자 얘네들이 한꺼번에 들어오게 되는 경우이다</li>
</ul>
<h3 id="기다림이-끝났을-때-어떻게-행공할것인가">기다림이 끝났을 때 어떻게 행공할것인가<a aria-hidden="true" tabindex="-1" href="#기다림이-끝났을-때-어떻게-행공할것인가" class="internal"> §</a></h3>
<p><img src="../../../../gardens/network/originals/datacommunication.spring.2021.cse.cnu.ac.kr/images/07_11f3b00bf54a426f96184c589fc5668d/image4.png" alt="%E1%84%8B%E1%85%B5%E1%84%85%E1%85%A9%E1%86%AB07%20-%20MAC%2011f3b00bf54a426f96184c589fc5668d/image4.png"/></p>
<ul>
<li>위 그림은 좀 이상하긴 함</li>
<li><strong>1-persistant</strong> : 계속 주시하다가 전송이 끝나자마자 바로 드가는 것 - 얘는 위에서 말한거처럼 여러명이 한꺼번에 들어올 수 있게 된다 - 근데 이더넷에서는 이것을 주로 사용한댄다</li>
<li><strong>non-persistant</strong> : 얘는 계속 주시하고있는게 아니고 처음에 한번 보고 아직 보내는 중이면 랜덤한 시간을 기다렸다가 본다음 없으면 그때 드가는 방법이다 - 없음이 감지되면 바로 드가긴 하지만 그 감지하는 시점을 랜덤하게 불연속적으로 가지는 것</li>
<li><strong>p-persistant</strong> : 얘도 슬롯의 개념을 이용한다
<ul>
<li>보면 위의 그림은 좀 잘못되었는데</li>
</ul>
<ol>
<li>일단 Channel이 idle한지 확인한다
<ul>
<li>idle하면 다음단계로 가고 아니면 다시 확인한다</li>
</ul>
</li>
<li><strong>Probability outcome</strong>을 하나 뽑는다. 난수를 하나 뽑는다는 소리이다. 그리고 그 수가 <strong>p</strong>라는 특정한 수보다 작은지 아닌지 확인한다
<ul>
<li>작으면 내보내고 아니면 다음단계로 넘어간다</li>
</ul>
</li>
<li>다음 슬롯을 기다리고 슬롯이 오면 Channel이 idle한지 아닌지 다시 판단한다
<ul>
<li>idle하면 다시 2번으로 가고 busy하면 다시 1번으로 간다</li>
</ul>
</li>
</ol>
</li>
<li>쟤네들 중에 뭘 사용하든 별 상관은 없다</li>
</ul>
<h2 id="csma-with-collision-detectioncsmacd">CSMA with Collision Detection(CSMA/CD)<a aria-hidden="true" tabindex="-1" href="#csma-with-collision-detectioncsmacd" class="internal"> §</a></h2>
<ul>
<li>위와 같은 CSMA기술을 이용해도 충돌을 없앨수는 없다</li>
<li>CSMA에서 충돌이 일어났는지를 알아내는 방법을 **CSMA with Collision Detection(CSMA / CD)**라고 하는 것</li>
<li>보면 파동의 중첩을 기본 원리로 한다 - 즉, 파동 두개가 겹쳐지면 중첩이 일어나 진폭의 세기가 세지는 현상을 이용하게 되는 것</li>
<li>따라서 Carrier Sencing을 했을 때 신호의 세기에 따라 구별해보면 다음과 같다
<ol>
<li><strong>세기가 0</strong> : idle한(비어있는) 상태</li>
<li><strong>세기가 정상</strong> : busy(누군가가 전송중)인 상태</li>
<li><strong>세기가 비정상</strong> : 충돌이 일어난 상태</li>
</ol>
</li>
</ul>
<h3 id="충돌을-감지했을때-좋은점">충돌을 감지했을때 좋은점<a aria-hidden="true" tabindex="-1" href="#충돌을-감지했을때-좋은점" class="internal"> §</a></h3>
<p><img src="../../../../gardens/network/originals/datacommunication.spring.2021.cse.cnu.ac.kr/images/07_11f3b00bf54a426f96184c589fc5668d/image5.png" alt="%E1%84%8B%E1%85%B5%E1%84%85%E1%85%A9%E1%86%AB07%20-%20MAC%2011f3b00bf54a426f96184c589fc5668d/image5.png"/></p>
<ul>
<li>봐봐라</li>
<li>위에 그림 보면 A가 보낼 데이터의 양이 많아 t1시간부터 그 이후로 계속 신호를 보내는 중이다</li>
<li>근데 C는 그걸 모르고 t2시간에(A가 보낸 데이터가 아직 도달하기 전에) 데이터를 전송했다고 치자</li>
<li>그럼 저 둘이만나는 지점에서 충돌이 일어나게 되고 그럼 C한테는 t3의 시점에 충돌이 감지되고, A한테는 t4의 시점에 충돌이 감지되게 된다</li>
<li>그럼 A는 저 t4시점에 신호를 끊게 된다 - 어차피 충돌이 일어났으므로 더 이상 보내는 것은 무의미하므로</li>
<li>따라서 아래 그림처럼 t4이후에 신호를 더 이상 보내지 않고 신호가 끊기게 되는 것이다</li>
<li>신호를 보내는 중에 충돌이 감지되면 신호를 더 보내지 않고 끊음으로써 무의미한 작업을 줄이고, 시간도 더 효율적으로 사용할 수 있게 된다
<ul>
<li>그냥 CSMA의 경우에는 충돌이 일어나도 다 보내게 되는데 <strong>CSMA / CD</strong>는 충돌을 감지하고 일찍 전송을 끊는다는 차이점이 있다</li>
</ul>
</li>
<li>이때 충돌이 일어나는 베스트와 워스트 경우의 수를 보면
<ul>
<li>송신측과 가까운 쪽에서 총돌이 일어나 송신측이 바로 알게 되는 경우가 제일 베스트</li>
<li>수신측과 가까운 쪽에서 충돌이 일어나 송신측이 늦게 알게 되는 경우가 제일 워스트이다</li>
</ul>
</li>
<li>그리고 이렇게 송신측이 충돌을 알게 되는데 걸리는 최대 시간은 워스트 케이스인 경우이므로 <strong>2 * 편도시간(Tp)</strong> 이다.
<ul>
<li>근데 만약 송신을 하는데 걸리는 시간이 이것보다 작고 최악의 경우가 일어나 송신을 끝내고 난 후에 충돌을 감지하게 되면 CSMA / CD 기술은 아무 효용도 없게 된다</li>
<li>따라서 <strong>CSMA / CD</strong>를 사용하려면 적어도 송신시간이 저것보단 길어야 된다</li>
</ul>
</li>
<li>따라서 CSMA / CD에 대한 플로우 차트는 다음과 같다 :</li>
</ul>
<p><img src="../../../../gardens/network/originals/datacommunication.spring.2021.cse.cnu.ac.kr/images/07_11f3b00bf54a426f96184c589fc5668d/image6.png" alt="%E1%84%8B%E1%85%B5%E1%84%85%E1%85%A9%E1%86%AB07%20-%20MAC%2011f3b00bf54a426f96184c589fc5668d/image6.png"/></p>
<ol>
<li>먼저 시도횟수(K) = 0으로 시작한다</li>
<li>그다음 <strong>Persistence</strong>중 하나를 골라 수행하여 적정한 시간에 프레임을 전송한다. 그리고 전송이 끝나거나 충돌이 감지되는지 수시로 확인한다
<ul>
<li>전송이 끝나거나 충돌이 감지되지 않으면 다시 확인하고, 둘 중 하나에 해당하면 다음 단계로 넘어간다</li>
</ul>
</li>
<li>전송 완료된 것인지 아니면 충돌에 의해 중단된 것인지 판단한다
<ul>
<li>만일 완료된 것이면 전송 성공인 것이고</li>
<li>중단된 것이면 다음단계로 넘어간다</li>
</ul>
</li>
<li>Jamming Signal을 보낸다는데 이게 뭔지는 모르겠고 시도횟수(K)를 하나 올려 시도횟수 최대값(15)보다 작은지 판단한다
<ul>
<li>만일 최대값보다 크다면 전송 취소(Abort)하고</li>
<li>그렇지 않다면 <strong>Binary Back-off</strong>를 실시해 난수 <strong>R</strong>를 하나 고르고 <strong>Tb = R * Tp</strong>를 통해 대기시간을 산정하고 대기한다</li>
<li>대기시간이 만료되면 다시 2번으로 돌아간다</li>
</ul>
</li>
</ol>
<h2 id="csma-with-collision-avoidancecsma--ca">CSMA with Collision Avoidance(CSMA / CA)<a aria-hidden="true" tabindex="-1" href="#csma-with-collision-avoidancecsma--ca" class="internal"> §</a></h2>
<ul>
<li>그냥 CSMA의 경우에는 무선의 환경에서도 사용 가능하나 CSMA / CD의 경우에는 무선환경에서는 사용하지 못한다
<ul>
<li>Collision Detection과정에서 사용되는 진폭에 따른 충돌 감지는 무선환경에서는 진폭변화가 크지 않기 때문에 충돌에 의한 것인지 아닌지를 판단하기가 힘들기 때문</li>
</ul>
</li>
</ul>
<h3 id="inter-frame-spaceifs">Inter Frame Space(IFS)<a aria-hidden="true" tabindex="-1" href="#inter-frame-spaceifs" class="internal"> §</a></h3>
<p><img src="../../../../gardens/network/originals/datacommunication.spring.2021.cse.cnu.ac.kr/images/07_11f3b00bf54a426f96184c589fc5668d/image7.png" alt="%E1%84%8B%E1%85%B5%E1%84%85%E1%85%A9%E1%86%AB07%20-%20MAC%2011f3b00bf54a426f96184c589fc5668d/image7.png"/></p>
<ul>
<li>일단 통신의 과정은 그냥 보낸다고 끝이 아니라 보내고 나서 ack까지 받는 것까지 해야 하나의 프레임을 전송 완료한것이다라고 말할 수 있다</li>
<li>이때 전송이 완료되고 회선이 비워지더라도 바로 보내지 않고 ACK보내는 시간을 배려해주기 위해 무조건적으로 대기해야되는 시간을 <strong>IFS</strong>라고 하며 IFS의 종류에는 여러가지가 있다
<ul>
<li>먼저 수신자 입장에서 프레임을 수신하고 ACK를 송신할때 바로 보낼 수 있는게 아니라 수신 모드에서 ACK 송신모드로 전환하는 과정이 필요한데 이 과정에 소요되는 시간을 <strong>Short Inter Frame Space(SIFS)</strong> 라고 하는 것 이다</li>
<li>즉, <strong>SIFS</strong>는 수신 이후 ACK전송까지 걸리는 시간이므로 최소한적으로 대기해야되는 시간인 것이다</li>
<li>SIFS말고 다른 IFS들은 차차 등장하게 된다</li>
</ul>
</li>
<li>그래서 엿듣고있는 놈들은 중간의 <strong>SIFS</strong>시간까지 전부 포함해서 회선이 busy인 것으로 판단하게 되는 것 이다</li>
<li>이제 <strong>CSMA / CA</strong>에서는 회선이 idle해지면 바로 보내는게 아니라 일단 SIFS만큼의 시간을 기다리고, binary back-off만큼의 시간을 추가적으로 기다린 후 회선이 여전히 비었으면 보내게 된다
<ul>
<li>CSMA / CD에서는 저 binary backoff를 충돌이 났을 때에 주로 사용하는데 CSMA / CA에서는 SIFS이후 기다리는 시간에 사용한다는 것이 차이점이다</li>
</ul>
</li>
</ul>
<p><img src="../../../../gardens/network/originals/datacommunication.spring.2021.cse.cnu.ac.kr/images/07_11f3b00bf54a426f96184c589fc5668d/image8.png" alt="%E1%84%8B%E1%85%B5%E1%84%85%E1%85%A9%E1%86%AB07%20-%20MAC%2011f3b00bf54a426f96184c589fc5668d/image8.png"/></p>
<ul>
<li>여기서 이제 <strong>Contention window</strong>라는 말이 나오게 되는데 이게 뭐냐면 binary backoff를 통해 난수를 하나 뽑을 때 <strong>2^시도횟수(K) - 1</strong>개의 상자가 있고 여기에서 그것중에 하나를 고르는 식으로 난수의 생성이 이루어지는데 이때의 상자를 저거라고 부르는 것 이다.</li>
</ul>
<p><img src="../../../../gardens/network/originals/datacommunication.spring.2021.cse.cnu.ac.kr/images/07_11f3b00bf54a426f96184c589fc5668d/image9.png" alt="%E1%84%8B%E1%85%B5%E1%84%85%E1%85%A9%E1%86%AB07%20-%20MAC%2011f3b00bf54a426f96184c589fc5668d/image9.png"/></p>
<ul>
<li>위 그림이 이 CSMA / CA에 대한 플로우 차트이다</li>
</ul>
<ol>
<li>마찬가지로 시도횟수(K)로 시작한다</li>
<li>그리고 Channel이 idle한지 계속 확인한다
<ul>
<li>idle해지면 다음단계로 넘어간다</li>
</ul>
</li>
<li>그리고 우선 <strong>IFS(SIFS)</strong> 를 대기하고 아직도 idle한지 확인한다
<ul>
<li>여전히 idle하면 다음단계로 넘어가지만 busy하다면 다시 2번으로 돌아간다</li>
</ul>
</li>
<li><strong>Binary Back-off</strong>를 시도하고 나온 난수 <strong>R</strong>만큼의 슬롯을 넘긴다. 그리고 프레임을 전송한뒤 타임아웃될때까지 ACK를 기다린다
<ul>
<li>만일 ACK가 수신되면 성공이지만 그게 아니라면 다음단계로 넘어간다</li>
</ul>
</li>
<li>시도횟수(K)를 1 증가시키고 이게 최댓값보다 큰지 검사한다
<ul>
<li>최댓값보다 크다면 전송 취소(Abort)하고 아니라면 2번으로 돌아간다</li>
</ul>
</li>
</ol>
<ul>
<li>근데 보면 binary backoff로 구한 난수만큼의 슬롯을 지나치고 그 난수에 해당하는 슬롯이 왔을때 프레임을 전송하는 것으로 보아 p-persistance에 IFS시간을 추가한 것과 유사하다는 것을 알 수 있다</li>
<li>CSMA / CA는 지금의 와이파이 프로토콜의 기반이 되는 기술 이라고 할 수 있다</li>
</ul>
<h2 id="controlled-access">Controlled Access<a aria-hidden="true" tabindex="-1" href="#controlled-access" class="internal"> §</a></h2>
<ul>
<li><strong>Controlled Access</strong>는 회선에 접근하는 station들을 잘 컨트롤해서 충돌이 아예 일어나지 않게 하는기법이다</li>
<li>얘는 이제 <strong>Reservation</strong>, <strong>Polling</strong>, <strong>Token Passing</strong>의 방법이 존재한다</li>
</ul>
<h2 id="reservation">Reservation<a aria-hidden="true" tabindex="-1" href="#reservation" class="internal"> §</a></h2>
<ul>
<li>얘는 이제 “어떤” 기준점을 잡는 놈이 송신할 순서를 미리 정해 이것을 미니 프레임에 담아 전송을 한다</li>
<li>그러면 나머지가 이것을 수신하고 자기 차례가 몇번째인지 확인한 후, 자기 차례가 오면 송신을 하는 구조</li>
<li>하지만 이론적이 내용일 뿐 실제로는 쓰이지 않는댄다</li>
</ul>
<h2 id="polling">Polling<a aria-hidden="true" tabindex="-1" href="#polling" class="internal"> §</a></h2>
<p><img src="../../../../gardens/network/originals/datacommunication.spring.2021.cse.cnu.ac.kr/images/07_11f3b00bf54a426f96184c589fc5668d/image10.png" alt="%E1%84%8B%E1%85%B5%E1%84%85%E1%85%A9%E1%86%AB07%20-%20MAC%2011f3b00bf54a426f96184c589fc5668d/image10.png"/></p>
<ul>
<li>얘도 이제 기준점이 필요한데 이 중앙 시스템을 <strong>Primary</strong>라고 한다</li>
</ul>
<h3 id="station에서-primary로-데이터를-보내고자-할-때">Station에서 Primary로 데이터를 보내고자 할 때<a aria-hidden="true" tabindex="-1" href="#station에서-primary로-데이터를-보내고자-할-때" class="internal"> §</a></h3>
<ol>
<li>먼저 primary가 <strong>Poll</strong>을 보내 보낼 데이터가 있는지 묻게 된다
<ul>
<li><strong>Poll</strong>은 보낼 데이터가 있는지 station에게 묻는 것을 말함</li>
<li>primary의 중앙 통제 하에 모든 통신이 이루어지므로 station이 먼저 데이터를 보낼 수는 없고 primary의 poll이 들어오면 그때 데이터를 보낼 수 있는 권한을 얻게 되는 것이다</li>
</ul>
</li>
<li>그리고 만약에 station이 보낼 데이터가 없으면 <strong>NAK</strong>을 보낸다</li>
<li>하지만 station이 보낼 데이터가 있으면 <strong>Data</strong>를 보내고 primary는 수신했다는 뜻으로 <strong>ACK</strong>를 송신한다</li>
</ol>
<h3 id="primary에서-station로-데이터를-보내고자-할-때">Primary에서 Station로 데이터를 보내고자 할 때<a aria-hidden="true" tabindex="-1" href="#primary에서-station로-데이터를-보내고자-할-때" class="internal"> §</a></h3>
<ol>
<li>이것도 먼저 primary가 먼저 보내게 되는데 이때는 <strong>SEL</strong>을 보내게 된다
<ul>
<li><strong>SEL</strong>은 보낼게 있는데 받을 준비가 되었느냐는 뜻이다 - QRV같은놈이제</li>
</ul>
</li>
<li>이때 station이 준비가 되었으면 <strong>ACK</strong>를 보내고</li>
<li>그럼 primary는 <strong>Data</strong>를 보내게 된다</li>
<li>station이 제대로 수신했으면 <strong>ACK</strong>를 보내는 것으로 통신이 마무리되게 된다</li>
</ol>
<h3 id="station---station">Station -> Station<a aria-hidden="true" tabindex="-1" href="#station---station" class="internal"> §</a></h3>
<ul>
<li>일단 Polling방식에서는 아까말한대로 통신이 primary의 통제 하에 이루어 지므로 station이 먼저 데이터를 보낼 수는 없다</li>
</ul>
<ol>
<li>따라서 송신 station은 primary의 <strong>Poll</strong>을 기다렸다가 오면 <strong>Data</strong>를 먼저 primary로 보낸다</li>
<li>그리고 primary가 수신 station으로 <strong>SEL</strong>을 보내 <strong>Data</strong>를 전송하는 방식으로 station간의 통신이 이루어지게 된다</li>
</ol>
<ul>
<li>따라서 station이 station으로 바로 데이터를 보낼 수는 없고 primary를 거쳐야만 station → station의 통신이 가능하다</li>
</ul>
<h2 id="token-passing">Token Passing<a aria-hidden="true" tabindex="-1" href="#token-passing" class="internal"> §</a></h2>
<ul>
<li>얘는 이제 약간 수건돌리기같은거다</li>
<li>회선을 사용할 권한을 갖고있는 놈한테 <strong>Token</strong>이 주어지는데</li>
<li>이것을 갖고있는 놈이 데이터를 다 보내고, 데이터를 다 보냈으면 다른놈한테 이 <strong>Token</strong> 을 전달하는 방식으로 통신이 이루어짐</li>
<li>하지만 얘도 별로 사용하지 않는댄다</li>
</ul>
<h2 id="channelization-protocol">Channelization Protocol<a aria-hidden="true" tabindex="-1" href="#channelization-protocol" class="internal"> §</a></h2>
<ul>
<li>이제까지는 한 station이 대역폭 전체를 사용해 통신할 떄 순서를 나눠서 충돌이 일어나지 않게 하는 방법이었다면, 얘는 대역폭으로 사용시간에 따라, 주파수에 따라, 그리고 코드라는 것에 따라 나눠서 통신하여 충돌을 줄이는 개념이다</li>
<li>넓은 대역폭을 잘라 통신하는 방법이라 하니 앞에서 배운 무언가가 막 생각나쥬? - <strong>Multiplexing</strong>이랑 <strong>Spreading</strong>을 활용하는 방법이다</li>
<li>이용하는 사람이 많아지면 그만큼 더 조밀하게 자르고(더 느려짐), 적어지면 더 널찍하게 대역폭을 잘라 사용(더 빨라짐) 하게 되는데 그래도 한번에 여러 station이 동시에 회선을 사용할 수 있다는 장점이 있다</li>
<li>요즘은 이 방법들을 한가지만 사용하는게 아니고 다 모아서 장점들만 살려 통신하는 기법을 사용한다고 한다네</li>
<li><strong>FDMA</strong>와, <strong>TDMA</strong>, <strong>CDMA</strong>등의 방법이 있다 - 하지만 학부때는 FDMA와 TDMA는 자세하게는 설명하지 않는댄다</li>
</ul>
<h2 id="frequency-division-multiple-accessfdma">Frequency-Division Multiple Access(FDMA)<a aria-hidden="true" tabindex="-1" href="#frequency-division-multiple-accessfdma" class="internal"> §</a></h2>
<ul>
<li>회선의 대역폭 주파수를 잘라 통신하는 기법</li>
<li><strong>FDM</strong>과 대응되는 개념인거지</li>
</ul>
<h2 id="time-division-multiple-accesstdma">Time-Division Multiple Access(TDMA)<a aria-hidden="true" tabindex="-1" href="#time-division-multiple-accesstdma" class="internal"> §</a></h2>
<ul>
<li>회선을 사용하는 시간을 나눠 통신하는 기법</li>
<li><strong>TDM</strong>과 대응되는 개념인거지</li>
</ul>
<h2 id="code-division-multiple-accesscdma">Code-Division Multiple Access(CDMA)<a aria-hidden="true" tabindex="-1" href="#code-division-multiple-accesscdma" class="internal"> §</a></h2>
<ul>
<li>얘는 이제 <strong>DSSS</strong>를 활용하는 방법이다 - 뭔지 기억 안나면 <strong>Spread Spectrum</strong>부분 다시 읽고 와라</li>
<li>만약에 spreading code를 절묘하게 짜게 된다면 데이터의 충돌이 일어나도 원 데이터를 꺼낼 수 있다 - 한 대역폭에 시간차를 두지 않고 통신해 당연히 충돌이 나지만 그럼에도 불구하고 잘 짜여진 <strong>Spreading Code</strong>를 이용해 충돌 데이터에서 원 데이터를 꺼내는 방식으로 충돌을 무시하는 방법이 <strong>CDMA</strong>의 개념이다</li>
</ul>
<h3 id="작동방식">작동방식<a aria-hidden="true" tabindex="-1" href="#작동방식" class="internal"> §</a></h3>
<p><img src="../../../../gardens/network/originals/datacommunication.spring.2021.cse.cnu.ac.kr/images/07_11f3b00bf54a426f96184c589fc5668d/image11.png" alt="%E1%84%8B%E1%85%B5%E1%84%85%E1%85%A9%E1%86%AB07%20-%20MAC%2011f3b00bf54a426f96184c589fc5668d/image11.png"/></p>
<ul>
<li>봐봐라</li>
<li>일단 맨 위에 있는게 진폭 설정 방식이다 - 데이터0은 <strong>진폭(-1)</strong> 으로, 1은 <strong>진폭(+1)</strong> 으로, 데이터가 없을때는 <strong>진폭(0)</strong> 으로</li>
<li>그리고 저 박스들이 다 station이다</li>
<li>저 박스들은 각자의 spreading code를 가지고 있다 - 저 분홍색 []가 spreading code이다</li>
<li>그리고 박스 안으로 진폭이 들어오면 저 spreading code와 곱해지고 이 곱해진 결과가 박스와 channel사이에 있는 검은 []다</li>
<li>얘네가 이제 충돌이 일어난 결과가 노란색 박스가 되는데</li>
<li>근데 신기하게도 여기에 각자의 spreading code를 곱하면 원래의 데이터를 뽑아낼 수 있게 된다
<ul>
<li>만약에 station 2 가 보낸 데이터가 뭔지 알고 싶으면 station 2 의 spreading code인 C2를 곱해서 더하면 -4가 나오게 된다</li>
<li>근데 -4는 음수이므로 데이터0으로 판단하게 되는데 이것은 정확하게 station 2 가 보낸 데이터와 동일하다</li>
<li>나머지 station이 보낸 데이터를 확인하고 싶어 각자의 spreading code를 곱해봐도 원래의 데이터가 나오게 된다</li>
</ul>
</li>
</ul>
<h3 id="spreading-code-만드는법">Spreading Code 만드는법<a aria-hidden="true" tabindex="-1" href="#spreading-code-만드는법" class="internal"> §</a></h3>
<p><img src="../../../../gardens/network/originals/datacommunication.spring.2021.cse.cnu.ac.kr/images/07_11f3b00bf54a426f96184c589fc5668d/image12.png" alt="%E1%84%8B%E1%85%B5%E1%84%85%E1%85%A9%E1%86%AB07%20-%20MAC%2011f3b00bf54a426f96184c589fc5668d/image12.png"/></p>
<ul>
<li><strong>Walsh table</strong>을 사용하면 Spreading Code를 손쉽게 만들어 낼 수 있다</li>
<li>위쪽이 귀납법으로 만들어진 table의 생성규칙, 아랫쪽이 생성 예시이다</li>
<li>“Wn바”는 Wn의 모든 부호를 반대로 바꿔준다는 뜻이다</li>
<li>저 생성된 행렬의 행(열)단위로 읽으면 그게 spreading code가 되는 것</li>
</ul></article></div><div class="right sidebar"><div class="graph "><h3>Graph View</h3><div class="graph-outer"><div id="graph-container" data-cfg="{&quot;drag&quot;:true,&quot;zoom&quot;:true,&quot;depth&quot;:1,&quot;scale&quot;:1.1,&quot;repelForce&quot;:0.5,&quot;centerForce&quot;:0.3,&quot;linkDistance&quot;:30,&quot;fontSize&quot;:0.6,&quot;opacityScale&quot;:1,&quot;showTags&quot;:true,&quot;removeTags&quot;:[]}"></div><svg version="1.1" id="global-graph-icon" xmlns="http://www.w3.org/2000/svg" xmlnsXlink="http://www.w3.org/1999/xlink" x="0px" y="0px" viewBox="0 0 55 55" fill="currentColor" xmlSpace="preserve"><path d="M49,0c-3.309,0-6,2.691-6,6c0,1.035,0.263,2.009,0.726,2.86l-9.829,9.829C32.542,17.634,30.846,17,29,17
	s-3.542,0.634-4.898,1.688l-7.669-7.669C16.785,10.424,17,9.74,17,9c0-2.206-1.794-4-4-4S9,6.794,9,9s1.794,4,4,4
	c0.74,0,1.424-0.215,2.019-0.567l7.669,7.669C21.634,21.458,21,23.154,21,25s0.634,3.542,1.688,4.897L10.024,42.562
	C8.958,41.595,7.549,41,6,41c-3.309,0-6,2.691-6,6s2.691,6,6,6s6-2.691,6-6c0-1.035-0.263-2.009-0.726-2.86l12.829-12.829
	c1.106,0.86,2.44,1.436,3.898,1.619v10.16c-2.833,0.478-5,2.942-5,5.91c0,3.309,2.691,6,6,6s6-2.691,6-6c0-2.967-2.167-5.431-5-5.91
	v-10.16c1.458-0.183,2.792-0.759,3.898-1.619l7.669,7.669C41.215,39.576,41,40.26,41,41c0,2.206,1.794,4,4,4s4-1.794,4-4
	s-1.794-4-4-4c-0.74,0-1.424,0.215-2.019,0.567l-7.669-7.669C36.366,28.542,37,26.846,37,25s-0.634-3.542-1.688-4.897l9.665-9.665
	C46.042,11.405,47.451,12,49,12c3.309,0,6-2.691,6-6S52.309,0,49,0z M11,9c0-1.103,0.897-2,2-2s2,0.897,2,2s-0.897,2-2,2
	S11,10.103,11,9z M6,51c-2.206,0-4-1.794-4-4s1.794-4,4-4s4,1.794,4,4S8.206,51,6,51z M33,49c0,2.206-1.794,4-4,4s-4-1.794-4-4
	s1.794-4,4-4S33,46.794,33,49z M29,31c-3.309,0-6-2.691-6-6s2.691-6,6-6s6,2.691,6,6S32.309,31,29,31z M47,41c0,1.103-0.897,2-2,2
	s-2-0.897-2-2s0.897-2,2-2S47,39.897,47,41z M49,10c-2.206,0-4-1.794-4-4s1.794-4,4-4s4,1.794,4,4S51.206,10,49,10z"></path></svg></div><div id="global-graph-outer"><div id="global-graph-container" data-cfg="{&quot;drag&quot;:true,&quot;zoom&quot;:true,&quot;depth&quot;:-1,&quot;scale&quot;:0.9,&quot;repelForce&quot;:0.5,&quot;centerForce&quot;:0.3,&quot;linkDistance&quot;:30,&quot;fontSize&quot;:0.6,&quot;opacityScale&quot;:1,&quot;showTags&quot;:true,&quot;removeTags&quot;:[]}"></div></div></div><div class="toc desktop-only"><button type="button" id="toc"><h3>Table of Contents</h3><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="fold"><polyline points="6 9 12 15 18 9"></polyline></svg></button><div id="toc-content"><ul class="overflow"><li class="depth-0"><a href="#multiple-access-controlmac" data-for="multiple-access-controlmac">Multiple Access Control(MAC)</a></li><li class="depth-0"><a href="#random-access" data-for="random-access">Random Access</a></li><li class="depth-0"><a href="#aloha-알고리즘" data-for="aloha-알고리즘">ALOHA 알고리즘</a></li><li class="depth-0"><a href="#slotted-aloha-알고리즘" data-for="slotted-aloha-알고리즘">Slotted ALOHA 알고리즘</a></li><li class="depth-0"><a href="#carrier-sense-multiple-accesscsma" data-for="carrier-sense-multiple-accesscsma">Carrier Sense Multiple Access(CSMA)</a></li><li class="depth-1"><a href="#기다림이-끝났을-때-어떻게-행공할것인가" data-for="기다림이-끝났을-때-어떻게-행공할것인가">기다림이 끝났을 때 어떻게 행공할것인가</a></li><li class="depth-0"><a href="#csma-with-collision-detectioncsmacd" data-for="csma-with-collision-detectioncsmacd">CSMA with Collision Detection(CSMA/CD)</a></li><li class="depth-1"><a href="#충돌을-감지했을때-좋은점" data-for="충돌을-감지했을때-좋은점">충돌을 감지했을때 좋은점</a></li><li class="depth-0"><a href="#csma-with-collision-avoidancecsma--ca" data-for="csma-with-collision-avoidancecsma--ca">CSMA with Collision Avoidance(CSMA / CA)</a></li><li class="depth-1"><a href="#inter-frame-spaceifs" data-for="inter-frame-spaceifs">Inter Frame Space(IFS)</a></li><li class="depth-0"><a href="#controlled-access" data-for="controlled-access">Controlled Access</a></li><li class="depth-0"><a href="#reservation" data-for="reservation">Reservation</a></li><li class="depth-0"><a href="#polling" data-for="polling">Polling</a></li><li class="depth-1"><a href="#station에서-primary로-데이터를-보내고자-할-때" data-for="station에서-primary로-데이터를-보내고자-할-때">Station에서 Primary로 데이터를 보내고자 할 때</a></li><li class="depth-1"><a href="#primary에서-station로-데이터를-보내고자-할-때" data-for="primary에서-station로-데이터를-보내고자-할-때">Primary에서 Station로 데이터를 보내고자 할 때</a></li><li class="depth-1"><a href="#station---station" data-for="station---station">Station -> Station</a></li><li class="depth-0"><a href="#token-passing" data-for="token-passing">Token Passing</a></li><li class="depth-0"><a href="#channelization-protocol" data-for="channelization-protocol">Channelization Protocol</a></li><li class="depth-0"><a href="#frequency-division-multiple-accessfdma" data-for="frequency-division-multiple-accessfdma">Frequency-Division Multiple Access(FDMA)</a></li><li class="depth-0"><a href="#time-division-multiple-accesstdma" data-for="time-division-multiple-accesstdma">Time-Division Multiple Access(TDMA)</a></li><li class="depth-0"><a href="#code-division-multiple-accesscdma" data-for="code-division-multiple-accesscdma">Code-Division Multiple Access(CDMA)</a></li><li class="depth-1"><a href="#작동방식" data-for="작동방식">작동방식</a></li><li class="depth-1"><a href="#spreading-code-만드는법" data-for="spreading-code-만드는법">Spreading Code 만드는법</a></li></ul></div></div><div class="backlinks "><h3>Backlinks</h3><ul class="overflow"><li><a href="../../../../gardens/network/originals/datacommunication.spring.2021.cse.cnu.ac.kr/(충남대)-데이터-통신-강의록" class="internal">(충남대) 데이터 통신 강의록</a></li></ul></div></div></div><footer class><hr/><p>Created with <a href="https://quartz.jzhao.xyz/">Quartz v4.1.0</a>, © 2024</p><ul><li><a href="https://github.com/haeramkeem">GitHub</a></li><li><a href="www.linkedin.com/in/haeram-kim-277404220">LinkedIn</a></li><li><a href="mailto:haeram.kim1@gmail.com">Email</a></li></ul></footer></div></body><script type="application/javascript">// quartz/components/scripts/quartz/components/scripts/callout.inline.ts
function toggleCallout() {
  const outerBlock = this.parentElement;
  outerBlock.classList.toggle(`is-collapsed`);
  const collapsed = outerBlock.classList.contains(`is-collapsed`);
  const height = collapsed ? this.scrollHeight : outerBlock.scrollHeight;
  outerBlock.style.maxHeight = height + `px`;
  let current = outerBlock;
  let parent = outerBlock.parentElement;
  while (parent) {
    if (!parent.classList.contains(`callout`)) {
      return;
    }
    const collapsed2 = parent.classList.contains(`is-collapsed`);
    const height2 = collapsed2 ? parent.scrollHeight : parent.scrollHeight + current.scrollHeight;
    parent.style.maxHeight = height2 + `px`;
    current = parent;
    parent = parent.parentElement;
  }
}
function setupCallout() {
  const collapsible = document.getElementsByClassName(
    `callout is-collapsible`
  );
  for (const div of collapsible) {
    const title = div.firstElementChild;
    if (title) {
      title.removeEventListener(`click`, toggleCallout);
      title.addEventListener(`click`, toggleCallout);
      const collapsed = div.classList.contains(`is-collapsed`);
      const height = collapsed ? title.scrollHeight : div.scrollHeight;
      div.style.maxHeight = height + `px`;
    }
  }
}
document.addEventListener(`nav`, setupCallout);
window.addEventListener(`resize`, setupCallout);
</script><script type="module">
          import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.esm.min.mjs';
          const darkMode = document.documentElement.getAttribute('saved-theme') === 'dark'
          mermaid.initialize({
            startOnLoad: false,
            securityLevel: 'loose',
            theme: darkMode ? 'dark' : 'default'
          });
          document.addEventListener('nav', async () => {
            await mermaid.run({
              querySelector: '.mermaid'
            })
          });
          </script><script src="https://cdn.jsdelivr.net/npm/katex@0.16.7/dist/contrib/copy-tex.min.js" type="application/javascript"></script><script src="https://www.googletagmanager.com/gtag/js?id=G-N68CCP1QHG" type="application/javascript"></script><script src="../../../../postscript.js" type="module"></script></html>