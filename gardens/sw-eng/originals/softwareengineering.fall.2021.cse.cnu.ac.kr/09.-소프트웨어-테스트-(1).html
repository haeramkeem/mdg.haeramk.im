<!DOCTYPE html>
<html><head><title>09. 소프트웨어 테스트 (1)</title><meta charSet="utf-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:title" content="09. 소프트웨어 테스트 (1)"/><meta property="og:description" content="충남대학교 컴퓨터공학과 김현수 교수님의 &amp;quot;소프트웨어 공학&amp;quot; 강의를 필기한 내용입니다. 다소 잘못된 내용과 구어적 표현 이 포함되어 있을 수 있습니다. Failure, Defect, Error § Failure(실패) : 시스템이 실행되는 도중 시스템이 받아들일 수 없는 행위가 발생한 경우 명세와 실행동작의 차이라고도 할 수 있고 이것을 기준으로 Reliability(신뢰도) 를 계산한다 Defect(결함) : 장애의 발생에 기여하거나 잠재적으로 기여할 수 있는 시스템에서의 결함 Error(오류) : 시스템의 결함으로 이끄는 소프트웨어 개발자의 잘못이나 결정 이렇게 말하면 위 세가지가 뭔차이가 있는지 약간 헷갈리는데 Failure는 결과적인 측면이다 - 시스템이 오작동한 결과를 말하는 것 Defect은 시스템에서의 원인이다 - 시스템이 오작동하게된 시스템에서의 원인을 말하는 것 Error는 개발자측면에서의 원인이다 - 시스템이 오작동하게된 개발자의 잘못을 말하는 것 Testing § 뭐 알다시피 시스템의 실패로 이끄는 결함이나 오류를 찾거나 명세와 구현이 일치함을 검증하는 과정을 말함 그래서 목적은 크게 결함 / 오류 찾기 명세 충족 확인 설계나 구현을 검증하는 것으로 생각할 수 있다 Test Case § 입력값과 해당 입력값에 대한 예상되는 결과 얘네가 일치한다면 해당 Test가 통과한 것이고 아니면 통과하지 못한것(실패) 테케는 보통 이런것들로 이루어진다 이름(ID) 대상 - 뭐 측정한 method나 클래스, 서브시스템 등 조건 - 테스트 대상이 실행되기위한 조건(테스트를 가능하게 하는 조건) 입력 예상 결과 여기서 Test Oracle은 테스트의 성공 / 실패를 판단하는 매커니즘 - 예를들면 예상결과와 실제 결과가 일치하는지 판단하는 것 좋은 테스팅 § Test Effectively(효과적인 테스트) : 결함을 최대한 많이 발견하면 당연히 좋겠지 Test Efficiently(효율적인 테스트) : 최대한 적은 노력과 테스트케이스로 최대한 많은 결함을 찾아내는 것 효과적 / 효율적인 테스트를 하지 못하면 배포 후의 유지보수비용이 늘어 금전적인 손해가 나거나 극단적으로는 사고가 나 인명피해가 발생하기도 하기 때문에 중허다 결함의 종류(사례) § Incorrect Logical Conditions : 반복이나 분기의 조건이 잘못된 경우 뭐 동등 분할 기법이나 경계값 분석 기법을 사용해서 찾아내거나 조건식에 사용되는 변수의 입력을 추적해보랜다 제어구조의 잘못된 부분에서 계산 수행 : 프로그램이 수행하지 않아야 할 작업을 수행하거나 수행해야될것을 수행하지 않은 경우 반복이나 분기에서 작업이 부적절하게 제외되거나 포함되는 경우가 많댄다 이런건 반복 횟수를 특정하는(정확히 0번, 1번, 혹은 n번 돌게 하는) 테스트케이스를 설계함으로 결함을 찾는데 도움이 될 수 있댄다 NULL을 처리하지 않음 : 제곧내 Off-by-one : 1과 관련된것 - 값이 부적절하게 1이 더해지거나 빼지는 경우, 혹은 반복이 한번 더 돌더나 덜 도는 것 Overflow : 자료형의 범위를 고려하지 않고 사용한 경우 부동소수점의 값이 같다고 판단하는 경우 : 부동소수점의 경우 값이 정확히 같을때보다 다를 확률이 더 많다 - 따라서 부동소수점의 경우에는 일치여부가 아니라 대소비교로 조건문을 줘야 한다 테스팅 기법 § Black Box Testing : 얘는 입력값에 따른 예상 결과를 내부 논리구조를 생각하지 않고 선정하는 것을 의미한다 여기에는 Equivalence partitioning과 Boundary Value Analysis가 있다 Equivalence Partitioning § Equivalence Partitioning(동등 분할 기법) 은 동치 클래스 결정을 하고 동치 클래스 각각에 대해 그 안에서 테스트케이스 각각을 선정하는 방법이다 뭔 소린지는 예시를 들어서 설명하면 일단 1부터 48사이의 정수가 정상 입력값이니까 1부터 48 사이의 정수가 정상 클래스가 되는거고 1부터 48 사이의 정수가 아닌 범위는 1보다 작은 정수, 48보다 큰 정수, 실수, 숫자가 아닌 값 정도로 나눌 수 있고 얘네 각각이 비정상 클래스가 되는 것이다 이제 이 클래스들에서 하나씩 테케 입력을 고르고 거기에 따른 예상되는 출력이 나오는지 확인하면 되는 것 위 예제에서 봤듯이 명세에 따라 값의 범위를 나누고 각각의 범위에서 테케를 고르는 방식으로 진행되는데 명세에 따라 값의 범위를 나누는 것을 동치 클래스를 결정한다고 한다 동치 클래스는 우선 클래스는 그냥 집합으로 이해하면 되고 그 클래스에 들어가는 값들은 전부 동등하다 - 즉, 같은 출력을 내고 같은 방식으로 작동하는 값들의 집합을 의미하게 된다 만일 동치 클래스의 값들이 다른방식으로 작동한다면 그건 동치 클래스를 잘못 결정한거임 따라서 동치 클래스에서는 어떤 값을 선택해도 동일하기 때문에 아무 값이나 골라서 테케 입력으로 선정하는거임 Test Driver, Stub § 일단 프로그램의 구성요소중 하나(메소드 등)를 다른것과의 의존성을 고려하지 않고 테스트하는 것을 Unit Test라고 하는데 Unit test는 main함수를 실행시킬 수 없기 때문에 main함수를 대신해서 해당 부분을 실행시켜주는 놈을 Test Driver라고 하고 만일 그 부분이 다른 함수를 필요로 한다면 그 함수를 대신해서 mock값을 대신 제공해주는 것을 Test Stub이라고 한다 그니까 위 그림에서는 e를 테스트하려고 할때 f를 필요로 하지만 f는 동작시킬 수 없기 때문에 f의 반환값또한 테스트 이전에 제공해주는 기능을 하는 라이브러리를 말한다 JUnit의 when()메소드로 특정 함수의 반환값을 지정해줄 수 있었자네 - 이런게 Test Stub 이 되는거임 Boundary Value Analysis § Boundary Value Analysis(경계값 분석, BVA) 는 결함이 보통 경계 부근에서 발견되기 때문에 경계 부근을 집중적으로 테스트하는 것을 말한다 따라서 위 그림처럼 1, 100이 경계니까 그 부근인 0, 101을 비유효 경계 값(경계와 근접한 비정상 입력값)으로 하고 1, 100 이외에도 2, 99정도까지 유효 경계 값(경계와 근접한 정상 입력값)으로 선정하여 테스트하게 된다 ."/><meta property="og:image" content="https://mdg.haeramk.im/static/og-image.png"/><meta property="og:width" content="1200"/><meta property="og:height" content="675"/><link rel="icon" href="../../../../static/icon.png"/><meta name="description" content="충남대학교 컴퓨터공학과 김현수 교수님의 &amp;quot;소프트웨어 공학&amp;quot; 강의를 필기한 내용입니다. 다소 잘못된 내용과 구어적 표현 이 포함되어 있을 수 있습니다. Failure, Defect, Error § Failure(실패) : 시스템이 실행되는 도중 시스템이 받아들일 수 없는 행위가 발생한 경우 명세와 실행동작의 차이라고도 할 수 있고 이것을 기준으로 Reliability(신뢰도) 를 계산한다 Defect(결함) : 장애의 발생에 기여하거나 잠재적으로 기여할 수 있는 시스템에서의 결함 Error(오류) : 시스템의 결함으로 이끄는 소프트웨어 개발자의 잘못이나 결정 이렇게 말하면 위 세가지가 뭔차이가 있는지 약간 헷갈리는데 Failure는 결과적인 측면이다 - 시스템이 오작동한 결과를 말하는 것 Defect은 시스템에서의 원인이다 - 시스템이 오작동하게된 시스템에서의 원인을 말하는 것 Error는 개발자측면에서의 원인이다 - 시스템이 오작동하게된 개발자의 잘못을 말하는 것 Testing § 뭐 알다시피 시스템의 실패로 이끄는 결함이나 오류를 찾거나 명세와 구현이 일치함을 검증하는 과정을 말함 그래서 목적은 크게 결함 / 오류 찾기 명세 충족 확인 설계나 구현을 검증하는 것으로 생각할 수 있다 Test Case § 입력값과 해당 입력값에 대한 예상되는 결과 얘네가 일치한다면 해당 Test가 통과한 것이고 아니면 통과하지 못한것(실패) 테케는 보통 이런것들로 이루어진다 이름(ID) 대상 - 뭐 측정한 method나 클래스, 서브시스템 등 조건 - 테스트 대상이 실행되기위한 조건(테스트를 가능하게 하는 조건) 입력 예상 결과 여기서 Test Oracle은 테스트의 성공 / 실패를 판단하는 매커니즘 - 예를들면 예상결과와 실제 결과가 일치하는지 판단하는 것 좋은 테스팅 § Test Effectively(효과적인 테스트) : 결함을 최대한 많이 발견하면 당연히 좋겠지 Test Efficiently(효율적인 테스트) : 최대한 적은 노력과 테스트케이스로 최대한 많은 결함을 찾아내는 것 효과적 / 효율적인 테스트를 하지 못하면 배포 후의 유지보수비용이 늘어 금전적인 손해가 나거나 극단적으로는 사고가 나 인명피해가 발생하기도 하기 때문에 중허다 결함의 종류(사례) § Incorrect Logical Conditions : 반복이나 분기의 조건이 잘못된 경우 뭐 동등 분할 기법이나 경계값 분석 기법을 사용해서 찾아내거나 조건식에 사용되는 변수의 입력을 추적해보랜다 제어구조의 잘못된 부분에서 계산 수행 : 프로그램이 수행하지 않아야 할 작업을 수행하거나 수행해야될것을 수행하지 않은 경우 반복이나 분기에서 작업이 부적절하게 제외되거나 포함되는 경우가 많댄다 이런건 반복 횟수를 특정하는(정확히 0번, 1번, 혹은 n번 돌게 하는) 테스트케이스를 설계함으로 결함을 찾는데 도움이 될 수 있댄다 NULL을 처리하지 않음 : 제곧내 Off-by-one : 1과 관련된것 - 값이 부적절하게 1이 더해지거나 빼지는 경우, 혹은 반복이 한번 더 돌더나 덜 도는 것 Overflow : 자료형의 범위를 고려하지 않고 사용한 경우 부동소수점의 값이 같다고 판단하는 경우 : 부동소수점의 경우 값이 정확히 같을때보다 다를 확률이 더 많다 - 따라서 부동소수점의 경우에는 일치여부가 아니라 대소비교로 조건문을 줘야 한다 테스팅 기법 § Black Box Testing : 얘는 입력값에 따른 예상 결과를 내부 논리구조를 생각하지 않고 선정하는 것을 의미한다 여기에는 Equivalence partitioning과 Boundary Value Analysis가 있다 Equivalence Partitioning § Equivalence Partitioning(동등 분할 기법) 은 동치 클래스 결정을 하고 동치 클래스 각각에 대해 그 안에서 테스트케이스 각각을 선정하는 방법이다 뭔 소린지는 예시를 들어서 설명하면 일단 1부터 48사이의 정수가 정상 입력값이니까 1부터 48 사이의 정수가 정상 클래스가 되는거고 1부터 48 사이의 정수가 아닌 범위는 1보다 작은 정수, 48보다 큰 정수, 실수, 숫자가 아닌 값 정도로 나눌 수 있고 얘네 각각이 비정상 클래스가 되는 것이다 이제 이 클래스들에서 하나씩 테케 입력을 고르고 거기에 따른 예상되는 출력이 나오는지 확인하면 되는 것 위 예제에서 봤듯이 명세에 따라 값의 범위를 나누고 각각의 범위에서 테케를 고르는 방식으로 진행되는데 명세에 따라 값의 범위를 나누는 것을 동치 클래스를 결정한다고 한다 동치 클래스는 우선 클래스는 그냥 집합으로 이해하면 되고 그 클래스에 들어가는 값들은 전부 동등하다 - 즉, 같은 출력을 내고 같은 방식으로 작동하는 값들의 집합을 의미하게 된다 만일 동치 클래스의 값들이 다른방식으로 작동한다면 그건 동치 클래스를 잘못 결정한거임 따라서 동치 클래스에서는 어떤 값을 선택해도 동일하기 때문에 아무 값이나 골라서 테케 입력으로 선정하는거임 Test Driver, Stub § 일단 프로그램의 구성요소중 하나(메소드 등)를 다른것과의 의존성을 고려하지 않고 테스트하는 것을 Unit Test라고 하는데 Unit test는 main함수를 실행시킬 수 없기 때문에 main함수를 대신해서 해당 부분을 실행시켜주는 놈을 Test Driver라고 하고 만일 그 부분이 다른 함수를 필요로 한다면 그 함수를 대신해서 mock값을 대신 제공해주는 것을 Test Stub이라고 한다 그니까 위 그림에서는 e를 테스트하려고 할때 f를 필요로 하지만 f는 동작시킬 수 없기 때문에 f의 반환값또한 테스트 이전에 제공해주는 기능을 하는 라이브러리를 말한다 JUnit의 when()메소드로 특정 함수의 반환값을 지정해줄 수 있었자네 - 이런게 Test Stub 이 되는거임 Boundary Value Analysis § Boundary Value Analysis(경계값 분석, BVA) 는 결함이 보통 경계 부근에서 발견되기 때문에 경계 부근을 집중적으로 테스트하는 것을 말한다 따라서 위 그림처럼 1, 100이 경계니까 그 부근인 0, 101을 비유효 경계 값(경계와 근접한 비정상 입력값)으로 하고 1, 100 이외에도 2, 99정도까지 유효 경계 값(경계와 근접한 정상 입력값)으로 선정하여 테스트하게 된다 ."/><meta name="generator" content="Quartz"/><link rel="preconnect" href="https://fonts.googleapis.com"/><link rel="preconnect" href="https://fonts.gstatic.com"/><link href="../../../../index.css" rel="stylesheet" type="text/css" spa-preserve/><link href="https://cdn.jsdelivr.net/npm/katex@0.16.0/dist/katex.min.css" rel="stylesheet" type="text/css" spa-preserve/><link href="https://fonts.googleapis.com/css2?family=IBM Plex Mono&amp;family=Gowun Batang:wght@400;700&amp;family=Gowun Dodum:ital,wght@0,400;0,600;1,400;1,600&amp;display=swap" rel="stylesheet" type="text/css" spa-preserve/><script src="../../../../prescript.js" type="application/javascript" spa-preserve></script><script type="application/javascript" spa-preserve>const fetchData = fetch(`../../../../static/contentIndex.json`).then(data => data.json())</script></head><body data-slug="gardens/sw-eng/originals/softwareengineering.fall.2021.cse.cnu.ac.kr/09.-소프트웨어-테스트-(1)"><div id="quartz-root" class="page"><div id="quartz-body"><div class="left sidebar"><h1 class="page-title "><a href="../../../..">Madison Digital Garden</a></h1><div class="spacer mobile-only"></div><div class="search "><div id="search-icon"><p>Search</p><div></div><svg tabIndex="0" aria-labelledby="title desc" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 19.9 19.7"><title id="title">Search</title><desc id="desc">Search</desc><g class="search-path" fill="none"><path stroke-linecap="square" d="M18.5 18.3l-5.4-5.4"></path><circle cx="8" cy="8" r="7"></circle></g></svg></div><div id="search-container"><div id="search-space"><input autocomplete="off" id="search-bar" name="search" type="text" aria-label="Search for something" placeholder="Search for something"/><div id="results-container"></div></div></div></div><div class="darkmode "><input class="toggle" id="darkmode-toggle" type="checkbox" tabIndex="-1"/><label id="toggle-label-light" for="darkmode-toggle" tabIndex="-1"><svg xmlns="http://www.w3.org/2000/svg" xmlnsXlink="http://www.w3.org/1999/xlink" version="1.1" id="dayIcon" x="0px" y="0px" viewBox="0 0 35 35" style="enable-background:new 0 0 35 35;" xmlSpace="preserve"><title>Light mode</title><path d="M6,17.5C6,16.672,5.328,16,4.5,16h-3C0.672,16,0,16.672,0,17.5    S0.672,19,1.5,19h3C5.328,19,6,18.328,6,17.5z M7.5,26c-0.414,0-0.789,0.168-1.061,0.439l-2,2C4.168,28.711,4,29.086,4,29.5    C4,30.328,4.671,31,5.5,31c0.414,0,0.789-0.168,1.06-0.44l2-2C8.832,28.289,9,27.914,9,27.5C9,26.672,8.329,26,7.5,26z M17.5,6    C18.329,6,19,5.328,19,4.5v-3C19,0.672,18.329,0,17.5,0S16,0.672,16,1.5v3C16,5.328,16.671,6,17.5,6z M27.5,9    c0.414,0,0.789-0.168,1.06-0.439l2-2C30.832,6.289,31,5.914,31,5.5C31,4.672,30.329,4,29.5,4c-0.414,0-0.789,0.168-1.061,0.44    l-2,2C26.168,6.711,26,7.086,26,7.5C26,8.328,26.671,9,27.5,9z M6.439,8.561C6.711,8.832,7.086,9,7.5,9C8.328,9,9,8.328,9,7.5    c0-0.414-0.168-0.789-0.439-1.061l-2-2C6.289,4.168,5.914,4,5.5,4C4.672,4,4,4.672,4,5.5c0,0.414,0.168,0.789,0.439,1.06    L6.439,8.561z M33.5,16h-3c-0.828,0-1.5,0.672-1.5,1.5s0.672,1.5,1.5,1.5h3c0.828,0,1.5-0.672,1.5-1.5S34.328,16,33.5,16z     M28.561,26.439C28.289,26.168,27.914,26,27.5,26c-0.828,0-1.5,0.672-1.5,1.5c0,0.414,0.168,0.789,0.439,1.06l2,2    C28.711,30.832,29.086,31,29.5,31c0.828,0,1.5-0.672,1.5-1.5c0-0.414-0.168-0.789-0.439-1.061L28.561,26.439z M17.5,29    c-0.829,0-1.5,0.672-1.5,1.5v3c0,0.828,0.671,1.5,1.5,1.5s1.5-0.672,1.5-1.5v-3C19,29.672,18.329,29,17.5,29z M17.5,7    C11.71,7,7,11.71,7,17.5S11.71,28,17.5,28S28,23.29,28,17.5S23.29,7,17.5,7z M17.5,25c-4.136,0-7.5-3.364-7.5-7.5    c0-4.136,3.364-7.5,7.5-7.5c4.136,0,7.5,3.364,7.5,7.5C25,21.636,21.636,25,17.5,25z"></path></svg></label><label id="toggle-label-dark" for="darkmode-toggle" tabIndex="-1"><svg xmlns="http://www.w3.org/2000/svg" xmlnsXlink="http://www.w3.org/1999/xlink" version="1.1" id="nightIcon" x="0px" y="0px" viewBox="0 0 100 100" style="enable-background='new 0 0 100 100'" xmlSpace="preserve"><title>Dark mode</title><path d="M96.76,66.458c-0.853-0.852-2.15-1.064-3.23-0.534c-6.063,2.991-12.858,4.571-19.655,4.571  C62.022,70.495,50.88,65.88,42.5,57.5C29.043,44.043,25.658,23.536,34.076,6.47c0.532-1.08,0.318-2.379-0.534-3.23  c-0.851-0.852-2.15-1.064-3.23-0.534c-4.918,2.427-9.375,5.619-13.246,9.491c-9.447,9.447-14.65,22.008-14.65,35.369  c0,13.36,5.203,25.921,14.65,35.368s22.008,14.65,35.368,14.65c13.361,0,25.921-5.203,35.369-14.65  c3.872-3.871,7.064-8.328,9.491-13.246C97.826,68.608,97.611,67.309,96.76,66.458z"></path></svg></label></div></div><div class="center"><div class="page-header"><div class="popover-hint"><h1 class="article-title ">09. 소프트웨어 테스트 (1)</h1><p class="content-meta ">Oct 28, 2024, 10 min read</p></div></div><article class="popover-hint"><blockquote class="callout" data-callout="info">
<div class="callout-title">
                  <div class="callout-icon"><svg xmlns="http://www.w3.org/2000/svg" width="100%" height="100%" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="10"></circle><line x1="12" y1="16" x2="12" y2="12"></line><line x1="12" y1="8" x2="12.01" y2="8"></line></svg></div>
                  <div class="callout-title-inner"><p>충남대학교 컴퓨터공학과 김현수 교수님의 &quot;소프트웨어 공학&quot; 강의를 필기한 내용입니다. </p></div>
                  
                </div>
</blockquote>
<blockquote class="callout" data-callout="warning">
<div class="callout-title">
                  <div class="callout-icon"><svg xmlns="http://www.w3.org/2000/svg" width="100%" height="100%" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="m21.73 18-8-14a2 2 0 0 0-3.48 0l-8 14A2 2 0 0 0 4 21h16a2 2 0 0 0 1.73-3Z"></path><line x1="12" y1="9" x2="12" y2="13"></line><line x1="12" y1="17" x2="12.01" y2="17"></line></svg></div>
                  <div class="callout-title-inner"><p>다소 잘못된 내용과 구어적 표현 이 포함되어 있을 수 있습니다. </p></div>
                  
                </div>
</blockquote>
<h2 id="failure-defect-error">Failure, Defect, Error<a aria-hidden="true" tabindex="-1" href="#failure-defect-error" class="internal"> §</a></h2>
<ul>
<li><strong>Failure(실패)</strong> : 시스템이 실행되는 도중 시스템이 받아들일 수 없는 행위가 발생한 경우
<ul>
<li>명세와 실행동작의 차이라고도 할 수 있고</li>
<li>이것을 기준으로 <strong>Reliability(신뢰도)</strong> 를 계산한다</li>
</ul>
</li>
<li><strong>Defect(결함)</strong> : 장애의 발생에 기여하거나 잠재적으로 기여할 수 있는 시스템에서의 결함</li>
<li><strong>Error(오류)</strong> : 시스템의 결함으로 이끄는 소프트웨어 개발자의 잘못이나 결정</li>
<li>이렇게 말하면 위 세가지가 뭔차이가 있는지 약간 헷갈리는데</li>
<li><strong>Failure</strong>는 결과적인 측면이다 - 시스템이 오작동한 결과를 말하는 것</li>
<li><strong>Defect</strong>은 시스템에서의 원인이다 - 시스템이 오작동하게된 시스템에서의 원인을 말하는 것</li>
<li><strong>Error</strong>는 개발자측면에서의 원인이다 - 시스템이 오작동하게된 개발자의 잘못을 말하는 것</li>
</ul>
<h2 id="testing">Testing<a aria-hidden="true" tabindex="-1" href="#testing" class="internal"> §</a></h2>
<ul>
<li>뭐 알다시피 시스템의 실패로 이끄는 결함이나 오류를 찾거나 명세와 구현이 일치함을 검증하는 과정을 말함
<ul>
<li>그래서 목적은 크게 결함 / 오류 찾기</li>
<li>명세 충족 확인</li>
<li>설계나 구현을 검증하는 것으로 생각할 수 있다</li>
</ul>
</li>
</ul>
<h3 id="test-case">Test Case<a aria-hidden="true" tabindex="-1" href="#test-case" class="internal"> §</a></h3>
<ul>
<li>입력값과 해당 입력값에 대한 예상되는 결과</li>
<li>얘네가 일치한다면 해당 Test가 통과한 것이고 아니면 통과하지 못한것(실패)</li>
<li>테케는 보통 이런것들로 이루어진다
<ul>
<li><strong>이름(ID)</strong></li>
<li><strong>대상</strong> - 뭐 측정한 method나 클래스, 서브시스템 등</li>
<li><strong>조건</strong> - 테스트 대상이 실행되기위한 조건(테스트를 가능하게 하는 조건)</li>
<li><strong>입력</strong></li>
<li><strong>예상 결과</strong>
<ul>
<li>여기서 <strong>Test Oracle</strong>은 테스트의 성공 / 실패를 판단하는 매커니즘 - 예를들면 예상결과와 실제 결과가 일치하는지 판단하는 것</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="좋은-테스팅">좋은 테스팅<a aria-hidden="true" tabindex="-1" href="#좋은-테스팅" class="internal"> §</a></h3>
<ul>
<li><strong>Test Effectively(효과적인 테스트)</strong> : 결함을 최대한 많이 발견하면 당연히 좋겠지</li>
<li><strong>Test Efficiently(효율적인 테스트)</strong> : 최대한 적은 노력과 테스트케이스로 최대한 많은 결함을 찾아내는 것</li>
<li>효과적 / 효율적인 테스트를 하지 못하면 배포 후의 유지보수비용이 늘어 금전적인 손해가 나거나 극단적으로는 사고가 나 인명피해가 발생하기도 하기 때문에 중허다</li>
</ul>
<h3 id="결함의-종류사례">결함의 종류(사례)<a aria-hidden="true" tabindex="-1" href="#결함의-종류사례" class="internal"> §</a></h3>
<ol>
<li><strong>Incorrect Logical Conditions</strong> : 반복이나 분기의 조건이 잘못된 경우
<ul>
<li>뭐 <strong>동등 분할 기법</strong>이나 <strong>경계값 분석 기법</strong>을 사용해서 찾아내거나</li>
<li>조건식에 사용되는 변수의 입력을 추적해보랜다</li>
</ul>
</li>
<li><strong>제어구조의 잘못된 부분에서 계산 수행</strong> : 프로그램이 수행하지 않아야 할 작업을 수행하거나 수행해야될것을 수행하지 않은 경우
<ul>
<li>반복이나 분기에서 작업이 부적절하게 제외되거나 포함되는 경우가 많댄다</li>
<li>이런건 반복 횟수를 특정하는(정확히 0번, 1번, 혹은 n번 돌게 하는) 테스트케이스를 설계함으로 결함을 찾는데 도움이 될 수 있댄다</li>
</ul>
</li>
<li><strong>NULL을 처리하지 않음</strong> : 제곧내</li>
<li><strong>Off-by-one</strong> : 1과 관련된것 - 값이 부적절하게 1이 더해지거나 빼지는 경우, 혹은 반복이 한번 더 돌더나 덜 도는 것</li>
<li><strong>Overflow</strong> : 자료형의 범위를 고려하지 않고 사용한 경우</li>
<li><strong>부동소수점의 값이 같다고 판단하는 경우</strong> : 부동소수점의 경우 값이 정확히 같을때보다 다를 확률이 더 많다 - 따라서 부동소수점의 경우에는 일치여부가 아니라 대소비교로 조건문을 줘야 한다</li>
</ol>
<h2 id="테스팅-기법">테스팅 기법<a aria-hidden="true" tabindex="-1" href="#테스팅-기법" class="internal"> §</a></h2>
<ul>
<li><strong>Black Box Testing</strong> : 얘는 입력값에 따른 예상 결과를 내부 논리구조를 생각하지 않고 선정하는 것을 의미한다</li>
<li>여기에는 <strong>Equivalence partitioning</strong>과 <strong>Boundary Value Analysis</strong>가 있다</li>
</ul>
<h3 id="equivalence-partitioning">Equivalence Partitioning<a aria-hidden="true" tabindex="-1" href="#equivalence-partitioning" class="internal"> §</a></h3>
<ul>
<li><strong>Equivalence Partitioning(동등 분할 기법)</strong> 은
<ol>
<li><strong>동치 클래스</strong> 결정을 하고</li>
<li>동치 클래스 각각에 대해 그 안에서 테스트케이스 각각을 선정하는 방법이다</li>
</ol>
</li>
<li>뭔 소린지는 예시를 들어서 설명하면</li>
</ul>
<p><img src="../../../../gardens/sw-eng/originals/softwareengineering.fall.2021.cse.cnu.ac.kr/images/09_f54c37d5ec5a4731873f19d67cbb1e90/image1.png" alt="%E1%84%8B%E1%85%B5%E1%84%85%E1%85%A9%E1%86%AB11%20-%20%E1%84%89%E1%85%A9%E1%84%91%E1%85%B3%E1%84%90%E1%85%B3%E1%84%8B%E1%85%B0%E1%84%8B%E1%85%A5%20%E1%84%90%E1%85%A6%E1%84%89%E1%85%B3%E1%84%90%E1%85%B3(1)%20f54c37d5ec5a4731873f19d67cbb1e90/image1.png"/></p>
<ul>
<li>일단 1부터 48사이의 정수가 정상 입력값이니까 1부터 48 사이의 정수가 정상 클래스가 되는거고</li>
<li>1부터 48 사이의 정수가 아닌 범위는 1보다 작은 정수, 48보다 큰 정수, 실수, 숫자가 아닌 값 정도로 나눌 수 있고 얘네 각각이 비정상 클래스가 되는 것이다</li>
<li>이제 이 클래스들에서 하나씩 테케 입력을 고르고 거기에 따른 예상되는 출력이 나오는지 확인하면 되는 것</li>
<li>위 예제에서 봤듯이 명세에 따라 값의 범위를 나누고 각각의 범위에서 테케를 고르는 방식으로 진행되는데</li>
<li>명세에 따라 값의 범위를 나누는 것을 <strong>동치 클래스</strong>를 결정한다고 한다
<ul>
<li><strong>동치 클래스</strong>는 우선 클래스는 그냥 집합으로 이해하면 되고 그 클래스에 들어가는 값들은 전부 동등하다 - 즉, 같은 출력을 내고 같은 방식으로 작동하는 값들의 집합을 의미하게 된다</li>
<li>만일 동치 클래스의 값들이 다른방식으로 작동한다면 그건 동치 클래스를 잘못 결정한거임</li>
<li>따라서 동치 클래스에서는 어떤 값을 선택해도 동일하기 때문에 아무 값이나 골라서 테케 입력으로 선정하는거임</li>
</ul>
</li>
</ul>
<h3 id="test-driver-stub">Test Driver, Stub<a aria-hidden="true" tabindex="-1" href="#test-driver-stub" class="internal"> §</a></h3>
<p><img src="../../../../gardens/sw-eng/originals/softwareengineering.fall.2021.cse.cnu.ac.kr/images/09_f54c37d5ec5a4731873f19d67cbb1e90/image2.png" alt="%E1%84%8B%E1%85%B5%E1%84%85%E1%85%A9%E1%86%AB11%20-%20%E1%84%89%E1%85%A9%E1%84%91%E1%85%B3%E1%84%90%E1%85%B3%E1%84%8B%E1%85%B0%E1%84%8B%E1%85%A5%20%E1%84%90%E1%85%A6%E1%84%89%E1%85%B3%E1%84%90%E1%85%B3(1)%20f54c37d5ec5a4731873f19d67cbb1e90/image2.png"/></p>
<ul>
<li>일단 프로그램의 구성요소중 하나(메소드 등)를 다른것과의 의존성을 고려하지 않고 테스트하는 것을 <strong>Unit Test</strong>라고 하는데</li>
<li>Unit test는 main함수를 실행시킬 수 없기 때문에 main함수를 대신해서 해당 부분을 실행시켜주는 놈을 <strong>Test Driver</strong>라고 하고</li>
<li>만일 그 부분이 다른 함수를 필요로 한다면 그 함수를 대신해서 mock값을 대신 제공해주는 것을 <strong>Test Stub</strong>이라고 한다
<ul>
<li>그니까 위 그림에서는 e를 테스트하려고 할때 f를 필요로 하지만 f는 동작시킬 수 없기 때문에 f의 반환값또한 테스트 이전에 제공해주는 기능을 하는 라이브러리를 말한다</li>
<li>JUnit의 when()메소드로 특정 함수의 반환값을 지정해줄 수 있었자네 - 이런게 <strong>Test Stub</strong> 이 되는거임</li>
</ul>
</li>
</ul>
<h3 id="boundary-value-analysis">Boundary Value Analysis<a aria-hidden="true" tabindex="-1" href="#boundary-value-analysis" class="internal"> §</a></h3>
<ul>
<li><strong>Boundary Value Analysis(경계값 분석, BVA)</strong> 는 결함이 보통 경계 부근에서 발견되기 때문에 경계 부근을 집중적으로 테스트하는 것을 말한다</li>
</ul>
<p><img src="../../../../gardens/sw-eng/originals/softwareengineering.fall.2021.cse.cnu.ac.kr/images/09_f54c37d5ec5a4731873f19d67cbb1e90/image3.png" alt="%E1%84%8B%E1%85%B5%E1%84%85%E1%85%A9%E1%86%AB11%20-%20%E1%84%89%E1%85%A9%E1%84%91%E1%85%B3%E1%84%90%E1%85%B3%E1%84%8B%E1%85%B0%E1%84%8B%E1%85%A5%20%E1%84%90%E1%85%A6%E1%84%89%E1%85%B3%E1%84%90%E1%85%B3(1)%20f54c37d5ec5a4731873f19d67cbb1e90/image3.png"/></p>
<ul>
<li>따라서 위 그림처럼 1, 100이 경계니까 그 부근인 0, 101을 <strong>비유효 경계 값</strong>(경계와 근접한 비정상 입력값)으로 하고 1, 100 이외에도 2, 99정도까지 <strong>유효 경계 값</strong>(경계와 근접한 정상 입력값)으로 선정하여 테스트하게 된다</li>
</ul></article></div><div class="right sidebar"><div class="graph "><h3>Graph View</h3><div class="graph-outer"><div id="graph-container" data-cfg="{&quot;drag&quot;:true,&quot;zoom&quot;:true,&quot;depth&quot;:1,&quot;scale&quot;:1.1,&quot;repelForce&quot;:0.5,&quot;centerForce&quot;:0.3,&quot;linkDistance&quot;:30,&quot;fontSize&quot;:0.6,&quot;opacityScale&quot;:1,&quot;showTags&quot;:true,&quot;removeTags&quot;:[]}"></div><svg version="1.1" id="global-graph-icon" xmlns="http://www.w3.org/2000/svg" xmlnsXlink="http://www.w3.org/1999/xlink" x="0px" y="0px" viewBox="0 0 55 55" fill="currentColor" xmlSpace="preserve"><path d="M49,0c-3.309,0-6,2.691-6,6c0,1.035,0.263,2.009,0.726,2.86l-9.829,9.829C32.542,17.634,30.846,17,29,17
	s-3.542,0.634-4.898,1.688l-7.669-7.669C16.785,10.424,17,9.74,17,9c0-2.206-1.794-4-4-4S9,6.794,9,9s1.794,4,4,4
	c0.74,0,1.424-0.215,2.019-0.567l7.669,7.669C21.634,21.458,21,23.154,21,25s0.634,3.542,1.688,4.897L10.024,42.562
	C8.958,41.595,7.549,41,6,41c-3.309,0-6,2.691-6,6s2.691,6,6,6s6-2.691,6-6c0-1.035-0.263-2.009-0.726-2.86l12.829-12.829
	c1.106,0.86,2.44,1.436,3.898,1.619v10.16c-2.833,0.478-5,2.942-5,5.91c0,3.309,2.691,6,6,6s6-2.691,6-6c0-2.967-2.167-5.431-5-5.91
	v-10.16c1.458-0.183,2.792-0.759,3.898-1.619l7.669,7.669C41.215,39.576,41,40.26,41,41c0,2.206,1.794,4,4,4s4-1.794,4-4
	s-1.794-4-4-4c-0.74,0-1.424,0.215-2.019,0.567l-7.669-7.669C36.366,28.542,37,26.846,37,25s-0.634-3.542-1.688-4.897l9.665-9.665
	C46.042,11.405,47.451,12,49,12c3.309,0,6-2.691,6-6S52.309,0,49,0z M11,9c0-1.103,0.897-2,2-2s2,0.897,2,2s-0.897,2-2,2
	S11,10.103,11,9z M6,51c-2.206,0-4-1.794-4-4s1.794-4,4-4s4,1.794,4,4S8.206,51,6,51z M33,49c0,2.206-1.794,4-4,4s-4-1.794-4-4
	s1.794-4,4-4S33,46.794,33,49z M29,31c-3.309,0-6-2.691-6-6s2.691-6,6-6s6,2.691,6,6S32.309,31,29,31z M47,41c0,1.103-0.897,2-2,2
	s-2-0.897-2-2s0.897-2,2-2S47,39.897,47,41z M49,10c-2.206,0-4-1.794-4-4s1.794-4,4-4s4,1.794,4,4S51.206,10,49,10z"></path></svg></div><div id="global-graph-outer"><div id="global-graph-container" data-cfg="{&quot;drag&quot;:true,&quot;zoom&quot;:true,&quot;depth&quot;:-1,&quot;scale&quot;:0.9,&quot;repelForce&quot;:0.5,&quot;centerForce&quot;:0.3,&quot;linkDistance&quot;:30,&quot;fontSize&quot;:0.6,&quot;opacityScale&quot;:1,&quot;showTags&quot;:true,&quot;removeTags&quot;:[]}"></div></div></div><div class="toc desktop-only"><button type="button" id="toc"><h3>Table of Contents</h3><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="fold"><polyline points="6 9 12 15 18 9"></polyline></svg></button><div id="toc-content"><ul class="overflow"><li class="depth-0"><a href="#failure-defect-error" data-for="failure-defect-error">Failure, Defect, Error</a></li><li class="depth-0"><a href="#testing" data-for="testing">Testing</a></li><li class="depth-1"><a href="#test-case" data-for="test-case">Test Case</a></li><li class="depth-1"><a href="#좋은-테스팅" data-for="좋은-테스팅">좋은 테스팅</a></li><li class="depth-1"><a href="#결함의-종류사례" data-for="결함의-종류사례">결함의 종류(사례)</a></li><li class="depth-0"><a href="#테스팅-기법" data-for="테스팅-기법">테스팅 기법</a></li><li class="depth-1"><a href="#equivalence-partitioning" data-for="equivalence-partitioning">Equivalence Partitioning</a></li><li class="depth-1"><a href="#test-driver-stub" data-for="test-driver-stub">Test Driver, Stub</a></li><li class="depth-1"><a href="#boundary-value-analysis" data-for="boundary-value-analysis">Boundary Value Analysis</a></li></ul></div></div><div class="backlinks "><h3>Backlinks</h3><ul class="overflow"><li><a href="../../../../gardens/sw-eng/originals/softwareengineering.fall.2021.cse.cnu.ac.kr/(충남대)-소프트웨어-공학-강의록" class="internal">(충남대) 소프트웨어 공학 강의록</a></li></ul></div></div></div><footer class><hr/><p>Created with <a href="https://quartz.jzhao.xyz/">Quartz v4.1.0</a>, © 2024</p><ul><li><a href="https://github.com/haeramkeem">GitHub</a></li><li><a href="www.linkedin.com/in/haeram-kim-277404220">LinkedIn</a></li><li><a href="mailto:haeram.kim1@gmail.com">Email</a></li></ul></footer></div></body><script type="application/javascript">// quartz/components/scripts/quartz/components/scripts/callout.inline.ts
function toggleCallout() {
  const outerBlock = this.parentElement;
  outerBlock.classList.toggle(`is-collapsed`);
  const collapsed = outerBlock.classList.contains(`is-collapsed`);
  const height = collapsed ? this.scrollHeight : outerBlock.scrollHeight;
  outerBlock.style.maxHeight = height + `px`;
  let current = outerBlock;
  let parent = outerBlock.parentElement;
  while (parent) {
    if (!parent.classList.contains(`callout`)) {
      return;
    }
    const collapsed2 = parent.classList.contains(`is-collapsed`);
    const height2 = collapsed2 ? parent.scrollHeight : parent.scrollHeight + current.scrollHeight;
    parent.style.maxHeight = height2 + `px`;
    current = parent;
    parent = parent.parentElement;
  }
}
function setupCallout() {
  const collapsible = document.getElementsByClassName(
    `callout is-collapsible`
  );
  for (const div of collapsible) {
    const title = div.firstElementChild;
    if (title) {
      title.removeEventListener(`click`, toggleCallout);
      title.addEventListener(`click`, toggleCallout);
      const collapsed = div.classList.contains(`is-collapsed`);
      const height = collapsed ? title.scrollHeight : div.scrollHeight;
      div.style.maxHeight = height + `px`;
    }
  }
}
document.addEventListener(`nav`, setupCallout);
window.addEventListener(`resize`, setupCallout);
</script><script type="module">
          import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.esm.min.mjs';
          const darkMode = document.documentElement.getAttribute('saved-theme') === 'dark'
          mermaid.initialize({
            startOnLoad: false,
            securityLevel: 'loose',
            theme: darkMode ? 'dark' : 'default'
          });
          document.addEventListener('nav', async () => {
            await mermaid.run({
              querySelector: '.mermaid'
            })
          });
          </script><script src="https://cdn.jsdelivr.net/npm/katex@0.16.7/dist/contrib/copy-tex.min.js" type="application/javascript"></script><script src="https://www.googletagmanager.com/gtag/js?id=G-N68CCP1QHG" type="application/javascript"></script><script src="../../../../postscript.js" type="module"></script></html>