<!DOCTYPE html>
<html><head><title>01. 소프트웨어 프로세스</title><meta charSet="utf-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:title" content="01. 소프트웨어 프로세스"/><meta property="og:description" content="충남대학교 컴퓨터공학과 김현수 교수님의 &amp;quot;소프트웨어 공학&amp;quot; 강의를 필기한 내용입니다. 다소 잘못된 내용과 구어적 표현 이 포함되어 있을 수 있습니다. 소프트웨어 개발 프로세스란 § 하나의 소프트웨어를 개발하는 과정 무엇을 해야 하는가 / 어떤 순서로 작업할 것인가를 결정하는데 도움이 되어야 함 말 그대로 도움이 되어야 함 - 모델들은 엄격하게 규정되기 보다는 지금 그리고 그 다음에 뭘 해야하는지는 생각하는데 도움이 되도록 구성되어 있다 각 프로젝트마다 성격이 다르므로 고유의 계획이 있어야 한다 즉흥적인 개발 프로세스의 문제점 § 설계가 제대로 안되어 품질이 떨어짐 계획이 없어 목표없이 일하게 됨 - 하나를 다 하고 나면 그 다음에 뭘 해야될지 모른다 테스트, 품질보증 등이 제대로 이루어지지 않음 위와 같은 이유로 개발과 유지보수 비용이 증가함 Waterfall Model (Phased Model) § 과정 § Requirements gathering and definition - 요구사항 수집과 정의 Specification - 명세 위 두 과정은 약간 블로그나 책마다 다르게 설명되어 있는데 대략 타당성 조사(비용 대비 이익이 얼마나 되는가, 주어진 시간 내에 우리가 가진 기술력으로 해결이 가능한가 등)와 요구사항 수집과 명세(문서화)정도로 이해하면 된다 Design - 디자인 여기서의 디자인은 외적인 디자인 말고도 시스템 전체에 대한 설계 등의 과정도 포함된다 Implementation - 구현 Integrate &amp;amp; Deploy - production build + deploy 같은 느낌 Maintenance - 유지보수 특징 § 현재의 단계가 끝나야 다음단계로 넘어가는 순차적인 구조로 진행된다 각 단계의 구분이 명확해 중복되는 작업이 이루어지지 않는다 그리고 각 단계가 시작되기 전에 전단계의 결과에 대해 점검하고 문서화 작업이 이루어진다 만일 문제점이 발견되면 바로 전 단계로 피드백을 주게 된다 장점 § 요구사항의 변경이 한정된 상황에서 유용 대규모 시스템 공학 프로젝트에서 많이 쓰임(대표적으로 국방관련 프로젝트) 단점 § 요구사항이 변경되었을 경우 대처하기가 힘들다 초기 단계(요구사항 분석과 설계 등)에서 잘못하면 미래가 어둡기 때문에 초기 단계가 중요한데 초기단계에서 힘을 너무 빼버리면 구현이나 테스트 등의 뒷 단계가 지연된다 단계가 전환될때 많은 노력이 필요하다 한번에 모든걸 끝내고하 하는 성격의 모델이기 때문에 프로토타입을 만들어볼 기회가 적다 앞으로의 단계에서 무슨일이 일어날지 모르기 때문에 갖가지 문서를 만들게 되는데 이 과정에서 쓸데없는 문서를 생산해낼 가능성이 있다 Prototype Model § 프로토타입의 종류 § 실험적 프로토타입 인간 - 기계 상호작용 프로토타입 : 뭐 ppt같은걸로 ui같은거 그려서 시나리오 짜보고 그런 경험 있제? 그런걸 말하는거다 Working prototype : 프로젝트의 가장 핵심적인 부분만 구현하여 프로토타입을 만들어보는 것 Throw-away prototype : 요구사항을 이해하기 위해 만들어서 버릴 생각으로 간단하게 만들어보는 것 점진적 프로토타입 개선을 목표로 요구되는 기능의 일부 또는 전체를 러프하게 만들어보는 것 과정 § System analysis - 시스템 분석 Requirement definition / design - 요구사항 분석 및 소프트웨어 설계 Prototype Development / Refinement - 프로토타입 구현과 코드 정리 Prototype Evaluation : 프로토타입 테스트(평가) 위의 네 단계가 이루어지고 프로토타입 평가 결과에 따라 1, 2, 3번의 과정을 다시 수행하여 평가가 통과할때까지 프로토타입을 만든다 Full-scale implementation - 프로토타입이 다 완성되었으면 정식 버전을 구현한다 Incremental Model § 과정 § 우선 이전의 모델들처럼 요구사항 분석, 명세 등의 과정을 다 끝낸다 그리고 구현할때 한번에 모든 기능을 구현하는 것이 아닌 기능별로 구현해서 여러번 배포할 목표로 계획을 하고 계획에 따라 구현, 배포한다 - 이게 핵심! 즉 바로 요구사항 분석 등의 과정이 끝난 후에 바로 소프트웨어 설계를 하는 것이 아닌 배포 계획을 세우고 각 배포 단계에 선행하여 설계를 하게 되는 것 각 배포 단계마다 설계, 구현, 테스트, 배포가 이루어진다 배포 구성 방법 § 점증적 방법 - 전체 시스템을 기능별로 쪼개어 그 기능이 구현될때마다 배포하는 방법 반복적 방법 - 기능을 다 구현한 다음 배포 하고 배포할때마다 기능들의 완성도를 높이는 방법 장점 § 빠른 시간 안에 시장에 출시해야 할 경우 강점을 가진다 시장에 처음으로 나온 소프트웨어의 경우 인지도 형성과 시장 점유에서 강점을 가지기 때문 자주 릴리즈를 하면 서비스 중일때 일어날 수 있는 문제를 빨리 파악하고 해결할 수 있다 기능별로 쪼개어 릴리즈를 하는 경우 개발팀이 각 배포 단계마다 하나의 기능에만 집중할 수 있기 때문에 기능의 완성도가 높아질 수 있다 Spiral Model § 1사분면이 요구사항 분석 등의 과정(Planning - 목표, 기능선택, 제약조건의 결정) 2사분면이 위험분석, 프로토타입 생성(Risk analysis - 기능선택의 우선순위, 위험요소의 분석) - 여기가 핵심! 4사분면이 구현 및 테스트(Engineering - 선택된 기능의 개발) 3사분면이 다음 단계 계획(Evaluation - 개발 결과의 평가) 이렇게 구성되어 있고 저렇게 빙글빙글 돌면서 반복한다는 컨셉인듯 이것도 반복적으로 배포하게 됨 점진적으로 반복해서 배포한다는 것은 다른 모델들과 비슷하나 위험부담을 최소화하기 위해 리스크 분석 단계가 존재하는 것이 나선형 모델의 가장 큰 특징인 듯 하다 장점 § 대규모 시스템 개발에 적합 리스트 분석을 매번 하기 때문에 리스크를 줄일 수 있다 반복적인 개발 및 테스트가 이루어진다 단점 § 관리가 중요 위험 분석이 중요 Evolutionary Model § 위의 그림처럼 하나 구현할때마다 설계 구현 시험 설치 운영을 거친다더라 Incremental Model과의 차이점은 Incremental Model의 경우에는 요구사항 분석등의 과정을 처음에 한번만 하고 그것을 토대로 앞으로의 계획을 짜서 여러번 배포하는 것이라면 Evolutionary Model은 매번 그것을 반복한다 아래의 UP 를 예시로 보면 이해하기 쉬움 이게 뭔지 UP (Unified Process) § 위의 그림을 어떻게 이해하면 되냐면 다음의 4단계가 하나의 사이클이라고 보면 된다 Inception(도입 단계) : 프로젝트의 범위를 설정하고 목표를 명확하게 함 Elaboration(정련 단계) : 시스템의 중요한 요구를 찾아내어 기본이 되는 설계를 완성 Construction(구축 단계) : 원시코드가 완성되고 중요한 요구의 테스트를 하는 것 Transition(전환 단계) : 사용자에게 릴리즈 근데 다른 모델들과의 차이점은 Inception 단계라고 해서 계획만 하는 것은 아니라는 거다 세로축에 있는 Business Modeling, Requirements, Analysis &amp;amp; Design, Implementation, Test, Deployment의 작업을 각 단계마다 수행하게 되는 것 하지만 각 단계마다 집중하는 비율은 당연히 달라지고 그 비율을 나타낸 것이 위의 그래프인 것 보면 Inception단계에서는 Business Modeling과 Requirements의 비중이 높은 것을 알 수 있고 Construction에서는 Implementation의 비율이 높은 것을 알 수 있다 즉, 다른 모델들은 각 단계마다 한가지의 일만을 하는 반면 UP에서는 비중만 달라질 뿐 모든 일을 골고루 처리한다는 차이점이 존재한다 Agile Model § Agile [형용사] : 빠른, 기민한, 날렵한, 민첩한 특징 § 설계가 변경되어도 쉽게 수용이 가능하도록 계획부터 배포까지의 사이클을 짧게 가져가는 것 점증적 설계 : 설계를 하되 나중에 충분히 개선될 여지가 있다는 것을 염두해 두고 설계에 대한 결정을 최대한 미루는 것 약 4-5주의 사이클로 계획 ~ 배포가 이루어진다 사용자를 팀에 아예 참여시켜 지속적으로 피드백을 받음 필요한 문서만 최소한으로 작성하고 대부분 소스코드로 대체, 커뮤니케이션도 문서를 통하기보다는 대화를 통해 해결 대규모의 프로젝트의 경우에는 설계가 자주 변경되는 것이 좋지 않으므로 소규모 프로젝트를 진행할때 적합하다 소규모의 프로젝트 같은 경우에는 설계가 자주 바뀌어도 품질에 크게 영향을 끼치지 않기 때문 과정 § 위처럼 요구사항 수립을 한 후에 지속적으로 개발 &amp;amp; 통합 &amp;amp; 테스트를 이어나가다가 고객에게 피드백을 받고 배포할지말지를 결정 빠꾸먹으면 왜 빠꾸먹었는지 등을 정리해놓고 다시 개발 &amp;amp; 통합 &amp;amp; 테스트 &amp;amp; 피드백 빠꾸 안먹어도 배포 후에 계속 요구사항을 정리해서 개발 &amp;amp; 통합 &amp;amp; 테스트 &amp;amp; 피드백 XP : eXtreme Programming § 최초의 애자일 프로세스랜다 Metaphor : 프로젝트에 사용할 아키텍처를 설계하는 것이 아닌 기존의 서비스 중 유사한 것의 아키텍처를 차용함 불필요하게 복잡한부분은 제거해서 설계 TDD를 중심적으로 개발 프로세스가 돌아감 Refactoring : 동일한 동작을 하되 더 간결하고 깔끔하게 시스템을 재구성 주당 40시간의 개발속도로 진행 코딩 컨벤션을 정해 동일한 규칙을 적용 과정 § Exploration : User story - 즉, 사용자의 니즈를 잘게 나누고 해당 니즈와 관련된 정보들을 모음."/><meta property="og:image" content="https://mdg.haeramk.im/static/og-image.png"/><meta property="og:width" content="1200"/><meta property="og:height" content="675"/><link rel="icon" href="../../../../static/icon.png"/><meta name="description" content="충남대학교 컴퓨터공학과 김현수 교수님의 &amp;quot;소프트웨어 공학&amp;quot; 강의를 필기한 내용입니다. 다소 잘못된 내용과 구어적 표현 이 포함되어 있을 수 있습니다. 소프트웨어 개발 프로세스란 § 하나의 소프트웨어를 개발하는 과정 무엇을 해야 하는가 / 어떤 순서로 작업할 것인가를 결정하는데 도움이 되어야 함 말 그대로 도움이 되어야 함 - 모델들은 엄격하게 규정되기 보다는 지금 그리고 그 다음에 뭘 해야하는지는 생각하는데 도움이 되도록 구성되어 있다 각 프로젝트마다 성격이 다르므로 고유의 계획이 있어야 한다 즉흥적인 개발 프로세스의 문제점 § 설계가 제대로 안되어 품질이 떨어짐 계획이 없어 목표없이 일하게 됨 - 하나를 다 하고 나면 그 다음에 뭘 해야될지 모른다 테스트, 품질보증 등이 제대로 이루어지지 않음 위와 같은 이유로 개발과 유지보수 비용이 증가함 Waterfall Model (Phased Model) § 과정 § Requirements gathering and definition - 요구사항 수집과 정의 Specification - 명세 위 두 과정은 약간 블로그나 책마다 다르게 설명되어 있는데 대략 타당성 조사(비용 대비 이익이 얼마나 되는가, 주어진 시간 내에 우리가 가진 기술력으로 해결이 가능한가 등)와 요구사항 수집과 명세(문서화)정도로 이해하면 된다 Design - 디자인 여기서의 디자인은 외적인 디자인 말고도 시스템 전체에 대한 설계 등의 과정도 포함된다 Implementation - 구현 Integrate &amp;amp; Deploy - production build + deploy 같은 느낌 Maintenance - 유지보수 특징 § 현재의 단계가 끝나야 다음단계로 넘어가는 순차적인 구조로 진행된다 각 단계의 구분이 명확해 중복되는 작업이 이루어지지 않는다 그리고 각 단계가 시작되기 전에 전단계의 결과에 대해 점검하고 문서화 작업이 이루어진다 만일 문제점이 발견되면 바로 전 단계로 피드백을 주게 된다 장점 § 요구사항의 변경이 한정된 상황에서 유용 대규모 시스템 공학 프로젝트에서 많이 쓰임(대표적으로 국방관련 프로젝트) 단점 § 요구사항이 변경되었을 경우 대처하기가 힘들다 초기 단계(요구사항 분석과 설계 등)에서 잘못하면 미래가 어둡기 때문에 초기 단계가 중요한데 초기단계에서 힘을 너무 빼버리면 구현이나 테스트 등의 뒷 단계가 지연된다 단계가 전환될때 많은 노력이 필요하다 한번에 모든걸 끝내고하 하는 성격의 모델이기 때문에 프로토타입을 만들어볼 기회가 적다 앞으로의 단계에서 무슨일이 일어날지 모르기 때문에 갖가지 문서를 만들게 되는데 이 과정에서 쓸데없는 문서를 생산해낼 가능성이 있다 Prototype Model § 프로토타입의 종류 § 실험적 프로토타입 인간 - 기계 상호작용 프로토타입 : 뭐 ppt같은걸로 ui같은거 그려서 시나리오 짜보고 그런 경험 있제? 그런걸 말하는거다 Working prototype : 프로젝트의 가장 핵심적인 부분만 구현하여 프로토타입을 만들어보는 것 Throw-away prototype : 요구사항을 이해하기 위해 만들어서 버릴 생각으로 간단하게 만들어보는 것 점진적 프로토타입 개선을 목표로 요구되는 기능의 일부 또는 전체를 러프하게 만들어보는 것 과정 § System analysis - 시스템 분석 Requirement definition / design - 요구사항 분석 및 소프트웨어 설계 Prototype Development / Refinement - 프로토타입 구현과 코드 정리 Prototype Evaluation : 프로토타입 테스트(평가) 위의 네 단계가 이루어지고 프로토타입 평가 결과에 따라 1, 2, 3번의 과정을 다시 수행하여 평가가 통과할때까지 프로토타입을 만든다 Full-scale implementation - 프로토타입이 다 완성되었으면 정식 버전을 구현한다 Incremental Model § 과정 § 우선 이전의 모델들처럼 요구사항 분석, 명세 등의 과정을 다 끝낸다 그리고 구현할때 한번에 모든 기능을 구현하는 것이 아닌 기능별로 구현해서 여러번 배포할 목표로 계획을 하고 계획에 따라 구현, 배포한다 - 이게 핵심! 즉 바로 요구사항 분석 등의 과정이 끝난 후에 바로 소프트웨어 설계를 하는 것이 아닌 배포 계획을 세우고 각 배포 단계에 선행하여 설계를 하게 되는 것 각 배포 단계마다 설계, 구현, 테스트, 배포가 이루어진다 배포 구성 방법 § 점증적 방법 - 전체 시스템을 기능별로 쪼개어 그 기능이 구현될때마다 배포하는 방법 반복적 방법 - 기능을 다 구현한 다음 배포 하고 배포할때마다 기능들의 완성도를 높이는 방법 장점 § 빠른 시간 안에 시장에 출시해야 할 경우 강점을 가진다 시장에 처음으로 나온 소프트웨어의 경우 인지도 형성과 시장 점유에서 강점을 가지기 때문 자주 릴리즈를 하면 서비스 중일때 일어날 수 있는 문제를 빨리 파악하고 해결할 수 있다 기능별로 쪼개어 릴리즈를 하는 경우 개발팀이 각 배포 단계마다 하나의 기능에만 집중할 수 있기 때문에 기능의 완성도가 높아질 수 있다 Spiral Model § 1사분면이 요구사항 분석 등의 과정(Planning - 목표, 기능선택, 제약조건의 결정) 2사분면이 위험분석, 프로토타입 생성(Risk analysis - 기능선택의 우선순위, 위험요소의 분석) - 여기가 핵심! 4사분면이 구현 및 테스트(Engineering - 선택된 기능의 개발) 3사분면이 다음 단계 계획(Evaluation - 개발 결과의 평가) 이렇게 구성되어 있고 저렇게 빙글빙글 돌면서 반복한다는 컨셉인듯 이것도 반복적으로 배포하게 됨 점진적으로 반복해서 배포한다는 것은 다른 모델들과 비슷하나 위험부담을 최소화하기 위해 리스크 분석 단계가 존재하는 것이 나선형 모델의 가장 큰 특징인 듯 하다 장점 § 대규모 시스템 개발에 적합 리스트 분석을 매번 하기 때문에 리스크를 줄일 수 있다 반복적인 개발 및 테스트가 이루어진다 단점 § 관리가 중요 위험 분석이 중요 Evolutionary Model § 위의 그림처럼 하나 구현할때마다 설계 구현 시험 설치 운영을 거친다더라 Incremental Model과의 차이점은 Incremental Model의 경우에는 요구사항 분석등의 과정을 처음에 한번만 하고 그것을 토대로 앞으로의 계획을 짜서 여러번 배포하는 것이라면 Evolutionary Model은 매번 그것을 반복한다 아래의 UP 를 예시로 보면 이해하기 쉬움 이게 뭔지 UP (Unified Process) § 위의 그림을 어떻게 이해하면 되냐면 다음의 4단계가 하나의 사이클이라고 보면 된다 Inception(도입 단계) : 프로젝트의 범위를 설정하고 목표를 명확하게 함 Elaboration(정련 단계) : 시스템의 중요한 요구를 찾아내어 기본이 되는 설계를 완성 Construction(구축 단계) : 원시코드가 완성되고 중요한 요구의 테스트를 하는 것 Transition(전환 단계) : 사용자에게 릴리즈 근데 다른 모델들과의 차이점은 Inception 단계라고 해서 계획만 하는 것은 아니라는 거다 세로축에 있는 Business Modeling, Requirements, Analysis &amp;amp; Design, Implementation, Test, Deployment의 작업을 각 단계마다 수행하게 되는 것 하지만 각 단계마다 집중하는 비율은 당연히 달라지고 그 비율을 나타낸 것이 위의 그래프인 것 보면 Inception단계에서는 Business Modeling과 Requirements의 비중이 높은 것을 알 수 있고 Construction에서는 Implementation의 비율이 높은 것을 알 수 있다 즉, 다른 모델들은 각 단계마다 한가지의 일만을 하는 반면 UP에서는 비중만 달라질 뿐 모든 일을 골고루 처리한다는 차이점이 존재한다 Agile Model § Agile [형용사] : 빠른, 기민한, 날렵한, 민첩한 특징 § 설계가 변경되어도 쉽게 수용이 가능하도록 계획부터 배포까지의 사이클을 짧게 가져가는 것 점증적 설계 : 설계를 하되 나중에 충분히 개선될 여지가 있다는 것을 염두해 두고 설계에 대한 결정을 최대한 미루는 것 약 4-5주의 사이클로 계획 ~ 배포가 이루어진다 사용자를 팀에 아예 참여시켜 지속적으로 피드백을 받음 필요한 문서만 최소한으로 작성하고 대부분 소스코드로 대체, 커뮤니케이션도 문서를 통하기보다는 대화를 통해 해결 대규모의 프로젝트의 경우에는 설계가 자주 변경되는 것이 좋지 않으므로 소규모 프로젝트를 진행할때 적합하다 소규모의 프로젝트 같은 경우에는 설계가 자주 바뀌어도 품질에 크게 영향을 끼치지 않기 때문 과정 § 위처럼 요구사항 수립을 한 후에 지속적으로 개발 &amp;amp; 통합 &amp;amp; 테스트를 이어나가다가 고객에게 피드백을 받고 배포할지말지를 결정 빠꾸먹으면 왜 빠꾸먹었는지 등을 정리해놓고 다시 개발 &amp;amp; 통합 &amp;amp; 테스트 &amp;amp; 피드백 빠꾸 안먹어도 배포 후에 계속 요구사항을 정리해서 개발 &amp;amp; 통합 &amp;amp; 테스트 &amp;amp; 피드백 XP : eXtreme Programming § 최초의 애자일 프로세스랜다 Metaphor : 프로젝트에 사용할 아키텍처를 설계하는 것이 아닌 기존의 서비스 중 유사한 것의 아키텍처를 차용함 불필요하게 복잡한부분은 제거해서 설계 TDD를 중심적으로 개발 프로세스가 돌아감 Refactoring : 동일한 동작을 하되 더 간결하고 깔끔하게 시스템을 재구성 주당 40시간의 개발속도로 진행 코딩 컨벤션을 정해 동일한 규칙을 적용 과정 § Exploration : User story - 즉, 사용자의 니즈를 잘게 나누고 해당 니즈와 관련된 정보들을 모음."/><meta name="generator" content="Quartz"/><link rel="preconnect" href="https://fonts.googleapis.com"/><link rel="preconnect" href="https://fonts.gstatic.com"/><link href="../../../../index.css" rel="stylesheet" type="text/css" spa-preserve/><link href="https://cdn.jsdelivr.net/npm/katex@0.16.0/dist/katex.min.css" rel="stylesheet" type="text/css" spa-preserve/><link href="https://fonts.googleapis.com/css2?family=IBM Plex Mono&amp;family=Gowun Batang:wght@400;700&amp;family=Gowun Dodum:ital,wght@0,400;0,600;1,400;1,600&amp;display=swap" rel="stylesheet" type="text/css" spa-preserve/><script src="../../../../prescript.js" type="application/javascript" spa-preserve></script><script type="application/javascript" spa-preserve>const fetchData = fetch(`../../../../static/contentIndex.json`).then(data => data.json())</script></head><body data-slug="gardens/sw-eng/originals/softwareengineering.fall.2021.cse.cnu.ac.kr/01.-소프트웨어-프로세스"><div id="quartz-root" class="page"><div id="quartz-body"><div class="left sidebar"><h1 class="page-title "><a href="../../../..">Madison Digital Garden</a></h1><div class="spacer mobile-only"></div><div class="search "><div id="search-icon"><p>Search</p><div></div><svg tabIndex="0" aria-labelledby="title desc" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 19.9 19.7"><title id="title">Search</title><desc id="desc">Search</desc><g class="search-path" fill="none"><path stroke-linecap="square" d="M18.5 18.3l-5.4-5.4"></path><circle cx="8" cy="8" r="7"></circle></g></svg></div><div id="search-container"><div id="search-space"><input autocomplete="off" id="search-bar" name="search" type="text" aria-label="Search for something" placeholder="Search for something"/><div id="results-container"></div></div></div></div><div class="darkmode "><input class="toggle" id="darkmode-toggle" type="checkbox" tabIndex="-1"/><label id="toggle-label-light" for="darkmode-toggle" tabIndex="-1"><svg xmlns="http://www.w3.org/2000/svg" xmlnsXlink="http://www.w3.org/1999/xlink" version="1.1" id="dayIcon" x="0px" y="0px" viewBox="0 0 35 35" style="enable-background:new 0 0 35 35;" xmlSpace="preserve"><title>Light mode</title><path d="M6,17.5C6,16.672,5.328,16,4.5,16h-3C0.672,16,0,16.672,0,17.5    S0.672,19,1.5,19h3C5.328,19,6,18.328,6,17.5z M7.5,26c-0.414,0-0.789,0.168-1.061,0.439l-2,2C4.168,28.711,4,29.086,4,29.5    C4,30.328,4.671,31,5.5,31c0.414,0,0.789-0.168,1.06-0.44l2-2C8.832,28.289,9,27.914,9,27.5C9,26.672,8.329,26,7.5,26z M17.5,6    C18.329,6,19,5.328,19,4.5v-3C19,0.672,18.329,0,17.5,0S16,0.672,16,1.5v3C16,5.328,16.671,6,17.5,6z M27.5,9    c0.414,0,0.789-0.168,1.06-0.439l2-2C30.832,6.289,31,5.914,31,5.5C31,4.672,30.329,4,29.5,4c-0.414,0-0.789,0.168-1.061,0.44    l-2,2C26.168,6.711,26,7.086,26,7.5C26,8.328,26.671,9,27.5,9z M6.439,8.561C6.711,8.832,7.086,9,7.5,9C8.328,9,9,8.328,9,7.5    c0-0.414-0.168-0.789-0.439-1.061l-2-2C6.289,4.168,5.914,4,5.5,4C4.672,4,4,4.672,4,5.5c0,0.414,0.168,0.789,0.439,1.06    L6.439,8.561z M33.5,16h-3c-0.828,0-1.5,0.672-1.5,1.5s0.672,1.5,1.5,1.5h3c0.828,0,1.5-0.672,1.5-1.5S34.328,16,33.5,16z     M28.561,26.439C28.289,26.168,27.914,26,27.5,26c-0.828,0-1.5,0.672-1.5,1.5c0,0.414,0.168,0.789,0.439,1.06l2,2    C28.711,30.832,29.086,31,29.5,31c0.828,0,1.5-0.672,1.5-1.5c0-0.414-0.168-0.789-0.439-1.061L28.561,26.439z M17.5,29    c-0.829,0-1.5,0.672-1.5,1.5v3c0,0.828,0.671,1.5,1.5,1.5s1.5-0.672,1.5-1.5v-3C19,29.672,18.329,29,17.5,29z M17.5,7    C11.71,7,7,11.71,7,17.5S11.71,28,17.5,28S28,23.29,28,17.5S23.29,7,17.5,7z M17.5,25c-4.136,0-7.5-3.364-7.5-7.5    c0-4.136,3.364-7.5,7.5-7.5c4.136,0,7.5,3.364,7.5,7.5C25,21.636,21.636,25,17.5,25z"></path></svg></label><label id="toggle-label-dark" for="darkmode-toggle" tabIndex="-1"><svg xmlns="http://www.w3.org/2000/svg" xmlnsXlink="http://www.w3.org/1999/xlink" version="1.1" id="nightIcon" x="0px" y="0px" viewBox="0 0 100 100" style="enable-background='new 0 0 100 100'" xmlSpace="preserve"><title>Dark mode</title><path d="M96.76,66.458c-0.853-0.852-2.15-1.064-3.23-0.534c-6.063,2.991-12.858,4.571-19.655,4.571  C62.022,70.495,50.88,65.88,42.5,57.5C29.043,44.043,25.658,23.536,34.076,6.47c0.532-1.08,0.318-2.379-0.534-3.23  c-0.851-0.852-2.15-1.064-3.23-0.534c-4.918,2.427-9.375,5.619-13.246,9.491c-9.447,9.447-14.65,22.008-14.65,35.369  c0,13.36,5.203,25.921,14.65,35.368s22.008,14.65,35.368,14.65c13.361,0,25.921-5.203,35.369-14.65  c3.872-3.871,7.064-8.328,9.491-13.246C97.826,68.608,97.611,67.309,96.76,66.458z"></path></svg></label></div></div><div class="center"><div class="page-header"><div class="popover-hint"><h1 class="article-title ">01. 소프트웨어 프로세스</h1><p class="content-meta ">Dec 23, 2024, 20 min read</p></div></div><article class="popover-hint"><blockquote class="callout" data-callout="info">
<div class="callout-title">
                  <div class="callout-icon"><svg xmlns="http://www.w3.org/2000/svg" width="100%" height="100%" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="10"></circle><line x1="12" y1="16" x2="12" y2="12"></line><line x1="12" y1="8" x2="12.01" y2="8"></line></svg></div>
                  <div class="callout-title-inner"><p>충남대학교 컴퓨터공학과 김현수 교수님의 &quot;소프트웨어 공학&quot; 강의를 필기한 내용입니다. </p></div>
                  
                </div>
</blockquote>
<blockquote class="callout" data-callout="warning">
<div class="callout-title">
                  <div class="callout-icon"><svg xmlns="http://www.w3.org/2000/svg" width="100%" height="100%" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="m21.73 18-8-14a2 2 0 0 0-3.48 0l-8 14A2 2 0 0 0 4 21h16a2 2 0 0 0 1.73-3Z"></path><line x1="12" y1="9" x2="12" y2="13"></line><line x1="12" y1="17" x2="12.01" y2="17"></line></svg></div>
                  <div class="callout-title-inner"><p>다소 잘못된 내용과 구어적 표현 이 포함되어 있을 수 있습니다. </p></div>
                  
                </div>
</blockquote>
<h2 id="소프트웨어-개발-프로세스란">소프트웨어 개발 프로세스란<a aria-hidden="true" tabindex="-1" href="#소프트웨어-개발-프로세스란" class="internal"> §</a></h2>
<ul>
<li>하나의 소프트웨어를 개발하는 과정</li>
<li>무엇을 해야 하는가 / 어떤 순서로 작업할 것인가를 결정하는데 도움이 되어야 함
<ul>
<li>말 그대로 도움이 되어야 함 - 모델들은 엄격하게 규정되기 보다는 지금 그리고 그 다음에 뭘 해야하는지는 생각하는데 도움이 되도록 구성되어 있다</li>
</ul>
</li>
<li>각 프로젝트마다 성격이 다르므로 고유의 계획이 있어야 한다</li>
</ul>
<h3 id="즉흥적인-개발-프로세스의-문제점">즉흥적인 개발 프로세스의 문제점<a aria-hidden="true" tabindex="-1" href="#즉흥적인-개발-프로세스의-문제점" class="internal"> §</a></h3>
<ul>
<li>설계가 제대로 안되어 품질이 떨어짐</li>
<li>계획이 없어 목표없이 일하게 됨 - 하나를 다 하고 나면 그 다음에 뭘 해야될지 모른다</li>
<li>테스트, 품질보증 등이 제대로 이루어지지 않음</li>
<li>위와 같은 이유로 개발과 유지보수 비용이 증가함</li>
</ul>
<h2 id="waterfall-model-phased-model">Waterfall Model (Phased Model)<a aria-hidden="true" tabindex="-1" href="#waterfall-model-phased-model" class="internal"> §</a></h2>
<h3 id="과정">과정<a aria-hidden="true" tabindex="-1" href="#과정" class="internal"> §</a></h3>
<p><img src="../../../../gardens/sw-eng/originals/softwareengineering.fall.2021.cse.cnu.ac.kr/images/01_96375d189c39451d93f318a757a7d1a9/image1.png" alt="%E1%84%8B%E1%85%B5%E1%84%85%E1%85%A9%E1%86%AB02%20-%20%E1%84%89%E1%85%A9%E1%84%91%E1%85%B3%E1%84%90%E1%85%B3%E1%84%8B%E1%85%B0%E1%84%8B%E1%85%A5%20%E1%84%91%E1%85%B3%E1%84%85%E1%85%A9%E1%84%89%E1%85%A6%E1%84%89%E1%85%B3%2096375d189c39451d93f318a757a7d1a9/image1.png"/></p>
<ol>
<li>Requirements gathering and definition - 요구사항 수집과 정의</li>
<li>Specification - 명세
<ul>
<li>위 두 과정은 약간 블로그나 책마다 다르게 설명되어 있는데 대략 타당성 조사(비용 대비 이익이 얼마나 되는가, 주어진 시간 내에 우리가 가진 기술력으로 해결이 가능한가 등)와 요구사항 수집과 명세(문서화)정도로 이해하면 된다</li>
</ul>
</li>
<li>Design - 디자인
<ul>
<li>여기서의 디자인은 외적인 디자인 말고도 시스템 전체에 대한 설계 등의 과정도 포함된다</li>
</ul>
</li>
<li>Implementation - 구현</li>
<li>Integrate &amp; Deploy - production build + deploy 같은 느낌</li>
<li>Maintenance - 유지보수</li>
</ol>
<h3 id="특징">특징<a aria-hidden="true" tabindex="-1" href="#특징" class="internal"> §</a></h3>
<ul>
<li>현재의 단계가 끝나야 다음단계로 넘어가는 순차적인 구조로 진행된다</li>
<li>각 단계의 구분이 명확해 중복되는 작업이 이루어지지 않는다</li>
<li>그리고 각 단계가 시작되기 전에 전단계의 결과에 대해 점검하고 문서화 작업이 이루어진다</li>
<li>만일 문제점이 발견되면 바로 전 단계로 피드백을 주게 된다</li>
</ul>
<h3 id="장점">장점<a aria-hidden="true" tabindex="-1" href="#장점" class="internal"> §</a></h3>
<ul>
<li>요구사항의 변경이 한정된 상황에서 유용</li>
<li>대규모 시스템 공학 프로젝트에서 많이 쓰임(대표적으로 국방관련 프로젝트)</li>
</ul>
<h3 id="단점">단점<a aria-hidden="true" tabindex="-1" href="#단점" class="internal"> §</a></h3>
<ul>
<li>요구사항이 변경되었을 경우 대처하기가 힘들다</li>
<li>초기 단계(요구사항 분석과 설계 등)에서 잘못하면 미래가 어둡기 때문에 초기 단계가 중요한데 초기단계에서 힘을 너무 빼버리면 구현이나 테스트 등의 뒷 단계가 지연된다</li>
<li>단계가 전환될때 많은 노력이 필요하다</li>
<li>한번에 모든걸 끝내고하 하는 성격의 모델이기 때문에 프로토타입을 만들어볼 기회가 적다</li>
<li>앞으로의 단계에서 무슨일이 일어날지 모르기 때문에 갖가지 문서를 만들게 되는데 이 과정에서 쓸데없는 문서를 생산해낼 가능성이 있다</li>
</ul>
<h2 id="prototype-model">Prototype Model<a aria-hidden="true" tabindex="-1" href="#prototype-model" class="internal"> §</a></h2>
<h3 id="프로토타입의-종류">프로토타입의 종류<a aria-hidden="true" tabindex="-1" href="#프로토타입의-종류" class="internal"> §</a></h3>
<ul>
<li>실험적 프로토타입
<ol>
<li><strong>인간 - 기계 상호작용 프로토타입</strong> : 뭐 ppt같은걸로 ui같은거 그려서 시나리오 짜보고 그런 경험 있제? 그런걸 말하는거다</li>
<li><strong>Working prototype</strong> : 프로젝트의 가장 핵심적인 부분만 구현하여 프로토타입을 만들어보는 것</li>
<li><strong>Throw-away prototype</strong> : 요구사항을 이해하기 위해 만들어서 버릴 생각으로 간단하게 만들어보는 것</li>
</ol>
</li>
<li>점진적 프로토타입
<ol>
<li>개선을 목표로 요구되는 기능의 일부 또는 전체를 러프하게 만들어보는 것</li>
</ol>
</li>
</ul>
<h3 id="과정-1">과정<a aria-hidden="true" tabindex="-1" href="#과정-1" class="internal"> §</a></h3>
<p><img src="../../../../gardens/sw-eng/originals/softwareengineering.fall.2021.cse.cnu.ac.kr/images/01_96375d189c39451d93f318a757a7d1a9/image2.png" alt="%E1%84%8B%E1%85%B5%E1%84%85%E1%85%A9%E1%86%AB02%20-%20%E1%84%89%E1%85%A9%E1%84%91%E1%85%B3%E1%84%90%E1%85%B3%E1%84%8B%E1%85%B0%E1%84%8B%E1%85%A5%20%E1%84%91%E1%85%B3%E1%84%85%E1%85%A9%E1%84%89%E1%85%A6%E1%84%89%E1%85%B3%2096375d189c39451d93f318a757a7d1a9/image2.png"/></p>
<ol>
<li>System analysis - 시스템 분석</li>
<li>Requirement definition / design - 요구사항 분석 및 소프트웨어 설계</li>
<li>Prototype Development / Refinement - 프로토타입 구현과 코드 정리</li>
<li>Prototype Evaluation : 프로토타입 테스트(평가)
<ul>
<li>위의 네 단계가 이루어지고 프로토타입 평가 결과에 따라 1, 2, 3번의 과정을 다시 수행하여 평가가 통과할때까지 프로토타입을 만든다</li>
</ul>
</li>
<li>Full-scale implementation - 프로토타입이 다 완성되었으면 정식 버전을 구현한다</li>
</ol>
<h2 id="incremental-model">Incremental Model<a aria-hidden="true" tabindex="-1" href="#incremental-model" class="internal"> §</a></h2>
<h3 id="과정-2">과정<a aria-hidden="true" tabindex="-1" href="#과정-2" class="internal"> §</a></h3>
<p><img src="../../../../gardens/sw-eng/originals/softwareengineering.fall.2021.cse.cnu.ac.kr/images/01_96375d189c39451d93f318a757a7d1a9/image3.png" alt="%E1%84%8B%E1%85%B5%E1%84%85%E1%85%A9%E1%86%AB02%20-%20%E1%84%89%E1%85%A9%E1%84%91%E1%85%B3%E1%84%90%E1%85%B3%E1%84%8B%E1%85%B0%E1%84%8B%E1%85%A5%20%E1%84%91%E1%85%B3%E1%84%85%E1%85%A9%E1%84%89%E1%85%A6%E1%84%89%E1%85%B3%2096375d189c39451d93f318a757a7d1a9/image3.png"/></p>
<ul>
<li>우선 이전의 모델들처럼 요구사항 분석, 명세 등의 과정을 다 끝낸다</li>
<li>그리고 구현할때 한번에 모든 기능을 구현하는 것이 아닌 기능별로 구현해서 여러번 배포할 목표로 계획을 하고 계획에 따라 구현, 배포한다 - 이게 핵심!
<ul>
<li>즉 바로 요구사항 분석 등의 과정이 끝난 후에 바로 소프트웨어 설계를 하는 것이 아닌 배포 계획을 세우고 각 배포 단계에 선행하여 설계를 하게 되는 것</li>
</ul>
</li>
<li>각 배포 단계마다 설계, 구현, 테스트, 배포가 이루어진다</li>
</ul>
<h3 id="배포-구성-방법">배포 구성 방법<a aria-hidden="true" tabindex="-1" href="#배포-구성-방법" class="internal"> §</a></h3>
<ul>
<li><strong>점증적 방법</strong> - 전체 시스템을 기능별로 쪼개어 그 기능이 구현될때마다 배포하는 방법</li>
<li><strong>반복적 방법</strong> - 기능을 다 구현한 다음 배포 하고 배포할때마다 기능들의 완성도를 높이는 방법</li>
</ul>
<h3 id="장점-1">장점<a aria-hidden="true" tabindex="-1" href="#장점-1" class="internal"> §</a></h3>
<ol>
<li>빠른 시간 안에 시장에 출시해야 할 경우 강점을 가진다
<ul>
<li>시장에 처음으로 나온 소프트웨어의 경우 인지도 형성과 시장 점유에서 강점을 가지기 때문</li>
</ul>
</li>
<li>자주 릴리즈를 하면 서비스 중일때 일어날 수 있는 문제를 빨리 파악하고 해결할 수 있다</li>
<li>기능별로 쪼개어 릴리즈를 하는 경우 개발팀이 각 배포 단계마다 하나의 기능에만 집중할 수 있기 때문에 기능의 완성도가 높아질 수 있다</li>
</ol>
<h2 id="spiral-model">Spiral Model<a aria-hidden="true" tabindex="-1" href="#spiral-model" class="internal"> §</a></h2>
<p><img src="../../../../gardens/sw-eng/originals/softwareengineering.fall.2021.cse.cnu.ac.kr/images/01_96375d189c39451d93f318a757a7d1a9/image4.png" alt="%E1%84%8B%E1%85%B5%E1%84%85%E1%85%A9%E1%86%AB02%20-%20%E1%84%89%E1%85%A9%E1%84%91%E1%85%B3%E1%84%90%E1%85%B3%E1%84%8B%E1%85%B0%E1%84%8B%E1%85%A5%20%E1%84%91%E1%85%B3%E1%84%85%E1%85%A9%E1%84%89%E1%85%A6%E1%84%89%E1%85%B3%2096375d189c39451d93f318a757a7d1a9/image4.png"/></p>
<ul>
<li>1사분면이 요구사항 분석 등의 과정(<strong>Planning</strong> - 목표, 기능선택, 제약조건의 결정)</li>
<li>2사분면이 위험분석, 프로토타입 생성(<strong>Risk analysis</strong> - 기능선택의 우선순위, 위험요소의 분석) - 여기가 핵심!</li>
<li>4사분면이 구현 및 테스트(<strong>Engineering</strong> - 선택된 기능의 개발)</li>
<li>3사분면이 다음 단계 계획(<strong>Evaluation</strong> - 개발 결과의 평가)</li>
<li>이렇게 구성되어 있고 저렇게 빙글빙글 돌면서 반복한다는 컨셉인듯</li>
<li>이것도 반복적으로 배포하게 됨</li>
<li>점진적으로 반복해서 배포한다는 것은 다른 모델들과 비슷하나 위험부담을 최소화하기 위해 리스크 분석 단계가 존재하는 것이 나선형 모델의 가장 큰 특징인 듯 하다</li>
</ul>
<h3 id="장점-2">장점<a aria-hidden="true" tabindex="-1" href="#장점-2" class="internal"> §</a></h3>
<ol>
<li>대규모 시스템 개발에 적합</li>
<li>리스트 분석을 매번 하기 때문에 리스크를 줄일 수 있다</li>
<li>반복적인 개발 및 테스트가 이루어진다</li>
</ol>
<h3 id="단점-1">단점<a aria-hidden="true" tabindex="-1" href="#단점-1" class="internal"> §</a></h3>
<ol>
<li>관리가 중요</li>
<li>위험 분석이 중요</li>
</ol>
<h2 id="evolutionary-model">Evolutionary Model<a aria-hidden="true" tabindex="-1" href="#evolutionary-model" class="internal"> §</a></h2>
<p><img src="../../../../gardens/sw-eng/originals/softwareengineering.fall.2021.cse.cnu.ac.kr/images/01_96375d189c39451d93f318a757a7d1a9/image5.png" alt="%E1%84%8B%E1%85%B5%E1%84%85%E1%85%A9%E1%86%AB02%20-%20%E1%84%89%E1%85%A9%E1%84%91%E1%85%B3%E1%84%90%E1%85%B3%E1%84%8B%E1%85%B0%E1%84%8B%E1%85%A5%20%E1%84%91%E1%85%B3%E1%84%85%E1%85%A9%E1%84%89%E1%85%A6%E1%84%89%E1%85%B3%2096375d189c39451d93f318a757a7d1a9/image5.png"/></p>
<ul>
<li>위의 그림처럼 하나 구현할때마다 설계 구현 시험 설치 운영을 거친다더라</li>
<li>Incremental Model과의 차이점은 Incremental Model의 경우에는 요구사항 분석등의 과정을 처음에 한번만 하고 그것을 토대로 앞으로의 계획을 짜서 여러번 배포하는 것이라면</li>
<li>Evolutionary Model은 매번 그것을 반복한다</li>
<li>아래의 UP 를 예시로 보면 이해하기 쉬움 이게 뭔지</li>
</ul>
<h3 id="up-unified-process">UP (Unified Process)<a aria-hidden="true" tabindex="-1" href="#up-unified-process" class="internal"> §</a></h3>
<p><img src="../../../../gardens/sw-eng/originals/softwareengineering.fall.2021.cse.cnu.ac.kr/images/01_96375d189c39451d93f318a757a7d1a9/image6.png" alt="%E1%84%8B%E1%85%B5%E1%84%85%E1%85%A9%E1%86%AB02%20-%20%E1%84%89%E1%85%A9%E1%84%91%E1%85%B3%E1%84%90%E1%85%B3%E1%84%8B%E1%85%B0%E1%84%8B%E1%85%A5%20%E1%84%91%E1%85%B3%E1%84%85%E1%85%A9%E1%84%89%E1%85%A6%E1%84%89%E1%85%B3%2096375d189c39451d93f318a757a7d1a9/image6.png"/></p>
<ul>
<li>위의 그림을 어떻게 이해하면 되냐면</li>
<li>다음의 4단계가 하나의 사이클이라고 보면 된다
<ul>
<li><strong>Inception(도입 단계)</strong> : 프로젝트의 범위를 설정하고 목표를 명확하게 함</li>
<li><strong>Elaboration(정련 단계)</strong> : 시스템의 중요한 요구를 찾아내어 기본이 되는 설계를 완성</li>
<li><strong>Construction(구축 단계)</strong> : 원시코드가 완성되고 중요한 요구의 테스트를 하는 것</li>
<li><strong>Transition(전환 단계)</strong> : 사용자에게 릴리즈</li>
</ul>
</li>
<li>근데 다른 모델들과의 차이점은 Inception 단계라고 해서 계획만 하는 것은 아니라는 거다
<ul>
<li>세로축에 있는 Business Modeling, Requirements, Analysis &amp; Design, Implementation, Test, Deployment의 작업을 각 단계마다 수행하게 되는 것</li>
</ul>
</li>
<li>하지만 각 단계마다 집중하는 비율은 당연히 달라지고 그 비율을 나타낸 것이 위의 그래프인 것
<ul>
<li>보면 Inception단계에서는 Business Modeling과 Requirements의 비중이 높은 것을 알 수 있고</li>
<li>Construction에서는 Implementation의 비율이 높은 것을 알 수 있다</li>
</ul>
</li>
<li>즉, 다른 모델들은 각 단계마다 한가지의 일만을 하는 반면 UP에서는 비중만 달라질 뿐 모든 일을 골고루 처리한다는 차이점이 존재한다</li>
</ul>
<h2 id="agile-model">Agile Model<a aria-hidden="true" tabindex="-1" href="#agile-model" class="internal"> §</a></h2>
<ul>
<li>Agile [형용사] : 빠른, 기민한, 날렵한, 민첩한</li>
</ul>
<h3 id="특징-1">특징<a aria-hidden="true" tabindex="-1" href="#특징-1" class="internal"> §</a></h3>
<ol>
<li>설계가 변경되어도 쉽게 수용이 가능하도록 계획부터 배포까지의 사이클을 짧게 가져가는 것
<ul>
<li><strong>점증적 설계</strong> : 설계를 하되 나중에 충분히 개선될 여지가 있다는 것을 염두해 두고 설계에 대한 결정을 최대한 미루는 것</li>
<li>약 4-5주의 사이클로 계획 ~ 배포가 이루어진다</li>
</ul>
</li>
<li>사용자를 팀에 아예 참여시켜 지속적으로 피드백을 받음</li>
<li>필요한 문서만 최소한으로 작성하고 대부분 소스코드로 대체, 커뮤니케이션도 문서를 통하기보다는 대화를 통해 해결</li>
<li>대규모의 프로젝트의 경우에는 설계가 자주 변경되는 것이 좋지 않으므로 소규모 프로젝트를 진행할때 적합하다
<ul>
<li>소규모의 프로젝트 같은 경우에는 설계가 자주 바뀌어도 품질에 크게 영향을 끼치지 않기 때문</li>
</ul>
</li>
</ol>
<h3 id="과정-3">과정<a aria-hidden="true" tabindex="-1" href="#과정-3" class="internal"> §</a></h3>
<p><img src="../../../../gardens/sw-eng/originals/softwareengineering.fall.2021.cse.cnu.ac.kr/images/01_96375d189c39451d93f318a757a7d1a9/image7.png" alt="%E1%84%8B%E1%85%B5%E1%84%85%E1%85%A9%E1%86%AB02%20-%20%E1%84%89%E1%85%A9%E1%84%91%E1%85%B3%E1%84%90%E1%85%B3%E1%84%8B%E1%85%B0%E1%84%8B%E1%85%A5%20%E1%84%91%E1%85%B3%E1%84%85%E1%85%A9%E1%84%89%E1%85%A6%E1%84%89%E1%85%B3%2096375d189c39451d93f318a757a7d1a9/image7.png"/></p>
<ul>
<li>위처럼 요구사항 수립을 한 후에 지속적으로 개발 &amp; 통합 &amp; 테스트를 이어나가다가</li>
<li>고객에게 피드백을 받고 배포할지말지를 결정</li>
<li>빠꾸먹으면 왜 빠꾸먹었는지 등을 정리해놓고 다시 개발 &amp; 통합 &amp; 테스트 &amp; 피드백</li>
<li>빠꾸 안먹어도 배포 후에 계속 요구사항을 정리해서 개발 &amp; 통합 &amp; 테스트 &amp; 피드백</li>
</ul>
<h3 id="xp--extreme-programming">XP : eXtreme Programming<a aria-hidden="true" tabindex="-1" href="#xp--extreme-programming" class="internal"> §</a></h3>
<ul>
<li>최초의 애자일 프로세스랜다</li>
<li><strong>Metaphor</strong> : 프로젝트에 사용할 아키텍처를 설계하는 것이 아닌 기존의 서비스 중 유사한 것의 아키텍처를 차용함</li>
<li>불필요하게 복잡한부분은 제거해서 설계</li>
<li><strong>TDD</strong>를 중심적으로 개발 프로세스가 돌아감</li>
<li><strong>Refactoring</strong> : 동일한 동작을 하되 더 간결하고 깔끔하게 시스템을 재구성</li>
<li>주당 40시간의 개발속도로 진행</li>
<li>코딩 컨벤션을 정해 동일한 규칙을 적용</li>
</ul>
<h3 id="과정-4">과정<a aria-hidden="true" tabindex="-1" href="#과정-4" class="internal"> §</a></h3>
<p><img src="../../../../gardens/sw-eng/originals/softwareengineering.fall.2021.cse.cnu.ac.kr/images/01_96375d189c39451d93f318a757a7d1a9/image8.png" alt="%E1%84%8B%E1%85%B5%E1%84%85%E1%85%A9%E1%86%AB02%20-%20%E1%84%89%E1%85%A9%E1%84%91%E1%85%B3%E1%84%90%E1%85%B3%E1%84%8B%E1%85%B0%E1%84%8B%E1%85%A5%20%E1%84%91%E1%85%B3%E1%84%85%E1%85%A9%E1%84%89%E1%85%A6%E1%84%89%E1%85%B3%2096375d189c39451d93f318a757a7d1a9/image8.png"/></p>
<ol>
<li><strong>Exploration</strong> : <strong>User story</strong> - 즉, 사용자의 니즈를 잘게 나누고 해당 니즈와 관련된 정보들을 모음.
<ul>
<li><strong>Capture stories in parking lot</strong> - 사무실에 앉아서 니즈를 알아내려고 하지 말고 엉뚱한데를 뒤져보라는 것.</li>
<li><strong>Architectural spikes</strong> : 어떤 user story에 대해 이것을 왜 해결해야 하는지 등의 신뢰성 혹은 기술적인 부분에서 문제가 없는지 등을 확인하기 위해 작성하는 간단한 프로그램</li>
</ul>
</li>
<li><strong>Iteration planning</strong> : 각 user story들에 대해 개발 사이클인 <strong>iteration</strong>이 얼마나 걸릴지를 예상. + 비용도 예상</li>
<li><strong>Iteration</strong> : <strong>Pair programming</strong> : 하나의 컴퓨터를 공유하고 개발과 테스팅을 분리하여 진행 + 지속적으로 개발의 결과를 통합시킴
<ul>
<li>개발 + 테스팅 이후에는 기존의 코드들과 연동이 잘 되는지 <strong>regression test</strong>를 진행함</li>
<li>그리고 iteration의 중간에 mid iteration review, iteration의 끝에 end of iteration review를 진행함</li>
</ul>
</li>
<li><strong>Acceptance tests</strong> : 릴리즈 전에 고객한테 피드백을 받음</li>
<li><strong>Small release</strong> : 고객이 ㅇㅋ하면 소규모의 배포를 진행</li>
</ol>
<h3 id="scrum">Scrum<a aria-hidden="true" tabindex="-1" href="#scrum" class="internal"> §</a></h3>
<h3 id="과정-5">과정<a aria-hidden="true" tabindex="-1" href="#과정-5" class="internal"> §</a></h3>
<p><img src="../../../../gardens/sw-eng/originals/softwareengineering.fall.2021.cse.cnu.ac.kr/images/01_96375d189c39451d93f318a757a7d1a9/image9.png" alt="%E1%84%8B%E1%85%B5%E1%84%85%E1%85%A9%E1%86%AB02%20-%20%E1%84%89%E1%85%A9%E1%84%91%E1%85%B3%E1%84%90%E1%85%B3%E1%84%8B%E1%85%B0%E1%84%8B%E1%85%A5%20%E1%84%91%E1%85%B3%E1%84%85%E1%85%A9%E1%84%89%E1%85%A6%E1%84%89%E1%85%B3%2096375d189c39451d93f318a757a7d1a9/image9.png"/></p>
<ol>
<li><strong>Product backlog</strong> : 고객이나 팀 임원진 등등의 사람들에게 요구사항을 물어봐서 정리함</li>
<li><strong>Sprint planning meeting</strong> : Product backlog 중에 어떤 것들을 이번 <strong>Sprint</strong>(iteration마냥 한 사이클)때 해결할 것인지를 결정함. 그리고 그것들에 대해 시간이 얼마나 걸릴지, 비용은 얼마나 필요할지 등을 산출함</li>
<li><strong>Sprint</strong> : 1주에서 4주정도의 기간 동안 회의때 결정한 내용들을 개발하고 테스트함. <strong>Daily scrum meeting</strong>을 통해 매일 15분 정도 얼마나 진도가 나갔는지, 이슈는 없는지 등을 논의함</li>
<li><strong>Sprint review</strong> : 스프린트 후 산출된 결과에 대해 리뷰함</li>
<li><strong>Sprint Retrospective</strong> : 스프린트 과정에 대해 변경할 부분은 없는지, 문제는 없었는지 등을 회고함</li>
</ol>
<h2 id="프로세스-모델-선정">프로세스 모델 선정<a aria-hidden="true" tabindex="-1" href="#프로세스-모델-선정" class="internal"> §</a></h2>
<ul>
<li>참고해라</li>
</ul>
<p><img src="../../../../gardens/sw-eng/originals/softwareengineering.fall.2021.cse.cnu.ac.kr/images/01_96375d189c39451d93f318a757a7d1a9/image10.png" alt="%E1%84%8B%E1%85%B5%E1%84%85%E1%85%A9%E1%86%AB02%20-%20%E1%84%89%E1%85%A9%E1%84%91%E1%85%B3%E1%84%90%E1%85%B3%E1%84%8B%E1%85%B0%E1%84%8B%E1%85%A5%20%E1%84%91%E1%85%B3%E1%84%85%E1%85%A9%E1%84%89%E1%85%A6%E1%84%89%E1%85%B3%2096375d189c39451d93f318a757a7d1a9/image10.png"/></p>
<h2 id="model과-관계없이-해야되는-작업들">Model과 관계없이 해야되는 작업들<a aria-hidden="true" tabindex="-1" href="#model과-관계없이-해야되는-작업들" class="internal"> §</a></h2>
<h3 id="specification">Specification<a aria-hidden="true" tabindex="-1" href="#specification" class="internal"> §</a></h3>
<ul>
<li><strong>Feasibility study</strong> : 타당성 조사. 비용 대비 이익이 얼마나 되는가, 주어진 시간 내에 우리가 가진 기술력으로 해결이 가능한가 등 - <strong>Feasibility report</strong>의 문서가 나오게 됨</li>
<li><strong>Requirements elicitation and analysis</strong> : 요구사항 도출 및 분석</li>
<li><strong>Specification</strong> : 명세. 문서화</li>
<li><strong>Validation</strong> : 검증 - <strong>Requirement validation</strong>의 문서가 나오게 됨</li>
</ul>
<p><img src="../../../../gardens/sw-eng/originals/softwareengineering.fall.2021.cse.cnu.ac.kr/images/01_96375d189c39451d93f318a757a7d1a9/image11.png" alt="%E1%84%8B%E1%85%B5%E1%84%85%E1%85%A9%E1%86%AB02%20-%20%E1%84%89%E1%85%A9%E1%84%91%E1%85%B3%E1%84%90%E1%85%B3%E1%84%8B%E1%85%B0%E1%84%8B%E1%85%A5%20%E1%84%91%E1%85%B3%E1%84%85%E1%85%A9%E1%84%89%E1%85%A6%E1%84%89%E1%85%B3%2096375d189c39451d93f318a757a7d1a9/image11.png"/></p>
<ul>
<li>뭐 대충 이렇댄다</li>
</ul>
<h3 id="design--implementation">Design &amp; Implementation<a aria-hidden="true" tabindex="-1" href="#design--implementation" class="internal"> §</a></h3>
<ul>
<li>Specification으로 실행가능한 프로그램을 만드는 과정</li>
<li>Design : 설계
<ul>
<li><strong>Architectural design</strong> : 프로그램이 돌아갈 OS등의 아키텍처를 고려해 설계</li>
<li><strong>Interface design</strong> : UI등의 인터페이스를 설계함</li>
<li><strong>Component design</strong> : 프로그램을 구성하는 클래스 등의 구성요소 들을 설계함 (Component는 기능이나 객체 혹은 이들의 그룹을 의미함)</li>
<li><strong>Data structure design</strong> : DB또는 자료구조들을 설계</li>
<li><strong>Algorithm design</strong> : 프로그램이 돌아가는 알고리즘을 설계</li>
</ul>
</li>
</ul>
<p><img src="../../../../gardens/sw-eng/originals/softwareengineering.fall.2021.cse.cnu.ac.kr/images/01_96375d189c39451d93f318a757a7d1a9/image12.png" alt="%E1%84%8B%E1%85%B5%E1%84%85%E1%85%A9%E1%86%AB02%20-%20%E1%84%89%E1%85%A9%E1%84%91%E1%85%B3%E1%84%90%E1%85%B3%E1%84%8B%E1%85%B0%E1%84%8B%E1%85%A5%20%E1%84%91%E1%85%B3%E1%84%85%E1%85%A9%E1%84%89%E1%85%A6%E1%84%89%E1%85%B3%2096375d189c39451d93f318a757a7d1a9/image12.png"/></p>
<ul>
<li>이렇댄다</li>
</ul>
<h3 id="verification--validation-v--v">Verification &amp; Validation (V &amp; V)<a aria-hidden="true" tabindex="-1" href="#verification--validation-v--v" class="internal"> §</a></h3>
<ul>
<li>작성한 프로그램이 명세와 요구사항을 충족하는 것을 보여주기 위한 과정</li>
<li><strong>Component or unit testing</strong> : unit testing을 진행</li>
<li><strong>System testing</strong> : 프로그램 전체 테스트 - 명세에서 유도된 테스트 케이스들을 가지고 시스템 전체를 테스트함</li>
<li><strong>Acceptance testing</strong> : 시스템이 고객의 요구를 충족하는지 확인하기 위해 고객의 데이터를 이용해 테스트</li>
</ul>
<p><img src="../../../../gardens/sw-eng/originals/softwareengineering.fall.2021.cse.cnu.ac.kr/images/01_96375d189c39451d93f318a757a7d1a9/image13.png" alt="%E1%84%8B%E1%85%B5%E1%84%85%E1%85%A9%E1%86%AB02%20-%20%E1%84%89%E1%85%A9%E1%84%91%E1%85%B3%E1%84%90%E1%85%B3%E1%84%8B%E1%85%B0%E1%84%8B%E1%85%A5%20%E1%84%91%E1%85%B3%E1%84%85%E1%85%A9%E1%84%89%E1%85%A6%E1%84%89%E1%85%B3%2096375d189c39451d93f318a757a7d1a9/image13.png"/></p>
<ul>
<li>이건 좀 잘 봐야됨
<ul>
<li>일단 위엣줄이 Specification과 Design을 진행하는 과정임</li>
<li>그리고 이 Spec과 design을 가지고 개발을 진행함(맨 오른쪽)</li>
<li>맨 아랫줄이 Specification과 Design을 진행하는 과정에서 산출된 테스트를 가지고 테스트를 진행하는 과정이다</li>
<li>위 그림만 보면 >이지만 어쨋든 V형태를 띈다고 해서 <strong>V-Model</strong>이라고 부르더라</li>
</ul>
</li>
</ul>
<h3 id="evolution">Evolution<a aria-hidden="true" tabindex="-1" href="#evolution" class="internal"> §</a></h3>
<p><img src="../../../../gardens/sw-eng/originals/softwareengineering.fall.2021.cse.cnu.ac.kr/images/01_96375d189c39451d93f318a757a7d1a9/image14.png" alt="%E1%84%8B%E1%85%B5%E1%84%85%E1%85%A9%E1%86%AB02%20-%20%E1%84%89%E1%85%A9%E1%84%91%E1%85%B3%E1%84%90%E1%85%B3%E1%84%8B%E1%85%B0%E1%84%8B%E1%85%A5%20%E1%84%91%E1%85%B3%E1%84%85%E1%85%A9%E1%84%89%E1%85%A6%E1%84%89%E1%85%B3%2096375d189c39451d93f318a757a7d1a9/image14.png"/></p>
<ul>
<li>유지보수 과정이라 생각하면 될듯</li>
</ul></article></div><div class="right sidebar"><div class="graph "><h3>Graph View</h3><div class="graph-outer"><div id="graph-container" data-cfg="{&quot;drag&quot;:true,&quot;zoom&quot;:true,&quot;depth&quot;:1,&quot;scale&quot;:1.1,&quot;repelForce&quot;:0.5,&quot;centerForce&quot;:0.3,&quot;linkDistance&quot;:30,&quot;fontSize&quot;:0.6,&quot;opacityScale&quot;:1,&quot;showTags&quot;:true,&quot;removeTags&quot;:[]}"></div><svg version="1.1" id="global-graph-icon" xmlns="http://www.w3.org/2000/svg" xmlnsXlink="http://www.w3.org/1999/xlink" x="0px" y="0px" viewBox="0 0 55 55" fill="currentColor" xmlSpace="preserve"><path d="M49,0c-3.309,0-6,2.691-6,6c0,1.035,0.263,2.009,0.726,2.86l-9.829,9.829C32.542,17.634,30.846,17,29,17
	s-3.542,0.634-4.898,1.688l-7.669-7.669C16.785,10.424,17,9.74,17,9c0-2.206-1.794-4-4-4S9,6.794,9,9s1.794,4,4,4
	c0.74,0,1.424-0.215,2.019-0.567l7.669,7.669C21.634,21.458,21,23.154,21,25s0.634,3.542,1.688,4.897L10.024,42.562
	C8.958,41.595,7.549,41,6,41c-3.309,0-6,2.691-6,6s2.691,6,6,6s6-2.691,6-6c0-1.035-0.263-2.009-0.726-2.86l12.829-12.829
	c1.106,0.86,2.44,1.436,3.898,1.619v10.16c-2.833,0.478-5,2.942-5,5.91c0,3.309,2.691,6,6,6s6-2.691,6-6c0-2.967-2.167-5.431-5-5.91
	v-10.16c1.458-0.183,2.792-0.759,3.898-1.619l7.669,7.669C41.215,39.576,41,40.26,41,41c0,2.206,1.794,4,4,4s4-1.794,4-4
	s-1.794-4-4-4c-0.74,0-1.424,0.215-2.019,0.567l-7.669-7.669C36.366,28.542,37,26.846,37,25s-0.634-3.542-1.688-4.897l9.665-9.665
	C46.042,11.405,47.451,12,49,12c3.309,0,6-2.691,6-6S52.309,0,49,0z M11,9c0-1.103,0.897-2,2-2s2,0.897,2,2s-0.897,2-2,2
	S11,10.103,11,9z M6,51c-2.206,0-4-1.794-4-4s1.794-4,4-4s4,1.794,4,4S8.206,51,6,51z M33,49c0,2.206-1.794,4-4,4s-4-1.794-4-4
	s1.794-4,4-4S33,46.794,33,49z M29,31c-3.309,0-6-2.691-6-6s2.691-6,6-6s6,2.691,6,6S32.309,31,29,31z M47,41c0,1.103-0.897,2-2,2
	s-2-0.897-2-2s0.897-2,2-2S47,39.897,47,41z M49,10c-2.206,0-4-1.794-4-4s1.794-4,4-4s4,1.794,4,4S51.206,10,49,10z"></path></svg></div><div id="global-graph-outer"><div id="global-graph-container" data-cfg="{&quot;drag&quot;:true,&quot;zoom&quot;:true,&quot;depth&quot;:-1,&quot;scale&quot;:0.9,&quot;repelForce&quot;:0.5,&quot;centerForce&quot;:0.3,&quot;linkDistance&quot;:30,&quot;fontSize&quot;:0.6,&quot;opacityScale&quot;:1,&quot;showTags&quot;:true,&quot;removeTags&quot;:[]}"></div></div></div><div class="toc desktop-only"><button type="button" id="toc"><h3>Table of Contents</h3><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="fold"><polyline points="6 9 12 15 18 9"></polyline></svg></button><div id="toc-content"><ul class="overflow"><li class="depth-0"><a href="#소프트웨어-개발-프로세스란" data-for="소프트웨어-개발-프로세스란">소프트웨어 개발 프로세스란</a></li><li class="depth-1"><a href="#즉흥적인-개발-프로세스의-문제점" data-for="즉흥적인-개발-프로세스의-문제점">즉흥적인 개발 프로세스의 문제점</a></li><li class="depth-0"><a href="#waterfall-model-phased-model" data-for="waterfall-model-phased-model">Waterfall Model (Phased Model)</a></li><li class="depth-1"><a href="#과정" data-for="과정">과정</a></li><li class="depth-1"><a href="#특징" data-for="특징">특징</a></li><li class="depth-1"><a href="#장점" data-for="장점">장점</a></li><li class="depth-1"><a href="#단점" data-for="단점">단점</a></li><li class="depth-0"><a href="#prototype-model" data-for="prototype-model">Prototype Model</a></li><li class="depth-1"><a href="#프로토타입의-종류" data-for="프로토타입의-종류">프로토타입의 종류</a></li><li class="depth-1"><a href="#과정-1" data-for="과정-1">과정</a></li><li class="depth-0"><a href="#incremental-model" data-for="incremental-model">Incremental Model</a></li><li class="depth-1"><a href="#과정-2" data-for="과정-2">과정</a></li><li class="depth-1"><a href="#배포-구성-방법" data-for="배포-구성-방법">배포 구성 방법</a></li><li class="depth-1"><a href="#장점-1" data-for="장점-1">장점</a></li><li class="depth-0"><a href="#spiral-model" data-for="spiral-model">Spiral Model</a></li><li class="depth-1"><a href="#장점-2" data-for="장점-2">장점</a></li><li class="depth-1"><a href="#단점-1" data-for="단점-1">단점</a></li><li class="depth-0"><a href="#evolutionary-model" data-for="evolutionary-model">Evolutionary Model</a></li><li class="depth-1"><a href="#up-unified-process" data-for="up-unified-process">UP (Unified Process)</a></li><li class="depth-0"><a href="#agile-model" data-for="agile-model">Agile Model</a></li><li class="depth-1"><a href="#특징-1" data-for="특징-1">특징</a></li><li class="depth-1"><a href="#과정-3" data-for="과정-3">과정</a></li><li class="depth-1"><a href="#xp--extreme-programming" data-for="xp--extreme-programming">XP : eXtreme Programming</a></li><li class="depth-1"><a href="#과정-4" data-for="과정-4">과정</a></li><li class="depth-1"><a href="#scrum" data-for="scrum">Scrum</a></li><li class="depth-1"><a href="#과정-5" data-for="과정-5">과정</a></li><li class="depth-0"><a href="#프로세스-모델-선정" data-for="프로세스-모델-선정">프로세스 모델 선정</a></li><li class="depth-0"><a href="#model과-관계없이-해야되는-작업들" data-for="model과-관계없이-해야되는-작업들">Model과 관계없이 해야되는 작업들</a></li><li class="depth-1"><a href="#specification" data-for="specification">Specification</a></li><li class="depth-1"><a href="#design--implementation" data-for="design--implementation">Design &amp; Implementation</a></li><li class="depth-1"><a href="#verification--validation-v--v" data-for="verification--validation-v--v">Verification &amp; Validation (V &amp; V)</a></li><li class="depth-1"><a href="#evolution" data-for="evolution">Evolution</a></li></ul></div></div><div class="backlinks "><h3>Backlinks</h3><ul class="overflow"><li><a href="../../../../gardens/sw-eng/originals/softwareengineering.fall.2021.cse.cnu.ac.kr/(충남대)-소프트웨어-공학-강의록" class="internal">(충남대) 소프트웨어 공학 강의록</a></li></ul></div></div></div><footer class><hr/><p>Created with <a href="https://quartz.jzhao.xyz/">Quartz v4.1.0</a>, © 2024</p><ul><li><a href="https://github.com/haeramkeem">GitHub</a></li><li><a href="www.linkedin.com/in/haeram-kim-277404220">LinkedIn</a></li><li><a href="mailto:haeram.kim1@gmail.com">Email</a></li></ul></footer></div></body><script type="application/javascript">// quartz/components/scripts/quartz/components/scripts/callout.inline.ts
function toggleCallout() {
  const outerBlock = this.parentElement;
  outerBlock.classList.toggle(`is-collapsed`);
  const collapsed = outerBlock.classList.contains(`is-collapsed`);
  const height = collapsed ? this.scrollHeight : outerBlock.scrollHeight;
  outerBlock.style.maxHeight = height + `px`;
  let current = outerBlock;
  let parent = outerBlock.parentElement;
  while (parent) {
    if (!parent.classList.contains(`callout`)) {
      return;
    }
    const collapsed2 = parent.classList.contains(`is-collapsed`);
    const height2 = collapsed2 ? parent.scrollHeight : parent.scrollHeight + current.scrollHeight;
    parent.style.maxHeight = height2 + `px`;
    current = parent;
    parent = parent.parentElement;
  }
}
function setupCallout() {
  const collapsible = document.getElementsByClassName(
    `callout is-collapsible`
  );
  for (const div of collapsible) {
    const title = div.firstElementChild;
    if (title) {
      title.removeEventListener(`click`, toggleCallout);
      title.addEventListener(`click`, toggleCallout);
      const collapsed = div.classList.contains(`is-collapsed`);
      const height = collapsed ? title.scrollHeight : div.scrollHeight;
      div.style.maxHeight = height + `px`;
    }
  }
}
document.addEventListener(`nav`, setupCallout);
window.addEventListener(`resize`, setupCallout);
</script><script type="module">
          import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.esm.min.mjs';
          const darkMode = document.documentElement.getAttribute('saved-theme') === 'dark'
          mermaid.initialize({
            startOnLoad: false,
            securityLevel: 'loose',
            theme: darkMode ? 'dark' : 'default'
          });
          document.addEventListener('nav', async () => {
            await mermaid.run({
              querySelector: '.mermaid'
            })
          });
          </script><script src="https://cdn.jsdelivr.net/npm/katex@0.16.7/dist/contrib/copy-tex.min.js" type="application/javascript"></script><script src="https://www.googletagmanager.com/gtag/js?id=G-N68CCP1QHG" type="application/javascript"></script><script src="../../../../postscript.js" type="module"></script></html>