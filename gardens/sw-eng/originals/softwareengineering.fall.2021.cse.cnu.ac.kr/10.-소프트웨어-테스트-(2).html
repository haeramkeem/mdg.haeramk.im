<!DOCTYPE html>
<html><head><title>10. 소프트웨어 테스트 (2)</title><meta charSet="utf-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:title" content="10. 소프트웨어 테스트 (2)"/><meta property="og:description" content="충남대학교 컴퓨터공학과 김현수 교수님의 &amp;quot;소프트웨어 공학&amp;quot; 강의를 필기한 내용입니다. 다소 잘못된 내용과 구어적 표현 이 포함되어 있을 수 있습니다. Whitebox Testing § Blackbox Testing와는 반대로 내부 논리구조를 테스트하는 방법이다 컴포넌트 레벨에서는 구문, 결정, 분기 등을 테스트 하고 모듈 레벨에서는 모듈간 호출관계 트리(Call Tree), 시스템 레벨에서는 메뉴, 프로세스 구조, GUI측면에서 테스트를 진행하게 된다 그리고 Whitebox Testing에서는 Converage라는 개념이 등장하는데 테스트 케이스 집합(Test Suite)으로 시스템 구조가 테스트된 정도를 말한다 뒤에서 계속 보겠지만 Coverage는 구문 테스팅을 할때는 코드의 어디어디가 실행되었나로 판단하게 되고 뭐 결정 Testing 을 할때는 어떤 분기나 경우의 수가 실행되었나로 판단하는 등 각각의 Test방법에 따라 Coverage를 구하는 방법은 달라진다 Coverage 목표치를 정해놓고 해당 Coverage에 도달할때까지 Test Suite에 테스트케이스를 추가하며 테스트를 진행하게 되고 이렇게 함으로써 여러 경우에 수에 대한 테스트를 좀 더 체계적으로 진행할 수 있게 된다 Statement Testing &amp;amp; Coverage § 말 그대로 어느 Statement가 실행되었고 어느 Statement가 실행되지 않았는지를 판단해 Coverage를 구하며 Test Suite를 조정하는 방법 얘는 Basic Block을 Statement 한줄로 하는 Control Flow Graph를 그리고 Test Suite의 테스트케이스를 진행하며 어느정도 Coverage가 나오는지 확인하는 방법이라고 생각하면 된다 컴파일러 강의를 제대로 들었고 위의 문장이 이해되면 위의 예시또한 어렵지 않게 이해할 수 있음 제일 왼쪽이 코드고 그 다음이 해당 코드의 Statement로 그린 CFG, 그리고 오른쪽이 해당 TS로 알아낸 Coverage이다 하는 방법은 TS의 테케를 돌리고 어디어디가 커버됐는지 확인한 뒤 Coverage를 구하면 되는데 이때 중요한건 total stmt에서 unreachable stmt의 갯수를 빼줘야 된다는 거다 - unreachable stmt를 빼지 않으면 절대로 100퍼가 나오지 않으므로 - 따라서 unreachable stmt를 coverage를 구하기 전에 반드시 구해줘야 한다 Decision Testing &amp;amp; Coverage § 여기서의 Coverage는 하나의 분기문에 대해 참과 거짓으로 모두 분기했을때 Decision Coverage가 1이라고 본다 뒤에서 나올 Condition Coverage와는 다르게 Decision Coverage는 분기문의 조건식 전체에 대해 결과가 참이냐 거짓이냐로 Coverage를 계산한다는 점을 주의할 것 즉, 말그대로 Decision이기 때문에 양쪽의 분기방향에 대해서만 생각하게 되는거다 예시를 보면 당연히 저 if문이 Decision Point가 되고 예시로 주어진 TS을 실행해보면 F와 T가 골고루 나왔으므로 covered decision이 1인데 Decision의 총 갯수도 1개이기 때문에 100%의 Coverage가 나오게 되는 것 여기서는 if문이 하나밖에 없어서 Decision 의 갯수가 1개인거지만 if문이 여러개인 놈을 테스트할때는 Total Decision 값이 n인 것에 주의하셈 Condition Testing &amp;amp; Coverage § 여기서는 Decision Testing과는 다르게 Decision Point의 Condition Expression 각각에 대해 참과 거짓이 모두 나와야 해당 condition이 cover된것으로 판단한다 예시를 보면 Decision Point에 Condition Expression이 두개 있으므로 쟤네 각각에 대해 TF가 골고루 나와야 각각이 cover된 것으로 판단하게 됨 예제로 주어진 TS를 해보면 위 표에서 보는것처럼 x &amp;gt;= -2가 TF가 나오므로 이게 cover가 되고 y &amp;lt; 4도 TF가 골고루 나와 cover가 된다 따라서 total condition의 갯수가 2이고 covered condition도 2이므로 100%의 Condition Coverage가 나오게 된다 Multiple Condition Coverage § 애는 Condition 각각이 TF가 나오는 경우에서 더 나아가 Condition들이 만들어낼 수 있는 모든 TF조합으로 판단하는 거다 예를들어 if(c1 BOOLOP c2)의 경우에 TT, TF, FT, FF 4개의 조합이 만들어지고 이 조합을 모두 충족해야 해당 Decision이 cover된 것으로 판단한다 따라서 Boolean Operation으로 연결된 Condition Expression이 n개 존재한다면 가능한 조합은 2^n이 되고 이것은 엄청나게 많은 수의 테케를 필요로 하므로 반드시 결함이 없어야되는 경우가 아니라면 진행하지 않는다 Testing들 간의 포함관계 § 뭔가 Condition Testing이 더 자세하기 때문에 이걸 만족하면 Decision Testing도 통과할거같지만 Condition Testing과 Decision Testing은 포함관계가 아니고 하나가 통과해도 나머지 하나가 실패하는 경우가 있기 때문에 두개를 반드시 수행해줘야 한다 위 표를 보면 모든 Test Case들에 대해 Condition Testing의 결과와 Decision Testing의 결과가 적혀있는데 T1을 보면 Condition Testing는 TF가 골고루 나와 통과하지만 Decision Testing 에서는 FF가 나와 통과하지 못하게 되는 것을 볼 수 있음 T2는 반대로 Decision Testing은 TF가 나와 통과하지만 Condition Testing에서는 두번째 테케가 TT가 나와 실패한다 따라서 T1와 T2를 합집합한 T3을 돌려야 Decision Testing과 Condition Testing을 모두 통과하게 되는 것 따라서 위와 같은 포함관계가 나오게 된다 개발 단계를 기준으로 한 테스트 분류 § Unit Test : 모듈 하나에 대한 테스트 주로 White Box Test를 진행한다 Integration Test : 전역변수 이슈나 인터페이스 결함 등의 모듈간 통합 과정에서 일어날 수 있는 결함을 체크한다 그냥 모듈들을 다 합치고 한꺼번에 테스트하는 것을 Bing-Bang Test라고 하는데 저건 너무 무식하니까 모듈들을 붙여가며 서브시스템을 테스트하고 서브시스템도 붙여가며 테스트하는 Incremental Testing을 진행한다 이건 수평적으로 붙이면서 진행할때도 있고 수직적으로 붙이면서 수행할 때도 있음 Top-down Testing은 UI에서 DB까지의 순서대로 내려가며 합치는 방법을 의미하고 이때 하위 시스템에 대해서는 사용하지 못하기 때문에 Test Stub을 이용해 하위 시스템에 대한 mock을 사용하여 테스트한다 Bottom-up Testing은 DB에서 UI까지 올라가며 합치는 방법이고 이때 상위 시스템에 대한 mock으로 Test Driver를 이용한다 그리고 이 둘을 섞은 Sandwich Testing이 있음 - 얘는 UI를 테스트하고 DB를 테스트한 뒤 가운데를 테스트하는 방법이다 - 이때에도 하위나 상위 시스템에 대한 mock으로 Test Driver나 Test Stub을 사용한다 System Test : 요구사항 명세를 기준으로 기능적, 비기능적(비기능 요구사항에 있었던 뭐 성능이나 이런것들) 테스트를 진행함 Acceptance Testing : 실제 사용자들을 참여시켜 사용자의 요구대로 돌아가는지 확인함 Alpha Test : 개발팀의 감독 하에 고객이 수행하는 테스트 Beta Test : 임의의 사용자가 개발팀과는 무관한 환경에서 테스트하게 해볼 목적으로 사용자들이 직접 테스팅하고 문제점을 report하는 형태 Open Beta Release로 일반인에게 임시 배포를 해 테스팅 하는 방법이 해당한다 테스터에 따른 분류 § Developer Test : 개발자나 연관된 테스팅 그룹에 의해 수행되는 테스트 Independent Test : 무관한 제 3자에 의해 테스트하는 것 ."/><meta property="og:image" content="https://mdg.haeramk.im/static/og-image.png"/><meta property="og:width" content="1200"/><meta property="og:height" content="675"/><link rel="icon" href="../../../../static/icon.png"/><meta name="description" content="충남대학교 컴퓨터공학과 김현수 교수님의 &amp;quot;소프트웨어 공학&amp;quot; 강의를 필기한 내용입니다. 다소 잘못된 내용과 구어적 표현 이 포함되어 있을 수 있습니다. Whitebox Testing § Blackbox Testing와는 반대로 내부 논리구조를 테스트하는 방법이다 컴포넌트 레벨에서는 구문, 결정, 분기 등을 테스트 하고 모듈 레벨에서는 모듈간 호출관계 트리(Call Tree), 시스템 레벨에서는 메뉴, 프로세스 구조, GUI측면에서 테스트를 진행하게 된다 그리고 Whitebox Testing에서는 Converage라는 개념이 등장하는데 테스트 케이스 집합(Test Suite)으로 시스템 구조가 테스트된 정도를 말한다 뒤에서 계속 보겠지만 Coverage는 구문 테스팅을 할때는 코드의 어디어디가 실행되었나로 판단하게 되고 뭐 결정 Testing 을 할때는 어떤 분기나 경우의 수가 실행되었나로 판단하는 등 각각의 Test방법에 따라 Coverage를 구하는 방법은 달라진다 Coverage 목표치를 정해놓고 해당 Coverage에 도달할때까지 Test Suite에 테스트케이스를 추가하며 테스트를 진행하게 되고 이렇게 함으로써 여러 경우에 수에 대한 테스트를 좀 더 체계적으로 진행할 수 있게 된다 Statement Testing &amp;amp; Coverage § 말 그대로 어느 Statement가 실행되었고 어느 Statement가 실행되지 않았는지를 판단해 Coverage를 구하며 Test Suite를 조정하는 방법 얘는 Basic Block을 Statement 한줄로 하는 Control Flow Graph를 그리고 Test Suite의 테스트케이스를 진행하며 어느정도 Coverage가 나오는지 확인하는 방법이라고 생각하면 된다 컴파일러 강의를 제대로 들었고 위의 문장이 이해되면 위의 예시또한 어렵지 않게 이해할 수 있음 제일 왼쪽이 코드고 그 다음이 해당 코드의 Statement로 그린 CFG, 그리고 오른쪽이 해당 TS로 알아낸 Coverage이다 하는 방법은 TS의 테케를 돌리고 어디어디가 커버됐는지 확인한 뒤 Coverage를 구하면 되는데 이때 중요한건 total stmt에서 unreachable stmt의 갯수를 빼줘야 된다는 거다 - unreachable stmt를 빼지 않으면 절대로 100퍼가 나오지 않으므로 - 따라서 unreachable stmt를 coverage를 구하기 전에 반드시 구해줘야 한다 Decision Testing &amp;amp; Coverage § 여기서의 Coverage는 하나의 분기문에 대해 참과 거짓으로 모두 분기했을때 Decision Coverage가 1이라고 본다 뒤에서 나올 Condition Coverage와는 다르게 Decision Coverage는 분기문의 조건식 전체에 대해 결과가 참이냐 거짓이냐로 Coverage를 계산한다는 점을 주의할 것 즉, 말그대로 Decision이기 때문에 양쪽의 분기방향에 대해서만 생각하게 되는거다 예시를 보면 당연히 저 if문이 Decision Point가 되고 예시로 주어진 TS을 실행해보면 F와 T가 골고루 나왔으므로 covered decision이 1인데 Decision의 총 갯수도 1개이기 때문에 100%의 Coverage가 나오게 되는 것 여기서는 if문이 하나밖에 없어서 Decision 의 갯수가 1개인거지만 if문이 여러개인 놈을 테스트할때는 Total Decision 값이 n인 것에 주의하셈 Condition Testing &amp;amp; Coverage § 여기서는 Decision Testing과는 다르게 Decision Point의 Condition Expression 각각에 대해 참과 거짓이 모두 나와야 해당 condition이 cover된것으로 판단한다 예시를 보면 Decision Point에 Condition Expression이 두개 있으므로 쟤네 각각에 대해 TF가 골고루 나와야 각각이 cover된 것으로 판단하게 됨 예제로 주어진 TS를 해보면 위 표에서 보는것처럼 x &amp;gt;= -2가 TF가 나오므로 이게 cover가 되고 y &amp;lt; 4도 TF가 골고루 나와 cover가 된다 따라서 total condition의 갯수가 2이고 covered condition도 2이므로 100%의 Condition Coverage가 나오게 된다 Multiple Condition Coverage § 애는 Condition 각각이 TF가 나오는 경우에서 더 나아가 Condition들이 만들어낼 수 있는 모든 TF조합으로 판단하는 거다 예를들어 if(c1 BOOLOP c2)의 경우에 TT, TF, FT, FF 4개의 조합이 만들어지고 이 조합을 모두 충족해야 해당 Decision이 cover된 것으로 판단한다 따라서 Boolean Operation으로 연결된 Condition Expression이 n개 존재한다면 가능한 조합은 2^n이 되고 이것은 엄청나게 많은 수의 테케를 필요로 하므로 반드시 결함이 없어야되는 경우가 아니라면 진행하지 않는다 Testing들 간의 포함관계 § 뭔가 Condition Testing이 더 자세하기 때문에 이걸 만족하면 Decision Testing도 통과할거같지만 Condition Testing과 Decision Testing은 포함관계가 아니고 하나가 통과해도 나머지 하나가 실패하는 경우가 있기 때문에 두개를 반드시 수행해줘야 한다 위 표를 보면 모든 Test Case들에 대해 Condition Testing의 결과와 Decision Testing의 결과가 적혀있는데 T1을 보면 Condition Testing는 TF가 골고루 나와 통과하지만 Decision Testing 에서는 FF가 나와 통과하지 못하게 되는 것을 볼 수 있음 T2는 반대로 Decision Testing은 TF가 나와 통과하지만 Condition Testing에서는 두번째 테케가 TT가 나와 실패한다 따라서 T1와 T2를 합집합한 T3을 돌려야 Decision Testing과 Condition Testing을 모두 통과하게 되는 것 따라서 위와 같은 포함관계가 나오게 된다 개발 단계를 기준으로 한 테스트 분류 § Unit Test : 모듈 하나에 대한 테스트 주로 White Box Test를 진행한다 Integration Test : 전역변수 이슈나 인터페이스 결함 등의 모듈간 통합 과정에서 일어날 수 있는 결함을 체크한다 그냥 모듈들을 다 합치고 한꺼번에 테스트하는 것을 Bing-Bang Test라고 하는데 저건 너무 무식하니까 모듈들을 붙여가며 서브시스템을 테스트하고 서브시스템도 붙여가며 테스트하는 Incremental Testing을 진행한다 이건 수평적으로 붙이면서 진행할때도 있고 수직적으로 붙이면서 수행할 때도 있음 Top-down Testing은 UI에서 DB까지의 순서대로 내려가며 합치는 방법을 의미하고 이때 하위 시스템에 대해서는 사용하지 못하기 때문에 Test Stub을 이용해 하위 시스템에 대한 mock을 사용하여 테스트한다 Bottom-up Testing은 DB에서 UI까지 올라가며 합치는 방법이고 이때 상위 시스템에 대한 mock으로 Test Driver를 이용한다 그리고 이 둘을 섞은 Sandwich Testing이 있음 - 얘는 UI를 테스트하고 DB를 테스트한 뒤 가운데를 테스트하는 방법이다 - 이때에도 하위나 상위 시스템에 대한 mock으로 Test Driver나 Test Stub을 사용한다 System Test : 요구사항 명세를 기준으로 기능적, 비기능적(비기능 요구사항에 있었던 뭐 성능이나 이런것들) 테스트를 진행함 Acceptance Testing : 실제 사용자들을 참여시켜 사용자의 요구대로 돌아가는지 확인함 Alpha Test : 개발팀의 감독 하에 고객이 수행하는 테스트 Beta Test : 임의의 사용자가 개발팀과는 무관한 환경에서 테스트하게 해볼 목적으로 사용자들이 직접 테스팅하고 문제점을 report하는 형태 Open Beta Release로 일반인에게 임시 배포를 해 테스팅 하는 방법이 해당한다 테스터에 따른 분류 § Developer Test : 개발자나 연관된 테스팅 그룹에 의해 수행되는 테스트 Independent Test : 무관한 제 3자에 의해 테스트하는 것 ."/><meta name="generator" content="Quartz"/><link rel="preconnect" href="https://fonts.googleapis.com"/><link rel="preconnect" href="https://fonts.gstatic.com"/><link href="../../../../index.css" rel="stylesheet" type="text/css" spa-preserve/><link href="https://cdn.jsdelivr.net/npm/katex@0.16.0/dist/katex.min.css" rel="stylesheet" type="text/css" spa-preserve/><link href="https://fonts.googleapis.com/css2?family=IBM Plex Mono&amp;family=Gowun Batang:wght@400;700&amp;family=Gowun Dodum:ital,wght@0,400;0,600;1,400;1,600&amp;display=swap" rel="stylesheet" type="text/css" spa-preserve/><script src="../../../../prescript.js" type="application/javascript" spa-preserve></script><script type="application/javascript" spa-preserve>const fetchData = fetch(`../../../../static/contentIndex.json`).then(data => data.json())</script></head><body data-slug="gardens/sw-eng/originals/softwareengineering.fall.2021.cse.cnu.ac.kr/10.-소프트웨어-테스트-(2)"><div id="quartz-root" class="page"><div id="quartz-body"><div class="left sidebar"><h1 class="page-title "><a href="../../../..">Madison Digital Garden</a></h1><div class="spacer mobile-only"></div><div class="search "><div id="search-icon"><p>Search</p><div></div><svg tabIndex="0" aria-labelledby="title desc" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 19.9 19.7"><title id="title">Search</title><desc id="desc">Search</desc><g class="search-path" fill="none"><path stroke-linecap="square" d="M18.5 18.3l-5.4-5.4"></path><circle cx="8" cy="8" r="7"></circle></g></svg></div><div id="search-container"><div id="search-space"><input autocomplete="off" id="search-bar" name="search" type="text" aria-label="Search for something" placeholder="Search for something"/><div id="results-container"></div></div></div></div><div class="darkmode "><input class="toggle" id="darkmode-toggle" type="checkbox" tabIndex="-1"/><label id="toggle-label-light" for="darkmode-toggle" tabIndex="-1"><svg xmlns="http://www.w3.org/2000/svg" xmlnsXlink="http://www.w3.org/1999/xlink" version="1.1" id="dayIcon" x="0px" y="0px" viewBox="0 0 35 35" style="enable-background:new 0 0 35 35;" xmlSpace="preserve"><title>Light mode</title><path d="M6,17.5C6,16.672,5.328,16,4.5,16h-3C0.672,16,0,16.672,0,17.5    S0.672,19,1.5,19h3C5.328,19,6,18.328,6,17.5z M7.5,26c-0.414,0-0.789,0.168-1.061,0.439l-2,2C4.168,28.711,4,29.086,4,29.5    C4,30.328,4.671,31,5.5,31c0.414,0,0.789-0.168,1.06-0.44l2-2C8.832,28.289,9,27.914,9,27.5C9,26.672,8.329,26,7.5,26z M17.5,6    C18.329,6,19,5.328,19,4.5v-3C19,0.672,18.329,0,17.5,0S16,0.672,16,1.5v3C16,5.328,16.671,6,17.5,6z M27.5,9    c0.414,0,0.789-0.168,1.06-0.439l2-2C30.832,6.289,31,5.914,31,5.5C31,4.672,30.329,4,29.5,4c-0.414,0-0.789,0.168-1.061,0.44    l-2,2C26.168,6.711,26,7.086,26,7.5C26,8.328,26.671,9,27.5,9z M6.439,8.561C6.711,8.832,7.086,9,7.5,9C8.328,9,9,8.328,9,7.5    c0-0.414-0.168-0.789-0.439-1.061l-2-2C6.289,4.168,5.914,4,5.5,4C4.672,4,4,4.672,4,5.5c0,0.414,0.168,0.789,0.439,1.06    L6.439,8.561z M33.5,16h-3c-0.828,0-1.5,0.672-1.5,1.5s0.672,1.5,1.5,1.5h3c0.828,0,1.5-0.672,1.5-1.5S34.328,16,33.5,16z     M28.561,26.439C28.289,26.168,27.914,26,27.5,26c-0.828,0-1.5,0.672-1.5,1.5c0,0.414,0.168,0.789,0.439,1.06l2,2    C28.711,30.832,29.086,31,29.5,31c0.828,0,1.5-0.672,1.5-1.5c0-0.414-0.168-0.789-0.439-1.061L28.561,26.439z M17.5,29    c-0.829,0-1.5,0.672-1.5,1.5v3c0,0.828,0.671,1.5,1.5,1.5s1.5-0.672,1.5-1.5v-3C19,29.672,18.329,29,17.5,29z M17.5,7    C11.71,7,7,11.71,7,17.5S11.71,28,17.5,28S28,23.29,28,17.5S23.29,7,17.5,7z M17.5,25c-4.136,0-7.5-3.364-7.5-7.5    c0-4.136,3.364-7.5,7.5-7.5c4.136,0,7.5,3.364,7.5,7.5C25,21.636,21.636,25,17.5,25z"></path></svg></label><label id="toggle-label-dark" for="darkmode-toggle" tabIndex="-1"><svg xmlns="http://www.w3.org/2000/svg" xmlnsXlink="http://www.w3.org/1999/xlink" version="1.1" id="nightIcon" x="0px" y="0px" viewBox="0 0 100 100" style="enable-background='new 0 0 100 100'" xmlSpace="preserve"><title>Dark mode</title><path d="M96.76,66.458c-0.853-0.852-2.15-1.064-3.23-0.534c-6.063,2.991-12.858,4.571-19.655,4.571  C62.022,70.495,50.88,65.88,42.5,57.5C29.043,44.043,25.658,23.536,34.076,6.47c0.532-1.08,0.318-2.379-0.534-3.23  c-0.851-0.852-2.15-1.064-3.23-0.534c-4.918,2.427-9.375,5.619-13.246,9.491c-9.447,9.447-14.65,22.008-14.65,35.369  c0,13.36,5.203,25.921,14.65,35.368s22.008,14.65,35.368,14.65c13.361,0,25.921-5.203,35.369-14.65  c3.872-3.871,7.064-8.328,9.491-13.246C97.826,68.608,97.611,67.309,96.76,66.458z"></path></svg></label></div></div><div class="center"><div class="page-header"><div class="popover-hint"><h1 class="article-title ">10. 소프트웨어 테스트 (2)</h1><p class="content-meta ">Jul 29, 2024, 11 min read</p></div></div><article class="popover-hint"><blockquote class="callout" data-callout="info">
<div class="callout-title">
                  <div class="callout-icon"><svg xmlns="http://www.w3.org/2000/svg" width="100%" height="100%" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="10"></circle><line x1="12" y1="16" x2="12" y2="12"></line><line x1="12" y1="8" x2="12.01" y2="8"></line></svg></div>
                  <div class="callout-title-inner"><p>충남대학교 컴퓨터공학과 김현수 교수님의 &quot;소프트웨어 공학&quot; 강의를 필기한 내용입니다. </p></div>
                  
                </div>
</blockquote>
<blockquote class="callout" data-callout="warning">
<div class="callout-title">
                  <div class="callout-icon"><svg xmlns="http://www.w3.org/2000/svg" width="100%" height="100%" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="m21.73 18-8-14a2 2 0 0 0-3.48 0l-8 14A2 2 0 0 0 4 21h16a2 2 0 0 0 1.73-3Z"></path><line x1="12" y1="9" x2="12" y2="13"></line><line x1="12" y1="17" x2="12.01" y2="17"></line></svg></div>
                  <div class="callout-title-inner"><p>다소 잘못된 내용과 구어적 표현 이 포함되어 있을 수 있습니다. </p></div>
                  
                </div>
</blockquote>
<h2 id="whitebox-testing">Whitebox Testing<a aria-hidden="true" tabindex="-1" href="#whitebox-testing" class="internal"> §</a></h2>
<ul>
<li>Blackbox Testing와는 반대로 내부 논리구조를 테스트하는 방법이다</li>
<li>컴포넌트 레벨에서는 구문, 결정, 분기 등을 테스트 하고 모듈 레벨에서는 모듈간 호출관계 트리(Call Tree), 시스템 레벨에서는 메뉴, 프로세스 구조, GUI측면에서 테스트를 진행하게 된다</li>
<li>그리고 Whitebox Testing에서는 <strong>Converage</strong>라는 개념이 등장하는데
<ul>
<li>테스트 케이스 집합(<strong>Test Suite</strong>)으로 시스템 구조가 테스트된 정도를 말한다</li>
<li>뒤에서 계속 보겠지만 <strong>Coverage</strong>는 구문 테스팅을 할때는 코드의 어디어디가 실행되었나로 판단하게 되고 뭐 결정 Testing 을 할때는 어떤 분기나 경우의 수가 실행되었나로 판단하는 등 각각의 Test방법에 따라 Coverage를 구하는 방법은 달라진다</li>
<li>Coverage 목표치를 정해놓고 해당 Coverage에 도달할때까지 Test Suite에 테스트케이스를 추가하며 테스트를 진행하게 되고 이렇게 함으로써 여러 경우에 수에 대한 테스트를 좀 더 체계적으로 진행할 수 있게 된다</li>
</ul>
</li>
</ul>
<h3 id="statement-testing--coverage">Statement Testing &amp; Coverage<a aria-hidden="true" tabindex="-1" href="#statement-testing--coverage" class="internal"> §</a></h3>
<ul>
<li>말 그대로 어느 Statement가 실행되었고 어느 Statement가 실행되지 않았는지를 판단해 Coverage를 구하며 Test Suite를 조정하는 방법</li>
<li>얘는 Basic Block을 Statement 한줄로 하는 Control Flow Graph를 그리고 Test Suite의 테스트케이스를 진행하며 어느정도 Coverage가 나오는지 확인하는 방법이라고 생각하면 된다</li>
</ul>
<p><img src="../../../../gardens/sw-eng/originals/softwareengineering.fall.2021.cse.cnu.ac.kr/images/10_5fba9d51c2c0427e8a8f3802d855cb1c/image1.png" alt="%E1%84%8B%E1%85%B5%E1%84%85%E1%85%A9%E1%86%AB12%20-%20%E1%84%89%E1%85%A9%E1%84%91%E1%85%B3%E1%84%90%E1%85%B3%E1%84%8B%E1%85%B0%E1%84%8B%E1%85%A5%20%E1%84%90%E1%85%A6%E1%84%89%E1%85%B3%E1%84%90%E1%85%B3(2)%205fba9d51c2c0427e8a8f3802d855cb1c/image1.png"/></p>
<ul>
<li>컴파일러 강의를 제대로 들었고 위의 문장이 이해되면 위의 예시또한 어렵지 않게 이해할 수 있음</li>
<li>제일 왼쪽이 코드고 그 다음이 해당 코드의 Statement로 그린 CFG, 그리고 오른쪽이 해당 TS로 알아낸 Coverage이다</li>
<li>하는 방법은 TS의 테케를 돌리고 어디어디가 커버됐는지 확인한 뒤 Coverage를 구하면 되는데</li>
<li>이때 중요한건 total stmt에서 unreachable stmt의 갯수를 빼줘야 된다는 거다 - unreachable stmt를 빼지 않으면 절대로 100퍼가 나오지 않으므로 - 따라서 unreachable stmt를 coverage를 구하기 전에 반드시 구해줘야 한다</li>
</ul>
<h3 id="decision-testing--coverage">Decision Testing &amp; Coverage<a aria-hidden="true" tabindex="-1" href="#decision-testing--coverage" class="internal"> §</a></h3>
<ul>
<li>여기서의 Coverage는 하나의 분기문에 대해 참과 거짓으로 모두 분기했을때 Decision Coverage가 1이라고 본다</li>
<li>뒤에서 나올 Condition Coverage와는 다르게 Decision Coverage는 분기문의 조건식 전체에 대해 결과가 참이냐 거짓이냐로 Coverage를 계산한다는 점을 주의할 것
<ul>
<li>즉, 말그대로 Decision이기 때문에 양쪽의 분기방향에 대해서만 생각하게 되는거다</li>
</ul>
</li>
</ul>
<p><img src="../../../../gardens/sw-eng/originals/softwareengineering.fall.2021.cse.cnu.ac.kr/images/10_5fba9d51c2c0427e8a8f3802d855cb1c/image2.png" alt="%E1%84%8B%E1%85%B5%E1%84%85%E1%85%A9%E1%86%AB12%20-%20%E1%84%89%E1%85%A9%E1%84%91%E1%85%B3%E1%84%90%E1%85%B3%E1%84%8B%E1%85%B0%E1%84%8B%E1%85%A5%20%E1%84%90%E1%85%A6%E1%84%89%E1%85%B3%E1%84%90%E1%85%B3(2)%205fba9d51c2c0427e8a8f3802d855cb1c/image2.png"/></p>
<ul>
<li>예시를 보면 당연히 저 if문이 Decision Point가 되고</li>
<li>예시로 주어진 TS을 실행해보면 F와 T가 골고루 나왔으므로 covered decision이 1인데 Decision의 총 갯수도 1개이기 때문에 100%의 Coverage가 나오게 되는 것</li>
<li>여기서는 if문이 하나밖에 없어서 Decision 의 갯수가 1개인거지만 if문이 여러개인 놈을 테스트할때는 Total Decision 값이 n인 것에 주의하셈</li>
</ul>
<h3 id="condition-testing--coverage">Condition Testing &amp; Coverage<a aria-hidden="true" tabindex="-1" href="#condition-testing--coverage" class="internal"> §</a></h3>
<ul>
<li>여기서는 Decision Testing과는 다르게 Decision Point의 Condition Expression 각각에 대해 참과 거짓이 모두 나와야 해당 condition이 cover된것으로 판단한다</li>
</ul>
<p><img src="../../../../gardens/sw-eng/originals/softwareengineering.fall.2021.cse.cnu.ac.kr/images/10_5fba9d51c2c0427e8a8f3802d855cb1c/image3.png" alt="%E1%84%8B%E1%85%B5%E1%84%85%E1%85%A9%E1%86%AB12%20-%20%E1%84%89%E1%85%A9%E1%84%91%E1%85%B3%E1%84%90%E1%85%B3%E1%84%8B%E1%85%B0%E1%84%8B%E1%85%A5%20%E1%84%90%E1%85%A6%E1%84%89%E1%85%B3%E1%84%90%E1%85%B3(2)%205fba9d51c2c0427e8a8f3802d855cb1c/image3.png"/></p>
<ul>
<li>예시를 보면</li>
<li>Decision Point에 Condition Expression이 두개 있으므로 쟤네 각각에 대해 TF가 골고루 나와야 각각이 cover된 것으로 판단하게 됨</li>
<li>예제로 주어진 TS를 해보면 위 표에서 보는것처럼 x >= -2가 TF가 나오므로 이게 cover가 되고 y &lt; 4도 TF가 골고루 나와 cover가 된다</li>
<li>따라서 total condition의 갯수가 2이고 covered condition도 2이므로 100%의 Condition Coverage가 나오게 된다</li>
</ul>
<h3 id="multiple-condition-coverage">Multiple Condition Coverage<a aria-hidden="true" tabindex="-1" href="#multiple-condition-coverage" class="internal"> §</a></h3>
<ul>
<li>애는 Condition 각각이 TF가 나오는 경우에서 더 나아가 Condition들이 만들어낼 수 있는 모든 TF조합으로 판단하는 거다</li>
<li>예를들어 if(c1 BOOLOP c2)의 경우에 TT, TF, FT, FF 4개의 조합이 만들어지고 이 조합을 모두 충족해야 해당 Decision이 cover된 것으로 판단한다</li>
<li>따라서 Boolean Operation으로 연결된 Condition Expression이 n개 존재한다면 가능한 조합은 2^n이 되고 이것은 엄청나게 많은 수의 테케를 필요로 하므로 반드시 결함이 없어야되는 경우가 아니라면 진행하지 않는다</li>
</ul>
<h3 id="testing들-간의-포함관계">Testing들 간의 포함관계<a aria-hidden="true" tabindex="-1" href="#testing들-간의-포함관계" class="internal"> §</a></h3>
<ul>
<li>뭔가 Condition Testing이 더 자세하기 때문에 이걸 만족하면 Decision Testing도 통과할거같지만 Condition Testing과 Decision Testing은 포함관계가 아니고 하나가 통과해도 나머지 하나가 실패하는 경우가 있기 때문에 두개를 반드시 수행해줘야 한다</li>
</ul>
<p><img src="../../../../gardens/sw-eng/originals/softwareengineering.fall.2021.cse.cnu.ac.kr/images/10_5fba9d51c2c0427e8a8f3802d855cb1c/image4.png" alt="%E1%84%8B%E1%85%B5%E1%84%85%E1%85%A9%E1%86%AB12%20-%20%E1%84%89%E1%85%A9%E1%84%91%E1%85%B3%E1%84%90%E1%85%B3%E1%84%8B%E1%85%B0%E1%84%8B%E1%85%A5%20%E1%84%90%E1%85%A6%E1%84%89%E1%85%B3%E1%84%90%E1%85%B3(2)%205fba9d51c2c0427e8a8f3802d855cb1c/image4.png"/></p>
<ul>
<li>위 표를 보면 모든 Test Case들에 대해 Condition Testing의 결과와 Decision Testing의 결과가 적혀있는데</li>
<li>T1을 보면 Condition Testing는 TF가 골고루 나와 통과하지만 Decision Testing 에서는 FF가 나와 통과하지 못하게 되는 것을 볼 수 있음</li>
<li>T2는 반대로 Decision Testing은 TF가 나와 통과하지만 Condition Testing에서는 두번째 테케가 TT가 나와 실패한다</li>
<li>따라서 T1와 T2를 합집합한 T3을 돌려야 Decision Testing과 Condition Testing을 모두 통과하게 되는 것</li>
</ul>
<p><img src="../../../../gardens/sw-eng/originals/softwareengineering.fall.2021.cse.cnu.ac.kr/images/10_5fba9d51c2c0427e8a8f3802d855cb1c/image5.png" alt="%E1%84%8B%E1%85%B5%E1%84%85%E1%85%A9%E1%86%AB12%20-%20%E1%84%89%E1%85%A9%E1%84%91%E1%85%B3%E1%84%90%E1%85%B3%E1%84%8B%E1%85%B0%E1%84%8B%E1%85%A5%20%E1%84%90%E1%85%A6%E1%84%89%E1%85%B3%E1%84%90%E1%85%B3(2)%205fba9d51c2c0427e8a8f3802d855cb1c/image5.png"/></p>
<ul>
<li>따라서 위와 같은 포함관계가 나오게 된다</li>
</ul>
<h2 id="개발-단계를-기준으로-한-테스트-분류">개발 단계를 기준으로 한 테스트 분류<a aria-hidden="true" tabindex="-1" href="#개발-단계를-기준으로-한-테스트-분류" class="internal"> §</a></h2>
<ul>
<li><strong>Unit Test</strong> : 모듈 하나에 대한 테스트
<ul>
<li>주로 White Box Test를 진행한다</li>
</ul>
</li>
<li><strong>Integration Test</strong> : 전역변수 이슈나 인터페이스 결함 등의 모듈간 통합 과정에서 일어날 수 있는 결함을 체크한다
<ul>
<li>그냥 모듈들을 다 합치고 한꺼번에 테스트하는 것을 <strong>Bing-Bang Test</strong>라고 하는데</li>
<li>저건 너무 무식하니까 모듈들을 붙여가며 서브시스템을 테스트하고 서브시스템도 붙여가며 테스트하는 <strong>Incremental Testing</strong>을 진행한다</li>
<li>이건 수평적으로 붙이면서 진행할때도 있고 수직적으로 붙이면서 수행할 때도 있음</li>
<li><strong>Top-down Testing</strong>은 UI에서 DB까지의 순서대로 내려가며 합치는 방법을 의미하고 이때 하위 시스템에 대해서는 사용하지 못하기 때문에 Test Stub을 이용해 하위 시스템에 대한 mock을 사용하여 테스트한다</li>
<li><strong>Bottom-up Testing</strong>은 DB에서 UI까지 올라가며 합치는 방법이고 이때 상위 시스템에 대한 mock으로 Test Driver를 이용한다</li>
<li>그리고 이 둘을 섞은 <strong>Sandwich Testing</strong>이 있음 - 얘는 UI를 테스트하고 DB를 테스트한 뒤 가운데를 테스트하는 방법이다 - 이때에도 하위나 상위 시스템에 대한 mock으로 Test Driver나 Test Stub을 사용한다</li>
</ul>
</li>
<li><strong>System Test</strong> : 요구사항 명세를 기준으로 기능적, 비기능적(비기능 요구사항에 있었던 뭐 성능이나 이런것들) 테스트를 진행함</li>
<li><strong>Acceptance Testing</strong> : 실제 사용자들을 참여시켜 사용자의 요구대로 돌아가는지 확인함
<ul>
<li><strong>Alpha Test</strong> : 개발팀의 감독 하에 고객이 수행하는 테스트</li>
<li><strong>Beta Test</strong> : 임의의 사용자가 개발팀과는 무관한 환경에서 테스트하게 해볼 목적으로 사용자들이 직접 테스팅하고 문제점을 report하는 형태
<ul>
<li><strong>Open Beta Release</strong>로 일반인에게 임시 배포를 해 테스팅 하는 방법이 해당한다</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="테스터에-따른-분류">테스터에 따른 분류<a aria-hidden="true" tabindex="-1" href="#테스터에-따른-분류" class="internal"> §</a></h2>
<ul>
<li><strong>Developer Test</strong> : 개발자나 연관된 테스팅 그룹에 의해 수행되는 테스트</li>
<li><strong>Independent Test</strong> : 무관한 제 3자에 의해 테스트하는 것</li>
</ul></article></div><div class="right sidebar"><div class="graph "><h3>Graph View</h3><div class="graph-outer"><div id="graph-container" data-cfg="{&quot;drag&quot;:true,&quot;zoom&quot;:true,&quot;depth&quot;:1,&quot;scale&quot;:1.1,&quot;repelForce&quot;:0.5,&quot;centerForce&quot;:0.3,&quot;linkDistance&quot;:30,&quot;fontSize&quot;:0.6,&quot;opacityScale&quot;:1,&quot;showTags&quot;:true,&quot;removeTags&quot;:[]}"></div><svg version="1.1" id="global-graph-icon" xmlns="http://www.w3.org/2000/svg" xmlnsXlink="http://www.w3.org/1999/xlink" x="0px" y="0px" viewBox="0 0 55 55" fill="currentColor" xmlSpace="preserve"><path d="M49,0c-3.309,0-6,2.691-6,6c0,1.035,0.263,2.009,0.726,2.86l-9.829,9.829C32.542,17.634,30.846,17,29,17
	s-3.542,0.634-4.898,1.688l-7.669-7.669C16.785,10.424,17,9.74,17,9c0-2.206-1.794-4-4-4S9,6.794,9,9s1.794,4,4,4
	c0.74,0,1.424-0.215,2.019-0.567l7.669,7.669C21.634,21.458,21,23.154,21,25s0.634,3.542,1.688,4.897L10.024,42.562
	C8.958,41.595,7.549,41,6,41c-3.309,0-6,2.691-6,6s2.691,6,6,6s6-2.691,6-6c0-1.035-0.263-2.009-0.726-2.86l12.829-12.829
	c1.106,0.86,2.44,1.436,3.898,1.619v10.16c-2.833,0.478-5,2.942-5,5.91c0,3.309,2.691,6,6,6s6-2.691,6-6c0-2.967-2.167-5.431-5-5.91
	v-10.16c1.458-0.183,2.792-0.759,3.898-1.619l7.669,7.669C41.215,39.576,41,40.26,41,41c0,2.206,1.794,4,4,4s4-1.794,4-4
	s-1.794-4-4-4c-0.74,0-1.424,0.215-2.019,0.567l-7.669-7.669C36.366,28.542,37,26.846,37,25s-0.634-3.542-1.688-4.897l9.665-9.665
	C46.042,11.405,47.451,12,49,12c3.309,0,6-2.691,6-6S52.309,0,49,0z M11,9c0-1.103,0.897-2,2-2s2,0.897,2,2s-0.897,2-2,2
	S11,10.103,11,9z M6,51c-2.206,0-4-1.794-4-4s1.794-4,4-4s4,1.794,4,4S8.206,51,6,51z M33,49c0,2.206-1.794,4-4,4s-4-1.794-4-4
	s1.794-4,4-4S33,46.794,33,49z M29,31c-3.309,0-6-2.691-6-6s2.691-6,6-6s6,2.691,6,6S32.309,31,29,31z M47,41c0,1.103-0.897,2-2,2
	s-2-0.897-2-2s0.897-2,2-2S47,39.897,47,41z M49,10c-2.206,0-4-1.794-4-4s1.794-4,4-4s4,1.794,4,4S51.206,10,49,10z"></path></svg></div><div id="global-graph-outer"><div id="global-graph-container" data-cfg="{&quot;drag&quot;:true,&quot;zoom&quot;:true,&quot;depth&quot;:-1,&quot;scale&quot;:0.9,&quot;repelForce&quot;:0.5,&quot;centerForce&quot;:0.3,&quot;linkDistance&quot;:30,&quot;fontSize&quot;:0.6,&quot;opacityScale&quot;:1,&quot;showTags&quot;:true,&quot;removeTags&quot;:[]}"></div></div></div><div class="toc desktop-only"><button type="button" id="toc"><h3>Table of Contents</h3><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="fold"><polyline points="6 9 12 15 18 9"></polyline></svg></button><div id="toc-content"><ul class="overflow"><li class="depth-0"><a href="#whitebox-testing" data-for="whitebox-testing">Whitebox Testing</a></li><li class="depth-1"><a href="#statement-testing--coverage" data-for="statement-testing--coverage">Statement Testing &amp; Coverage</a></li><li class="depth-1"><a href="#decision-testing--coverage" data-for="decision-testing--coverage">Decision Testing &amp; Coverage</a></li><li class="depth-1"><a href="#condition-testing--coverage" data-for="condition-testing--coverage">Condition Testing &amp; Coverage</a></li><li class="depth-1"><a href="#multiple-condition-coverage" data-for="multiple-condition-coverage">Multiple Condition Coverage</a></li><li class="depth-1"><a href="#testing들-간의-포함관계" data-for="testing들-간의-포함관계">Testing들 간의 포함관계</a></li><li class="depth-0"><a href="#개발-단계를-기준으로-한-테스트-분류" data-for="개발-단계를-기준으로-한-테스트-분류">개발 단계를 기준으로 한 테스트 분류</a></li><li class="depth-0"><a href="#테스터에-따른-분류" data-for="테스터에-따른-분류">테스터에 따른 분류</a></li></ul></div></div><div class="backlinks "><h3>Backlinks</h3><ul class="overflow"><li><a href="../../../../gardens/sw-eng/originals/softwareengineering.fall.2021.cse.cnu.ac.kr/(충남대)-소프트웨어-공학-강의록" class="internal">(충남대) 소프트웨어 공학 강의록</a></li></ul></div></div></div><footer class><hr/><p>Created with <a href="https://quartz.jzhao.xyz/">Quartz v4.1.0</a>, © 2024</p><ul><li><a href="https://github.com/haeramkeem">GitHub</a></li><li><a href="www.linkedin.com/in/haeram-kim-277404220">LinkedIn</a></li><li><a href="mailto:haeram.kim1@gmail.com">Email</a></li></ul></footer></div></body><script type="application/javascript">// quartz/components/scripts/quartz/components/scripts/callout.inline.ts
function toggleCallout() {
  const outerBlock = this.parentElement;
  outerBlock.classList.toggle(`is-collapsed`);
  const collapsed = outerBlock.classList.contains(`is-collapsed`);
  const height = collapsed ? this.scrollHeight : outerBlock.scrollHeight;
  outerBlock.style.maxHeight = height + `px`;
  let current = outerBlock;
  let parent = outerBlock.parentElement;
  while (parent) {
    if (!parent.classList.contains(`callout`)) {
      return;
    }
    const collapsed2 = parent.classList.contains(`is-collapsed`);
    const height2 = collapsed2 ? parent.scrollHeight : parent.scrollHeight + current.scrollHeight;
    parent.style.maxHeight = height2 + `px`;
    current = parent;
    parent = parent.parentElement;
  }
}
function setupCallout() {
  const collapsible = document.getElementsByClassName(
    `callout is-collapsible`
  );
  for (const div of collapsible) {
    const title = div.firstElementChild;
    if (title) {
      title.removeEventListener(`click`, toggleCallout);
      title.addEventListener(`click`, toggleCallout);
      const collapsed = div.classList.contains(`is-collapsed`);
      const height = collapsed ? title.scrollHeight : div.scrollHeight;
      div.style.maxHeight = height + `px`;
    }
  }
}
document.addEventListener(`nav`, setupCallout);
window.addEventListener(`resize`, setupCallout);
</script><script type="module">
          import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.esm.min.mjs';
          const darkMode = document.documentElement.getAttribute('saved-theme') === 'dark'
          mermaid.initialize({
            startOnLoad: false,
            securityLevel: 'loose',
            theme: darkMode ? 'dark' : 'default'
          });
          document.addEventListener('nav', async () => {
            await mermaid.run({
              querySelector: '.mermaid'
            })
          });
          </script><script src="https://cdn.jsdelivr.net/npm/katex@0.16.7/dist/contrib/copy-tex.min.js" type="application/javascript"></script><script src="https://www.googletagmanager.com/gtag/js?id=G-N68CCP1QHG" type="application/javascript"></script><script src="../../../../postscript.js" type="module"></script></html>