<!DOCTYPE html>
<html><head><title>07. 아키텍쳐 디자인</title><meta charSet="utf-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><meta property="og:title" content="07. 아키텍쳐 디자인"/><meta property="og:description" content="충남대학교 컴퓨터공학과 김현수 교수님의 &amp;quot;소프트웨어 공학&amp;quot; 강의를 필기한 내용입니다. 다소 잘못된 내용과 구어적 표현 이 포함되어 있을 수 있습니다. 아키텍쳐 설계 § 기능적 요구사항을 구현하기 위한 방법을 찾고 비기능적 요구사항에 명시된 제약을 준수하기 위한 설계 과정 Design Space § 위처럼 선택 가능한 모든 설계의 대안을 모아놓은 것을 Design Space 라고 하고 이 중에서 경로를 하나 선택해서 설계를 하고 이것이 설계의 최종 산출물이 된다 설계를 구성하는 요소들 § Module : 프로그래밍 언어 수준에서 정의된 컴포넌트 위 그림에서 보이는것처럼 컴포넌트는 컴포넌트로 구성될 수 있고 시스템의 구성요소가 될 수도 있다 상향식 설계 / 하향식 설계 § 하향식 설계(Top-Down) : 시스템의 최상위부분을 설계하고 하위 컴포넌트로 점차 내려오면서 구체적으로 설계하는 방식 하향식 설계는 전체 시스템 구조를 잡는데 좋다는 장점이 있다 상향식 설계(Bottom-Up) : 컴포넌트들을 일단 다 구성한 후에 그것들을 배치하며 높은 수준의 구조를 설계하는 것 상향식 설계는 재사용 가능한 컴포넌트를 구성하는 것에 강점이 있다는 장점이 있다 보통은 이 둘을 혼용하여 각각의 장점을 모두 취한다 설계의 종류 § 아키텍처 설계 : 전체 시스템과 서브 시스템, 컴포넌트들로 분할하여 구조와 관계를 잡는 것 클래스 설계 : 각각 컴포넌트들에 대해 설계 사용자 인터페이스 설계 : UI 알고리즘 설계 : 계산벙식 설계 프로토콜 설계 : 통신 규정(프로토콜) 설계 설계 원리1 : Divide &amp;amp; Conquer § 말 그대로 분할 정복 사람들을 업무대로 나누어 각 부분을 작업하게 함 뭐 병행적으로 진행되어서 더 빠르고 자신의 분야에서 전문성이 높아지고 각 컴포넌트들의 품질이 향상 된다 설계 원리2: 응집력 향상 § 관련있는것들을 하나의 모듈에 모아 시스템의 변경이나 이해에 도움이 되게 함 따라서 응집력은 높을수롣 좋은 것 각각 응집도에 따른 응집력은 위와 같음 기능적 응집도 § 말 그대로 기능적으로 밀접하게 관련되어 있는 프로시저들을 하나의 모듈에 묶는 것을 의미함 모듈이 단일 작업을 수행하고 하나의 결과만 낼수록 기능적 응집도가 커진다 모듈이 단일한 기능만을 제공하기 때문에 이해하기 쉽고 재사용이 쉽고 : 해당 기능을 필요로 할 때마다 호출하면 되기 때문 대체하기 쉬움 : 다른 더 좋은 라이브러리가 있을때 교체하는 것이 용이 계층적 응집도 § 연관된 서비스들을 하나의 계층에 넣고 다른것들은 배제하는 것 여기서 계층과 모듈과의 차이점 은 상위계층에서 하위 계층의 서비스를 이용할 수는 있지만 그 반대는 안된다는 것이다 상호작용 인터페이스만 유지하면 다른 층에 영향을 주지 않고 계층을 변경할 수 있다는 장점 이 있다 순차적 응집도 § 프로시저가 순차적으로 실행되며 우선적으로 실행된 프로시저의 결과물이 이후에 실행되는 프로시저에 사용될 경우 순차적 응집도 가 가깝다고 한다 교환적 응집도 § 교환적 응집도는 클래스 생각하면 이해하기 쉬움 특정 데이터에 조작하는 애들끼리 모아놓고 해당 모듈이 그 데이터를 조작하는 것 외에는 별다른 일을 하지 않을 경우 교환적 응집도 가 올라간다 객체지향의 큰 장점 중 하나는 교환적 응집을 보장한다는 것 이다 절차적 응집도 § 차례로 수행되는 프로시저를 모아놓은 경우 순차적 응집도와의 차이점은 순차적 응집도는 차례로 수행되는 것 외에도 데이터도 같이 이동하며 묶여있어야 되고 절차적 응집도의 경우에는 순서대로만 수행되면 되는 것 시간적 응집도 § 비슷한 시점에 작동할 프로시저들을 모아놓은 것 시스템 시작시에 초기화해주는 역할을 하는 애들 한곳에 모아놓는거 생각하면 된다 실용적 응집도 § 그냥 뭐 어디에 넣기 애매한 유틸리티같은거 걍 한곳에 다 때려박은 것을 의미함 설계 원리3: 결합력 낮춤 § 두 모듈 사이에 결합이 있다는 것은 모듈 간 의존관계가 있다는 것이다 의존관계가 있으면 한쪽의 변경이 다른 한쪽한테 영향을 주기 때문에 결합은 낮으면 낮을수록 좋음 또한 의존관계가 높으면 컴포넌트들이 어떻게 수행되는지 파악하기도 힘들다 위의 그림에서 위에 있는 결합일수록 결합력이 높고 더 안좋다."/><meta property="og:image" content="https://mdg.haeramk.im/static/og-image.png"/><meta property="og:width" content="1200"/><meta property="og:height" content="675"/><link rel="icon" href="../../../../static/icon.png"/><meta name="description" content="충남대학교 컴퓨터공학과 김현수 교수님의 &amp;quot;소프트웨어 공학&amp;quot; 강의를 필기한 내용입니다. 다소 잘못된 내용과 구어적 표현 이 포함되어 있을 수 있습니다. 아키텍쳐 설계 § 기능적 요구사항을 구현하기 위한 방법을 찾고 비기능적 요구사항에 명시된 제약을 준수하기 위한 설계 과정 Design Space § 위처럼 선택 가능한 모든 설계의 대안을 모아놓은 것을 Design Space 라고 하고 이 중에서 경로를 하나 선택해서 설계를 하고 이것이 설계의 최종 산출물이 된다 설계를 구성하는 요소들 § Module : 프로그래밍 언어 수준에서 정의된 컴포넌트 위 그림에서 보이는것처럼 컴포넌트는 컴포넌트로 구성될 수 있고 시스템의 구성요소가 될 수도 있다 상향식 설계 / 하향식 설계 § 하향식 설계(Top-Down) : 시스템의 최상위부분을 설계하고 하위 컴포넌트로 점차 내려오면서 구체적으로 설계하는 방식 하향식 설계는 전체 시스템 구조를 잡는데 좋다는 장점이 있다 상향식 설계(Bottom-Up) : 컴포넌트들을 일단 다 구성한 후에 그것들을 배치하며 높은 수준의 구조를 설계하는 것 상향식 설계는 재사용 가능한 컴포넌트를 구성하는 것에 강점이 있다는 장점이 있다 보통은 이 둘을 혼용하여 각각의 장점을 모두 취한다 설계의 종류 § 아키텍처 설계 : 전체 시스템과 서브 시스템, 컴포넌트들로 분할하여 구조와 관계를 잡는 것 클래스 설계 : 각각 컴포넌트들에 대해 설계 사용자 인터페이스 설계 : UI 알고리즘 설계 : 계산벙식 설계 프로토콜 설계 : 통신 규정(프로토콜) 설계 설계 원리1 : Divide &amp;amp; Conquer § 말 그대로 분할 정복 사람들을 업무대로 나누어 각 부분을 작업하게 함 뭐 병행적으로 진행되어서 더 빠르고 자신의 분야에서 전문성이 높아지고 각 컴포넌트들의 품질이 향상 된다 설계 원리2: 응집력 향상 § 관련있는것들을 하나의 모듈에 모아 시스템의 변경이나 이해에 도움이 되게 함 따라서 응집력은 높을수롣 좋은 것 각각 응집도에 따른 응집력은 위와 같음 기능적 응집도 § 말 그대로 기능적으로 밀접하게 관련되어 있는 프로시저들을 하나의 모듈에 묶는 것을 의미함 모듈이 단일 작업을 수행하고 하나의 결과만 낼수록 기능적 응집도가 커진다 모듈이 단일한 기능만을 제공하기 때문에 이해하기 쉽고 재사용이 쉽고 : 해당 기능을 필요로 할 때마다 호출하면 되기 때문 대체하기 쉬움 : 다른 더 좋은 라이브러리가 있을때 교체하는 것이 용이 계층적 응집도 § 연관된 서비스들을 하나의 계층에 넣고 다른것들은 배제하는 것 여기서 계층과 모듈과의 차이점 은 상위계층에서 하위 계층의 서비스를 이용할 수는 있지만 그 반대는 안된다는 것이다 상호작용 인터페이스만 유지하면 다른 층에 영향을 주지 않고 계층을 변경할 수 있다는 장점 이 있다 순차적 응집도 § 프로시저가 순차적으로 실행되며 우선적으로 실행된 프로시저의 결과물이 이후에 실행되는 프로시저에 사용될 경우 순차적 응집도 가 가깝다고 한다 교환적 응집도 § 교환적 응집도는 클래스 생각하면 이해하기 쉬움 특정 데이터에 조작하는 애들끼리 모아놓고 해당 모듈이 그 데이터를 조작하는 것 외에는 별다른 일을 하지 않을 경우 교환적 응집도 가 올라간다 객체지향의 큰 장점 중 하나는 교환적 응집을 보장한다는 것 이다 절차적 응집도 § 차례로 수행되는 프로시저를 모아놓은 경우 순차적 응집도와의 차이점은 순차적 응집도는 차례로 수행되는 것 외에도 데이터도 같이 이동하며 묶여있어야 되고 절차적 응집도의 경우에는 순서대로만 수행되면 되는 것 시간적 응집도 § 비슷한 시점에 작동할 프로시저들을 모아놓은 것 시스템 시작시에 초기화해주는 역할을 하는 애들 한곳에 모아놓는거 생각하면 된다 실용적 응집도 § 그냥 뭐 어디에 넣기 애매한 유틸리티같은거 걍 한곳에 다 때려박은 것을 의미함 설계 원리3: 결합력 낮춤 § 두 모듈 사이에 결합이 있다는 것은 모듈 간 의존관계가 있다는 것이다 의존관계가 있으면 한쪽의 변경이 다른 한쪽한테 영향을 주기 때문에 결합은 낮으면 낮을수록 좋음 또한 의존관계가 높으면 컴포넌트들이 어떻게 수행되는지 파악하기도 힘들다 위의 그림에서 위에 있는 결합일수록 결합력이 높고 더 안좋다."/><meta name="generator" content="Quartz"/><link rel="preconnect" href="https://fonts.googleapis.com"/><link rel="preconnect" href="https://fonts.gstatic.com"/><link href="../../../../index.css" rel="stylesheet" type="text/css" spa-preserve/><link href="https://cdn.jsdelivr.net/npm/katex@0.16.0/dist/katex.min.css" rel="stylesheet" type="text/css" spa-preserve/><link href="https://fonts.googleapis.com/css2?family=IBM Plex Mono&amp;family=Gowun Batang:wght@400;700&amp;family=Gowun Dodum:ital,wght@0,400;0,600;1,400;1,600&amp;display=swap" rel="stylesheet" type="text/css" spa-preserve/><script src="../../../../prescript.js" type="application/javascript" spa-preserve></script><script type="application/javascript" spa-preserve>const fetchData = fetch(`../../../../static/contentIndex.json`).then(data => data.json())</script></head><body data-slug="gardens/sw-eng/originals/softwareengineering.fall.2021.cse.cnu.ac.kr/07.-아키텍쳐-디자인"><div id="quartz-root" class="page"><div id="quartz-body"><div class="left sidebar"><h1 class="page-title "><a href="../../../..">Madison Digital Garden</a></h1><div class="spacer mobile-only"></div><div class="search "><div id="search-icon"><p>Search</p><div></div><svg tabIndex="0" aria-labelledby="title desc" role="img" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 19.9 19.7"><title id="title">Search</title><desc id="desc">Search</desc><g class="search-path" fill="none"><path stroke-linecap="square" d="M18.5 18.3l-5.4-5.4"></path><circle cx="8" cy="8" r="7"></circle></g></svg></div><div id="search-container"><div id="search-space"><input autocomplete="off" id="search-bar" name="search" type="text" aria-label="Search for something" placeholder="Search for something"/><div id="results-container"></div></div></div></div><div class="darkmode "><input class="toggle" id="darkmode-toggle" type="checkbox" tabIndex="-1"/><label id="toggle-label-light" for="darkmode-toggle" tabIndex="-1"><svg xmlns="http://www.w3.org/2000/svg" xmlnsXlink="http://www.w3.org/1999/xlink" version="1.1" id="dayIcon" x="0px" y="0px" viewBox="0 0 35 35" style="enable-background:new 0 0 35 35;" xmlSpace="preserve"><title>Light mode</title><path d="M6,17.5C6,16.672,5.328,16,4.5,16h-3C0.672,16,0,16.672,0,17.5    S0.672,19,1.5,19h3C5.328,19,6,18.328,6,17.5z M7.5,26c-0.414,0-0.789,0.168-1.061,0.439l-2,2C4.168,28.711,4,29.086,4,29.5    C4,30.328,4.671,31,5.5,31c0.414,0,0.789-0.168,1.06-0.44l2-2C8.832,28.289,9,27.914,9,27.5C9,26.672,8.329,26,7.5,26z M17.5,6    C18.329,6,19,5.328,19,4.5v-3C19,0.672,18.329,0,17.5,0S16,0.672,16,1.5v3C16,5.328,16.671,6,17.5,6z M27.5,9    c0.414,0,0.789-0.168,1.06-0.439l2-2C30.832,6.289,31,5.914,31,5.5C31,4.672,30.329,4,29.5,4c-0.414,0-0.789,0.168-1.061,0.44    l-2,2C26.168,6.711,26,7.086,26,7.5C26,8.328,26.671,9,27.5,9z M6.439,8.561C6.711,8.832,7.086,9,7.5,9C8.328,9,9,8.328,9,7.5    c0-0.414-0.168-0.789-0.439-1.061l-2-2C6.289,4.168,5.914,4,5.5,4C4.672,4,4,4.672,4,5.5c0,0.414,0.168,0.789,0.439,1.06    L6.439,8.561z M33.5,16h-3c-0.828,0-1.5,0.672-1.5,1.5s0.672,1.5,1.5,1.5h3c0.828,0,1.5-0.672,1.5-1.5S34.328,16,33.5,16z     M28.561,26.439C28.289,26.168,27.914,26,27.5,26c-0.828,0-1.5,0.672-1.5,1.5c0,0.414,0.168,0.789,0.439,1.06l2,2    C28.711,30.832,29.086,31,29.5,31c0.828,0,1.5-0.672,1.5-1.5c0-0.414-0.168-0.789-0.439-1.061L28.561,26.439z M17.5,29    c-0.829,0-1.5,0.672-1.5,1.5v3c0,0.828,0.671,1.5,1.5,1.5s1.5-0.672,1.5-1.5v-3C19,29.672,18.329,29,17.5,29z M17.5,7    C11.71,7,7,11.71,7,17.5S11.71,28,17.5,28S28,23.29,28,17.5S23.29,7,17.5,7z M17.5,25c-4.136,0-7.5-3.364-7.5-7.5    c0-4.136,3.364-7.5,7.5-7.5c4.136,0,7.5,3.364,7.5,7.5C25,21.636,21.636,25,17.5,25z"></path></svg></label><label id="toggle-label-dark" for="darkmode-toggle" tabIndex="-1"><svg xmlns="http://www.w3.org/2000/svg" xmlnsXlink="http://www.w3.org/1999/xlink" version="1.1" id="nightIcon" x="0px" y="0px" viewBox="0 0 100 100" style="enable-background='new 0 0 100 100'" xmlSpace="preserve"><title>Dark mode</title><path d="M96.76,66.458c-0.853-0.852-2.15-1.064-3.23-0.534c-6.063,2.991-12.858,4.571-19.655,4.571  C62.022,70.495,50.88,65.88,42.5,57.5C29.043,44.043,25.658,23.536,34.076,6.47c0.532-1.08,0.318-2.379-0.534-3.23  c-0.851-0.852-2.15-1.064-3.23-0.534c-4.918,2.427-9.375,5.619-13.246,9.491c-9.447,9.447-14.65,22.008-14.65,35.369  c0,13.36,5.203,25.921,14.65,35.368s22.008,14.65,35.368,14.65c13.361,0,25.921-5.203,35.369-14.65  c3.872-3.871,7.064-8.328,9.491-13.246C97.826,68.608,97.611,67.309,96.76,66.458z"></path></svg></label></div></div><div class="center"><div class="page-header"><div class="popover-hint"><h1 class="article-title ">07. 아키텍쳐 디자인</h1><p class="content-meta ">Sep 29, 2024, 18 min read</p></div></div><article class="popover-hint"><blockquote class="callout" data-callout="info">
<div class="callout-title">
                  <div class="callout-icon"><svg xmlns="http://www.w3.org/2000/svg" width="100%" height="100%" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="10"></circle><line x1="12" y1="16" x2="12" y2="12"></line><line x1="12" y1="8" x2="12.01" y2="8"></line></svg></div>
                  <div class="callout-title-inner"><p>충남대학교 컴퓨터공학과 김현수 교수님의 &quot;소프트웨어 공학&quot; 강의를 필기한 내용입니다. </p></div>
                  
                </div>
</blockquote>
<blockquote class="callout" data-callout="warning">
<div class="callout-title">
                  <div class="callout-icon"><svg xmlns="http://www.w3.org/2000/svg" width="100%" height="100%" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="m21.73 18-8-14a2 2 0 0 0-3.48 0l-8 14A2 2 0 0 0 4 21h16a2 2 0 0 0 1.73-3Z"></path><line x1="12" y1="9" x2="12" y2="13"></line><line x1="12" y1="17" x2="12.01" y2="17"></line></svg></div>
                  <div class="callout-title-inner"><p>다소 잘못된 내용과 구어적 표현 이 포함되어 있을 수 있습니다. </p></div>
                  
                </div>
</blockquote>
<h2 id="아키텍쳐-설계">아키텍쳐 설계<a aria-hidden="true" tabindex="-1" href="#아키텍쳐-설계" class="internal"> §</a></h2>
<ul>
<li>기능적 요구사항을 구현하기 위한 방법을 찾고 비기능적 요구사항에 명시된 제약을 준수하기 위한 설계 과정</li>
</ul>
<h3 id="design-space">Design Space<a aria-hidden="true" tabindex="-1" href="#design-space" class="internal"> §</a></h3>
<p><img src="../../../../gardens/sw-eng/originals/softwareengineering.fall.2021.cse.cnu.ac.kr/images/07_b3edbc1c80984b7987c022f877a5b043/image1.png" alt="%E1%84%8B%E1%85%B5%E1%84%85%E1%85%A9%E1%86%AB08%20-%20%E1%84%8B%E1%85%A1%E1%84%8F%E1%85%B5%E1%84%90%E1%85%A6%E1%86%A8%E1%84%8E%E1%85%A7%20%E1%84%83%E1%85%B5%E1%84%8C%E1%85%A1%E1%84%8B%E1%85%B5%E1%86%AB(1)%20b3edbc1c80984b7987c022f877a5b043/image1.png"/></p>
<ul>
<li>위처럼 선택 가능한 모든 설계의 대안을 모아놓은 것을 <strong>Design Space</strong> 라고 하고</li>
<li>이 중에서 경로를 하나 선택해서 설계를 하고 이것이 설계의 최종 산출물이 된다</li>
</ul>
<h3 id="설계를-구성하는-요소들">설계를 구성하는 요소들<a aria-hidden="true" tabindex="-1" href="#설계를-구성하는-요소들" class="internal"> §</a></h3>
<p><img src="../../../../gardens/sw-eng/originals/softwareengineering.fall.2021.cse.cnu.ac.kr/images/07_b3edbc1c80984b7987c022f877a5b043/image2.png" alt="%E1%84%8B%E1%85%B5%E1%84%85%E1%85%A9%E1%86%AB08%20-%20%E1%84%8B%E1%85%A1%E1%84%8F%E1%85%B5%E1%84%90%E1%85%A6%E1%86%A8%E1%84%8E%E1%85%A7%20%E1%84%83%E1%85%B5%E1%84%8C%E1%85%A1%E1%84%8B%E1%85%B5%E1%86%AB(1)%20b3edbc1c80984b7987c022f877a5b043/image2.png"/></p>
<ul>
<li><strong>Module</strong> : 프로그래밍 언어 수준에서 정의된 컴포넌트</li>
<li>위 그림에서 보이는것처럼 컴포넌트는 컴포넌트로 구성될 수 있고 시스템의 구성요소가 될 수도 있다</li>
</ul>
<h3 id="상향식-설계--하향식-설계">상향식 설계 / 하향식 설계<a aria-hidden="true" tabindex="-1" href="#상향식-설계--하향식-설계" class="internal"> §</a></h3>
<ul>
<li><strong>하향식 설계(Top-Down)</strong> : 시스템의 최상위부분을 설계하고 하위 컴포넌트로 점차 내려오면서 구체적으로 설계하는 방식
<ul>
<li>하향식 설계는 전체 시스템 구조를 잡는데 좋다는 장점이 있다</li>
</ul>
</li>
<li><strong>상향식 설계(Bottom-Up)</strong> : 컴포넌트들을 일단 다 구성한 후에 그것들을 배치하며 높은 수준의 구조를 설계하는 것
<ul>
<li>상향식 설계는 재사용 가능한 컴포넌트를 구성하는 것에 강점이 있다는 장점이 있다</li>
</ul>
</li>
<li>보통은 이 둘을 혼용하여 각각의 장점을 모두 취한다</li>
</ul>
<h3 id="설계의-종류">설계의 종류<a aria-hidden="true" tabindex="-1" href="#설계의-종류" class="internal"> §</a></h3>
<ul>
<li><strong>아키텍처 설계</strong> : 전체 시스템과 서브 시스템, 컴포넌트들로 분할하여 구조와 관계를 잡는 것</li>
<li><strong>클래스 설계</strong> : 각각 컴포넌트들에 대해 설계</li>
<li><strong>사용자 인터페이스 설계</strong> : UI</li>
<li><strong>알고리즘 설계</strong> : 계산벙식 설계</li>
<li><strong>프로토콜 설계</strong> : 통신 규정(프로토콜) 설계</li>
</ul>
<h2 id="설계-원리1--divide--conquer">설계 원리1 : Divide &amp; Conquer<a aria-hidden="true" tabindex="-1" href="#설계-원리1--divide--conquer" class="internal"> §</a></h2>
<ul>
<li>말 그대로 <strong>분할 정복</strong></li>
<li>사람들을 업무대로 나누어 각 부분을 작업하게 함</li>
<li>뭐 병행적으로 진행되어서 더 빠르고</li>
<li>자신의 분야에서 전문성이 높아지고</li>
<li>각 컴포넌트들의 품질이 향상 된다</li>
</ul>
<h2 id="설계-원리2-응집력-향상">설계 원리2: 응집력 향상<a aria-hidden="true" tabindex="-1" href="#설계-원리2-응집력-향상" class="internal"> §</a></h2>
<ul>
<li>관련있는것들을 하나의 모듈에 모아 시스템의 변경이나 이해에 도움이 되게 함</li>
<li>따라서 응집력은 높을수롣 좋은 것</li>
</ul>
<p><img src="../../../../gardens/sw-eng/originals/softwareengineering.fall.2021.cse.cnu.ac.kr/images/07_b3edbc1c80984b7987c022f877a5b043/image3.png" alt="%E1%84%8B%E1%85%B5%E1%84%85%E1%85%A9%E1%86%AB08%20-%20%E1%84%8B%E1%85%A1%E1%84%8F%E1%85%B5%E1%84%90%E1%85%A6%E1%86%A8%E1%84%8E%E1%85%A7%20%E1%84%83%E1%85%B5%E1%84%8C%E1%85%A1%E1%84%8B%E1%85%B5%E1%86%AB(1)%20b3edbc1c80984b7987c022f877a5b043/image3.png"/></p>
<ul>
<li>각각 응집도에 따른 응집력은 위와 같음</li>
</ul>
<h3 id="기능적-응집도">기능적 응집도<a aria-hidden="true" tabindex="-1" href="#기능적-응집도" class="internal"> §</a></h3>
<ul>
<li>말 그대로 기능적으로 밀접하게 관련되어 있는 프로시저들을 하나의 모듈에 묶는 것을 의미함</li>
<li>모듈이 단일 작업을 수행하고 하나의 결과만 낼수록 기능적 응집도가 커진다</li>
<li>모듈이 단일한 기능만을 제공하기 때문에</li>
<li>이해하기 쉽고</li>
<li>재사용이 쉽고 : 해당 기능을 필요로 할 때마다 호출하면 되기 때문</li>
<li>대체하기 쉬움 : 다른 더 좋은 라이브러리가 있을때 교체하는 것이 용이</li>
</ul>
<h3 id="계층적-응집도">계층적 응집도<a aria-hidden="true" tabindex="-1" href="#계층적-응집도" class="internal"> §</a></h3>
<ul>
<li>연관된 서비스들을 하나의 계층에 넣고 다른것들은 배제하는 것</li>
<li>여기서 계층과 모듈과의 차이점 은 상위계층에서 하위 계층의 서비스를 이용할 수는 있지만 그 반대는 안된다는 것이다</li>
<li>상호작용 인터페이스만 유지하면 다른 층에 영향을 주지 않고 계층을 변경할 수 있다는 장점 이 있다</li>
</ul>
<h3 id="순차적-응집도">순차적 응집도<a aria-hidden="true" tabindex="-1" href="#순차적-응집도" class="internal"> §</a></h3>
<ul>
<li>프로시저가 순차적으로 실행되며 우선적으로 실행된 프로시저의 결과물이 이후에 실행되는 프로시저에 사용될 경우 <strong>순차적 응집도</strong> 가 가깝다고 한다</li>
</ul>
<h3 id="교환적-응집도">교환적 응집도<a aria-hidden="true" tabindex="-1" href="#교환적-응집도" class="internal"> §</a></h3>
<ul>
<li>교환적 응집도는 클래스 생각하면 이해하기 쉬움</li>
<li>특정 데이터에 조작하는 애들끼리 모아놓고</li>
<li>해당 모듈이 그 데이터를 조작하는 것 외에는 별다른 일을 하지 않을 경우 <strong>교환적 응집도</strong> 가 올라간다</li>
<li>객체지향의 큰 장점 중 하나는 교환적 응집을 보장한다는 것 이다</li>
</ul>
<h3 id="절차적-응집도">절차적 응집도<a aria-hidden="true" tabindex="-1" href="#절차적-응집도" class="internal"> §</a></h3>
<ul>
<li>차례로 수행되는 프로시저를 모아놓은 경우</li>
<li>순차적 응집도와의 차이점은 순차적 응집도는 차례로 수행되는 것 외에도 데이터도 같이 이동하며 묶여있어야 되고</li>
<li>절차적 응집도의 경우에는 순서대로만 수행되면 되는 것</li>
</ul>
<h3 id="시간적-응집도">시간적 응집도<a aria-hidden="true" tabindex="-1" href="#시간적-응집도" class="internal"> §</a></h3>
<ul>
<li>비슷한 시점에 작동할 프로시저들을 모아놓은 것</li>
<li>시스템 시작시에 초기화해주는 역할을 하는 애들 한곳에 모아놓는거 생각하면 된다</li>
</ul>
<h3 id="실용적-응집도">실용적 응집도<a aria-hidden="true" tabindex="-1" href="#실용적-응집도" class="internal"> §</a></h3>
<ul>
<li>그냥 뭐 어디에 넣기 애매한 유틸리티같은거 걍 한곳에 다 때려박은 것을 의미함</li>
</ul>
<h2 id="설계-원리3-결합력-낮춤">설계 원리3: 결합력 낮춤<a aria-hidden="true" tabindex="-1" href="#설계-원리3-결합력-낮춤" class="internal"> §</a></h2>
<ul>
<li>두 모듈 사이에 결합이 있다는 것은 모듈 간 의존관계가 있다는 것이다</li>
<li>의존관계가 있으면 한쪽의 변경이 다른 한쪽한테 영향을 주기 때문에 결합은 낮으면 낮을수록 좋음</li>
<li>또한 의존관계가 높으면 컴포넌트들이 어떻게 수행되는지 파악하기도 힘들다</li>
</ul>
<p><img src="../../../../gardens/sw-eng/originals/softwareengineering.fall.2021.cse.cnu.ac.kr/images/07_b3edbc1c80984b7987c022f877a5b043/image4.png" alt="%E1%84%8B%E1%85%B5%E1%84%85%E1%85%A9%E1%86%AB08%20-%20%E1%84%8B%E1%85%A1%E1%84%8F%E1%85%B5%E1%84%90%E1%85%A6%E1%86%A8%E1%84%8E%E1%85%A7%20%E1%84%83%E1%85%B5%E1%84%8C%E1%85%A1%E1%84%8B%E1%85%B5%E1%86%AB(1)%20b3edbc1c80984b7987c022f877a5b043/image4.png"/></p>
<ul>
<li>위의 그림에서 위에 있는 결합일수록 결합력이 높고 더 안좋다. 반면, 아래에 있는 결합일수록 결합력이 낮고 더 좋다.</li>
</ul>
<h3 id="내용결합">내용결합<a aria-hidden="true" tabindex="-1" href="#내용결합" class="internal"> §</a></h3>
<ul>
<li>이건 한 컴포넌트가 다른 컴포넌트의 내부 데이터를 비밀리에 수정하는 것으로</li>
<li>클래스의 property를 getter나 setter를 사용하지 않고 수정할 경우에 내용결합이 생긴다고 예시를 들 수 있다</li>
</ul>
<h3 id="공통결합">공통결합<a aria-hidden="true" tabindex="-1" href="#공통결합" class="internal"> §</a></h3>
<ul>
<li>이건 전역변수와 연관된 결합으로 전역변수를 선언한 모듈은 그걸 사용하는 모든 모듈과 결합됨</li>
<li>시스템 전체사 사용하는 디폴트 값이나 상수의 경우에는 허용한다</li>
<li>Singleton Pattern 은 어떤 객체를 전역으로 딱 하나만 생성되게 해서 캡슐화된 전역 변수, 즉, 공통결합의 부작용이 적은 전역변수를 생성할 수 있게씀 한다</li>
</ul>
<h3 id="제어결합">제어결합<a aria-hidden="true" tabindex="-1" href="#제어결합" class="internal"> §</a></h3>
<ul>
<li>제어 결합은 뭐 함수의 인자로 플래그나 커맨드같은걸 받아서 그거에 따라 어떤 함수가 호출될지 결정하는 패턴으로 설계를 했을 때 나타날 수 있는 결합이다</li>
<li>그래서 플래그를 줘서 함수를 호출하는 방식보다는 그냥 그 함수를 Call하는 부분에서 if문으로 함수를 직접적으로 호출하거나</li>
<li>인터페이스를 만들어서 상속받은 다음 동작의 구분을 객체의 종류에 따라 다르게 해주는 <strong>다형성</strong>을 이용한 방식을 사용하면 더 좋다</li>
</ul>
<h3 id="스탬프-결합">스탬프 결합<a aria-hidden="true" tabindex="-1" href="#스탬프-결합" class="internal"> §</a></h3>
<ul>
<li>얘는 클래스를 매개변수로 주는 경우에 해당하는데 여기서 중요한 점은</li>
<li>매개변수로 받은 클래스의 모든 Property중 일부만 사용해야 한다는 것이다</li>
<li>이것이 문제가 되는 이유는 클래스의 노출시킬필요가 없는 것들까지 노출되기 때문</li>
<li>따라서 이것을 해결하는 방법은 그냥 그 클래스 내에서 사용하는 Property들만 을 원시 자료형 매개변수로 각각 주거나</li>
<li>아니면 사용하는 Property만을 따로 모은 인터페이스 등을 정의해서 인자로 주는 것이 좋다</li>
</ul>
<h3 id="데이터-결합자료-결합">데이터 결합(자료 결합)<a aria-hidden="true" tabindex="-1" href="#데이터-결합자료-결합" class="internal"> §</a></h3>
<ul>
<li>이건 원시 자료형을 매개변수로 주는 경우인데</li>
<li>일단 스탬프와의 차이점은 얘는 매개변수로 클래스를 받더라도 클래스의 모든 Property를 메소드 내에서 사용한다는 점이다</li>
<li>근데 이때 원시자료형을 쓰는게 무조건 좋은건 아니고 매개변수의 갯수가 많아질수록 결합력은 높아짐 - 따라서 매개변수가 너무 많을때는 차라리 스탬프 결합을 이용하는 것이 더 결합력을 낮추는 방법이 된다</li>
</ul>
<h3 id="루틴-호출-결합">루틴 호출 결합<a aria-hidden="true" tabindex="-1" href="#루틴-호출-결합" class="internal"> §</a></h3>
<ul>
<li>얘는 어느 메소드에서 다른 메소드를 호출하는 경우이다</li>
<li>이것 또한 호출되는 메소드의 변경이 호출하는 메소드의 변경을 가져오기 때문에 어느정도 결합력이 있다고 생각할 수 있음</li>
<li>즉, 루틴 호출 결합은 어느 시스템에나 존재하게 된다</li>
<li>만일 두개 이상의 메소드를 반복적으로 호출한다면 그것들을 하나의 메소드로 뺀 다음 걔를 호출하는 것이 루틴 호출 결합을 줄이는 방법이 된다</li>
</ul>
<h3 id="타입-사용-결합">타입 사용 결합<a aria-hidden="true" tabindex="-1" href="#타입-사용-결합" class="internal"> §</a></h3>
<ul>
<li>얘는 다른 모듈에서 선언된 타입(자료형)을 불러다 쓰는 경우를 말하는데</li>
<li>얘도 타입의 정의가 바뀌면 그걸 불러서 사용하는 놈에게도 영향이 가기 때문에 결합력이 생기는거다</li>
<li>그래서 이때 결합력을 줄이는 방법은 최대한 포괄적이고 상위에 있는 자료형(클래스)를 사용해 자료형의 변경에도 의연하게 대처할 수 있도록 하면 된다</li>
</ul>
<h3 id="포함-결합">포함 결합<a aria-hidden="true" tabindex="-1" href="#포함-결합" class="internal"> §</a></h3>
<ul>
<li>얘는 그냥 모듈 import하는 경우 생기는 결합력에 관한 것이다</li>
</ul>
<h3 id="외부-결합">외부 결합<a aria-hidden="true" tabindex="-1" href="#외부-결합" class="internal"> §</a></h3>
<ul>
<li>얘는 모듈이 특정 운영체제, 하드웨어에 의존하는 경우 생기는 결합력이다</li>
<li>따라서 특정 운영체제나 하드웨어에 의존하지 않도록 코드를 짜거나 그러한 라이브러리를 사용하는 것으로 낮출 수 있다</li>
</ul>
<h2 id="설계-원리4-높은-수준의-추상화">설계 원리4: 높은 수준의 추상화<a aria-hidden="true" tabindex="-1" href="#설계-원리4-높은-수준의-추상화" class="internal"> §</a></h2>
<ul>
<li>이것은 정보 은닉을 통해 구체적이고 상세한 부분은 감춰져야 한다는 것이다</li>
</ul>
<h3 id="추상화와-클래스">추상화와 클래스<a aria-hidden="true" tabindex="-1" href="#추상화와-클래스" class="internal"> §</a></h3>
<ul>
<li>클래스는 자료와 프로시저를 추상화할 수 있다는 강점이 있는 자료형</li>
<li>추상성을 높이기 위해서는</li>
<li>private변수를 늘려야 하고</li>
<li>메소드의 숫자를 줄이고</li>
<li>사용하고자할때 되도록이면 슈퍼클래스나 인터페이스를 사용하거나</li>
<li>메소드의 매개변수의 갯수를 줄이는 것으로</li>
<li>추상성을 높일 수 있다</li>
</ul>
<h2 id="설계-원리5-재사용성-증진">설계 원리5: 재사용성 증진<a aria-hidden="true" tabindex="-1" href="#설계-원리5-재사용성-증진" class="internal"> §</a></h2>
<ul>
<li>다른 상황에서도 재사용할 수 있도록 설계하는 것</li>
<li>설계를 일반화, 단순화하고</li>
<li>응집도와 추상화는 높게, 결합도는 낮게</li>
<li>사용자의 기호에 따라 기능을 추가할 수 있도록 <strong>Hook</strong>를 추가하랜다</li>
</ul>
<h2 id="설계-원리6-설계와-코드의-재사용">설계 원리6: 설계와 코드의 재사용<a aria-hidden="true" tabindex="-1" href="#설계-원리6-설계와-코드의-재사용" class="internal"> §</a></h2>
<ul>
<li>설계할때 기존의 코드를 최대한 재사용하는 방향으로 설계하는 것이 좋음</li>
</ul>
<h2 id="설계-원리7-유연성-고려">설계 원리7: 유연성 고려<a aria-hidden="true" tabindex="-1" href="#설계-원리7-유연성-고려" class="internal"> §</a></h2>
<ul>
<li>코드가 나중에 바뀌거나 요구사항이 변경될 가능성을 항상 고려해야 된다</li>
<li>이걸 높이기 위해서는 재사용성 증진과 비슷하게</li>
<li>설계를 일반화, 단순화하고</li>
<li>응집도와 추상화는 높게, 결합도는 낮게</li>
<li>상수의 경우에는 하드코딩을 하지 말고</li>
<li>사용자의 기호에 따라 기능을 추가할 수 있도록 <strong>Hook</strong>를 추가하거나 선택의 여지를 남기는 방향으로 설계하랜다</li>
</ul>
<h2 id="설계-원리8-노후화-예측">설계 원리8: 노후화 예측<a aria-hidden="true" tabindex="-1" href="#설계-원리8-노후화-예측" class="internal"> §</a></h2>
<ul>
<li>시스템은 항상 노후화되기 때문에 기술이나 환경에 변화에 유연하게 대처할 수 있게 설계하고 변경될 여지가 많은 기술이나 환경을 사용하는 것은 피해야 한다</li>
<li>즉, 기술의 초기 배포판을 사용하거나 특정한 환경에서만 사용할 수 있는 라이브러리를 사용하는 것, Deprecated될 가능성이 많은 기능이나 장기간의 지원을 제공할 가능성이 낮은 회사가 제공하는 기술을 사용하는 것을 피해야 한다</li>
</ul>
<h2 id="설계-원리9-이식성-고려">설계 원리9: 이식성 고려<a aria-hidden="true" tabindex="-1" href="#설계-원리9-이식성-고려" class="internal"> §</a></h2>
<ul>
<li>운영체제, 플랫폼, 아키텍쳐에 종속적인 기능의 사용을 피하고 가능하면 많은 플랫폼에서 실행할 수 있는 기능을 사용해야 한다</li>
</ul>
<h2 id="설계-원리10-테스트-가능성-고려">설계 원리10: 테스트 가능성 고려<a aria-hidden="true" tabindex="-1" href="#설계-원리10-테스트-가능성-고려" class="internal"> §</a></h2>
<ul>
<li>테스트가 쉽고 자동적으로 이루어질 수 있도록 하고, GUI를 통한 테스트를 되도록이면 피할 수 있게 설계해야된다</li>
</ul>
<h2 id="설계-원리11-방어적인-설계">설계 원리11: 방어적인 설계<a aria-hidden="true" tabindex="-1" href="#설계-원리11-방어적인-설계" class="internal"> §</a></h2>
<ul>
<li>컴포넌트를 부적절하게 사용할 경우에 대비하고 input validation등의 방법이나 precondition check 등의 방법을 이용해라</li>
</ul>
<h3 id="계약에-의한-설계">계약에 의한 설계<a aria-hidden="true" tabindex="-1" href="#계약에-의한-설계" class="internal"> §</a></h3>
<ul>
<li>이건 설계를 할 때 메소드 하나에 대해 다음과 같은 계약을 맺는다고 생각하면서 설계를 하는 것이다</li>
<li>precondition: 메소드가 호출되기 전에 만족해야 하는 것</li>
<li>postcondition: 메소득 호출된 이후에 만족해야 되는 것</li>
<li>invariant: 메소드 실행 전과 후에 변하지 않아야 하는 것</li>
</ul></article></div><div class="right sidebar"><div class="graph "><h3>Graph View</h3><div class="graph-outer"><div id="graph-container" data-cfg="{&quot;drag&quot;:true,&quot;zoom&quot;:true,&quot;depth&quot;:1,&quot;scale&quot;:1.1,&quot;repelForce&quot;:0.5,&quot;centerForce&quot;:0.3,&quot;linkDistance&quot;:30,&quot;fontSize&quot;:0.6,&quot;opacityScale&quot;:1,&quot;showTags&quot;:true,&quot;removeTags&quot;:[]}"></div><svg version="1.1" id="global-graph-icon" xmlns="http://www.w3.org/2000/svg" xmlnsXlink="http://www.w3.org/1999/xlink" x="0px" y="0px" viewBox="0 0 55 55" fill="currentColor" xmlSpace="preserve"><path d="M49,0c-3.309,0-6,2.691-6,6c0,1.035,0.263,2.009,0.726,2.86l-9.829,9.829C32.542,17.634,30.846,17,29,17
	s-3.542,0.634-4.898,1.688l-7.669-7.669C16.785,10.424,17,9.74,17,9c0-2.206-1.794-4-4-4S9,6.794,9,9s1.794,4,4,4
	c0.74,0,1.424-0.215,2.019-0.567l7.669,7.669C21.634,21.458,21,23.154,21,25s0.634,3.542,1.688,4.897L10.024,42.562
	C8.958,41.595,7.549,41,6,41c-3.309,0-6,2.691-6,6s2.691,6,6,6s6-2.691,6-6c0-1.035-0.263-2.009-0.726-2.86l12.829-12.829
	c1.106,0.86,2.44,1.436,3.898,1.619v10.16c-2.833,0.478-5,2.942-5,5.91c0,3.309,2.691,6,6,6s6-2.691,6-6c0-2.967-2.167-5.431-5-5.91
	v-10.16c1.458-0.183,2.792-0.759,3.898-1.619l7.669,7.669C41.215,39.576,41,40.26,41,41c0,2.206,1.794,4,4,4s4-1.794,4-4
	s-1.794-4-4-4c-0.74,0-1.424,0.215-2.019,0.567l-7.669-7.669C36.366,28.542,37,26.846,37,25s-0.634-3.542-1.688-4.897l9.665-9.665
	C46.042,11.405,47.451,12,49,12c3.309,0,6-2.691,6-6S52.309,0,49,0z M11,9c0-1.103,0.897-2,2-2s2,0.897,2,2s-0.897,2-2,2
	S11,10.103,11,9z M6,51c-2.206,0-4-1.794-4-4s1.794-4,4-4s4,1.794,4,4S8.206,51,6,51z M33,49c0,2.206-1.794,4-4,4s-4-1.794-4-4
	s1.794-4,4-4S33,46.794,33,49z M29,31c-3.309,0-6-2.691-6-6s2.691-6,6-6s6,2.691,6,6S32.309,31,29,31z M47,41c0,1.103-0.897,2-2,2
	s-2-0.897-2-2s0.897-2,2-2S47,39.897,47,41z M49,10c-2.206,0-4-1.794-4-4s1.794-4,4-4s4,1.794,4,4S51.206,10,49,10z"></path></svg></div><div id="global-graph-outer"><div id="global-graph-container" data-cfg="{&quot;drag&quot;:true,&quot;zoom&quot;:true,&quot;depth&quot;:-1,&quot;scale&quot;:0.9,&quot;repelForce&quot;:0.5,&quot;centerForce&quot;:0.3,&quot;linkDistance&quot;:30,&quot;fontSize&quot;:0.6,&quot;opacityScale&quot;:1,&quot;showTags&quot;:true,&quot;removeTags&quot;:[]}"></div></div></div><div class="toc desktop-only"><button type="button" id="toc"><h3>Table of Contents</h3><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="fold"><polyline points="6 9 12 15 18 9"></polyline></svg></button><div id="toc-content"><ul class="overflow"><li class="depth-0"><a href="#아키텍쳐-설계" data-for="아키텍쳐-설계">아키텍쳐 설계</a></li><li class="depth-1"><a href="#design-space" data-for="design-space">Design Space</a></li><li class="depth-1"><a href="#설계를-구성하는-요소들" data-for="설계를-구성하는-요소들">설계를 구성하는 요소들</a></li><li class="depth-1"><a href="#상향식-설계--하향식-설계" data-for="상향식-설계--하향식-설계">상향식 설계 / 하향식 설계</a></li><li class="depth-1"><a href="#설계의-종류" data-for="설계의-종류">설계의 종류</a></li><li class="depth-0"><a href="#설계-원리1--divide--conquer" data-for="설계-원리1--divide--conquer">설계 원리1 : Divide &amp; Conquer</a></li><li class="depth-0"><a href="#설계-원리2-응집력-향상" data-for="설계-원리2-응집력-향상">설계 원리2: 응집력 향상</a></li><li class="depth-1"><a href="#기능적-응집도" data-for="기능적-응집도">기능적 응집도</a></li><li class="depth-1"><a href="#계층적-응집도" data-for="계층적-응집도">계층적 응집도</a></li><li class="depth-1"><a href="#순차적-응집도" data-for="순차적-응집도">순차적 응집도</a></li><li class="depth-1"><a href="#교환적-응집도" data-for="교환적-응집도">교환적 응집도</a></li><li class="depth-1"><a href="#절차적-응집도" data-for="절차적-응집도">절차적 응집도</a></li><li class="depth-1"><a href="#시간적-응집도" data-for="시간적-응집도">시간적 응집도</a></li><li class="depth-1"><a href="#실용적-응집도" data-for="실용적-응집도">실용적 응집도</a></li><li class="depth-0"><a href="#설계-원리3-결합력-낮춤" data-for="설계-원리3-결합력-낮춤">설계 원리3: 결합력 낮춤</a></li><li class="depth-1"><a href="#내용결합" data-for="내용결합">내용결합</a></li><li class="depth-1"><a href="#공통결합" data-for="공통결합">공통결합</a></li><li class="depth-1"><a href="#제어결합" data-for="제어결합">제어결합</a></li><li class="depth-1"><a href="#스탬프-결합" data-for="스탬프-결합">스탬프 결합</a></li><li class="depth-1"><a href="#데이터-결합자료-결합" data-for="데이터-결합자료-결합">데이터 결합(자료 결합)</a></li><li class="depth-1"><a href="#루틴-호출-결합" data-for="루틴-호출-결합">루틴 호출 결합</a></li><li class="depth-1"><a href="#타입-사용-결합" data-for="타입-사용-결합">타입 사용 결합</a></li><li class="depth-1"><a href="#포함-결합" data-for="포함-결합">포함 결합</a></li><li class="depth-1"><a href="#외부-결합" data-for="외부-결합">외부 결합</a></li><li class="depth-0"><a href="#설계-원리4-높은-수준의-추상화" data-for="설계-원리4-높은-수준의-추상화">설계 원리4: 높은 수준의 추상화</a></li><li class="depth-1"><a href="#추상화와-클래스" data-for="추상화와-클래스">추상화와 클래스</a></li><li class="depth-0"><a href="#설계-원리5-재사용성-증진" data-for="설계-원리5-재사용성-증진">설계 원리5: 재사용성 증진</a></li><li class="depth-0"><a href="#설계-원리6-설계와-코드의-재사용" data-for="설계-원리6-설계와-코드의-재사용">설계 원리6: 설계와 코드의 재사용</a></li><li class="depth-0"><a href="#설계-원리7-유연성-고려" data-for="설계-원리7-유연성-고려">설계 원리7: 유연성 고려</a></li><li class="depth-0"><a href="#설계-원리8-노후화-예측" data-for="설계-원리8-노후화-예측">설계 원리8: 노후화 예측</a></li><li class="depth-0"><a href="#설계-원리9-이식성-고려" data-for="설계-원리9-이식성-고려">설계 원리9: 이식성 고려</a></li><li class="depth-0"><a href="#설계-원리10-테스트-가능성-고려" data-for="설계-원리10-테스트-가능성-고려">설계 원리10: 테스트 가능성 고려</a></li><li class="depth-0"><a href="#설계-원리11-방어적인-설계" data-for="설계-원리11-방어적인-설계">설계 원리11: 방어적인 설계</a></li><li class="depth-1"><a href="#계약에-의한-설계" data-for="계약에-의한-설계">계약에 의한 설계</a></li></ul></div></div><div class="backlinks "><h3>Backlinks</h3><ul class="overflow"><li><a href="../../../../gardens/sw-eng/originals/softwareengineering.fall.2021.cse.cnu.ac.kr/(충남대)-소프트웨어-공학-강의록" class="internal">(충남대) 소프트웨어 공학 강의록</a></li></ul></div></div></div><footer class><hr/><p>Created with <a href="https://quartz.jzhao.xyz/">Quartz v4.1.0</a>, © 2024</p><ul><li><a href="https://github.com/haeramkeem">GitHub</a></li><li><a href="www.linkedin.com/in/haeram-kim-277404220">LinkedIn</a></li><li><a href="mailto:haeram.kim1@gmail.com">Email</a></li></ul></footer></div></body><script type="application/javascript">// quartz/components/scripts/quartz/components/scripts/callout.inline.ts
function toggleCallout() {
  const outerBlock = this.parentElement;
  outerBlock.classList.toggle(`is-collapsed`);
  const collapsed = outerBlock.classList.contains(`is-collapsed`);
  const height = collapsed ? this.scrollHeight : outerBlock.scrollHeight;
  outerBlock.style.maxHeight = height + `px`;
  let current = outerBlock;
  let parent = outerBlock.parentElement;
  while (parent) {
    if (!parent.classList.contains(`callout`)) {
      return;
    }
    const collapsed2 = parent.classList.contains(`is-collapsed`);
    const height2 = collapsed2 ? parent.scrollHeight : parent.scrollHeight + current.scrollHeight;
    parent.style.maxHeight = height2 + `px`;
    current = parent;
    parent = parent.parentElement;
  }
}
function setupCallout() {
  const collapsible = document.getElementsByClassName(
    `callout is-collapsible`
  );
  for (const div of collapsible) {
    const title = div.firstElementChild;
    if (title) {
      title.removeEventListener(`click`, toggleCallout);
      title.addEventListener(`click`, toggleCallout);
      const collapsed = div.classList.contains(`is-collapsed`);
      const height = collapsed ? title.scrollHeight : div.scrollHeight;
      div.style.maxHeight = height + `px`;
    }
  }
}
document.addEventListener(`nav`, setupCallout);
window.addEventListener(`resize`, setupCallout);
</script><script type="module">
          import mermaid from 'https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.esm.min.mjs';
          const darkMode = document.documentElement.getAttribute('saved-theme') === 'dark'
          mermaid.initialize({
            startOnLoad: false,
            securityLevel: 'loose',
            theme: darkMode ? 'dark' : 'default'
          });
          document.addEventListener('nav', async () => {
            await mermaid.run({
              querySelector: '.mermaid'
            })
          });
          </script><script src="https://cdn.jsdelivr.net/npm/katex@0.16.7/dist/contrib/copy-tex.min.js" type="application/javascript"></script><script src="https://www.googletagmanager.com/gtag/js?id=G-N68CCP1QHG" type="application/javascript"></script><script src="../../../../postscript.js" type="module"></script></html>